<html>
<header><link rel='stylesheet' href='api.css'></header>
<body>
<h1>Teardown scripting API (1.7.0)</h1>
<h2>Teardown scripting</h2>
<p>
Teardown uses Lua version 5.1 as scripting language. The Lua 5.1 reference manual can be found <a href="https://www.lua.org/manual/5.1/">here</a>. 
Each Teardown script runs in its own Lua context and can only interact with the engine and other scripts 
through API functions and the registry. The registry is a database of hierarchical global variables that is used both internally
in the engine, for communication between scripts and as a way to save persistent data. 
<p>
The Teardown API uses only native lua types. Handles to objects are plain Lua numbers. Vector types are represented
as plain Lua tables, and so on. Each script has up-to 6 OPTIONAL callback functions that will be called by the game engine.
<p>
<table border=0><tr><td class='header'>&nbsp;Function&nbsp;	</td><td class='header'>&nbsp;Description</td></tr>
<tr><td class='first' valign='top'>function&nbsp;init()			</td><td valign='top'> Called once at load time</td></tr><tr><td class='first' valign='top'>function&nbsp;tick(dt)		</td><td valign='top'> Called exactly once per frame. The time step is variable but always between 0.0 and 0.0333333</td></tr><tr><td class='first' valign='top'>function&nbsp;update(dt)&nbsp;	</td><td valign='top'> Called at a fixed update rate, but at the most two times per frame. Time step is always 0.0166667 (60 updates per second). Depending on frame rate it might not be called at all for a particular frame.</td></tr><tr><td class='first' valign='top'>function&nbsp;draw()			</td><td valign='top'> Called when the 2D overlay is being draw, after the scene but before the standard HUD. Ui functions can only be used from this callback.</td></tr><tr><td class='first' valign='top'>function&nbsp;render(dt)		</td><td valign='top'> Called exactly once per frame, right before things are actually drawn to the screen.</td></tr><tr><td class='first' valign='top'>function&nbsp;postUpdate()&nbsp;	</td><td valign='top'> Called like update, but after physics. Because update can trigger physics updates, it can be necessary to do some additional calculations afterwards. This is usually used by animators.</td></tr><table/>
<p>
<p>

<p>
<hr/>
<h2>Parameters</h2>
<p>
Scripts can have parameters defined in the level XML file. These serve as
input to a specific instance of the script and can be used to configure
various options and parameters of the script. While these parameters can
be read at any time in the script, it's recommended to copy them to a global
variable in or outside the init function.
<p>

<p>
<a href='#GetIntParam'>GetIntParam</a></br>
<a href='#GetFloatParam'>GetFloatParam</a></br>
<a href='#GetBoolParam'>GetBoolParam</a></br>
<a href='#GetStringParam'>GetStringParam</a></br>
<a href='#GetColorParam'>GetColorParam</a></br>
<hr/>
<h2>Script control</h2>
<p>
General functions that control the operation and flow of the script.
<table border=0><tr><td class='header'>&nbsp;Physical&nbsp;input&nbsp;</td><td class='header'>&nbsp;Description</td></tr>
<tr><td class='first' valign='top'>esc				</td><td valign='top'> Escape key</td></tr><tr><td class='first' valign='top'>tab				</td><td valign='top'> Tab key</td></tr><tr><td class='first' valign='top'>lmb				</td><td valign='top'> Left mouse button</td></tr><tr><td class='first' valign='top'>rmb				</td><td valign='top'> Right mouse button</td></tr><tr><td class='first' valign='top'>mmb				</td><td valign='top'> Middle mouse button</td></tr><tr><td class='first' valign='top'>uparrow			</td><td valign='top'> Up arrow key</td></tr><tr><td class='first' valign='top'>downarrow		</td><td valign='top'> Down arrow key</td></tr><tr><td class='first' valign='top'>leftarrow		</td><td valign='top'> Left arrow key</td></tr><tr><td class='first' valign='top'>rightarrow		</td><td valign='top'> Right arrow key</td></tr><tr><td class='first' valign='top'>f1-f12			</td><td valign='top'> Function keys</td></tr><tr><td class='first' valign='top'>backspace		</td><td valign='top'> Backspace key</td></tr><tr><td class='first' valign='top'>alt				</td><td valign='top'> Alt key</td></tr><tr><td class='first' valign='top'>delete			</td><td valign='top'> Delete key</td></tr><tr><td class='first' valign='top'>home			</td><td valign='top'> Home key</td></tr><tr><td class='first' valign='top'>end				</td><td valign='top'> End key</td></tr><tr><td class='first' valign='top'>pgup			</td><td valign='top'> Pgup key</td></tr><tr><td class='first' valign='top'>pgdown			</td><td valign='top'> Pgdown key</td></tr><tr><td class='first' valign='top'>insert			</td><td valign='top'> Insert key</td></tr><tr><td class='first' valign='top'>space			</td><td valign='top'> Space bar</td></tr><tr><td class='first' valign='top'>shift			</td><td valign='top'> Shift key</td></tr><tr><td class='first' valign='top'>ctrl			</td><td valign='top'> Ctrl key</td></tr><tr><td class='first' valign='top'>return			</td><td valign='top'> Return key</td></tr><tr><td class='first' valign='top'>any				</td><td valign='top'> Any key or button</td></tr><tr><td class='first' valign='top'>a,b,c,...		</td><td valign='top'> Latin, alphabetical keys a through z</td></tr><tr><td class='first' valign='top'>0-9				</td><td valign='top'> Digits, zero to nine</td></tr><tr><td class='first' valign='top'>mousedx			</td><td valign='top'> Mouse horizontal diff. Only valid in InputValue.</td></tr><tr><td class='first' valign='top'>mousedy			</td><td valign='top'> Mouse vertical diff. Only valid in InputValue.</td></tr><tr><td class='first' valign='top'>mousewheel		</td><td valign='top'> Mouse wheel. Only valid in InputValue.</td></tr><table/>
<p>
<table border=0><tr><td class='header'>&nbsp;Logical&nbsp;input&nbsp;</td><td class='header'>&nbsp;Description</td></tr>
<tr><td class='first' valign='top'>up				</td><td valign='top'> Move forward / Accelerate</td></tr><tr><td class='first' valign='top'>down			</td><td valign='top'> Move backward / Brake</td></tr><tr><td class='first' valign='top'>left			</td><td valign='top'> Move left</td></tr><tr><td class='first' valign='top'>right			</td><td valign='top'> Move right</td></tr><tr><td class='first' valign='top'>interact		</td><td valign='top'> Interact</td></tr><tr><td class='first' valign='top'>flashlight		</td><td valign='top'> Flashlight</td></tr><tr><td class='first' valign='top'>jump			</td><td valign='top'> Jump</td></tr><tr><td class='first' valign='top'>crouch			</td><td valign='top'> Crouch</td></tr><tr><td class='first' valign='top'>usetool			</td><td valign='top'> Use tool</td></tr><tr><td class='first' valign='top'>grab			</td><td valign='top'> Grab</td></tr><tr><td class='first' valign='top'>handbrake		</td><td valign='top'> Handbrake</td></tr><tr><td class='first' valign='top'>map				</td><td valign='top'> Map</td></tr><tr><td class='first' valign='top'>pause			</td><td valign='top'> Pause game (escape)</td></tr><tr><td class='first' valign='top'>vehicleraise	</td><td valign='top'> Raise vehicle parts</td></tr><tr><td class='first' valign='top'>vehiclelower	</td><td valign='top'> Lower vehicle parts</td></tr><tr><td class='first' valign='top'>vehicleaction	</td><td valign='top'> Vehicle action</td></tr><tr><td class='first' valign='top'>camerax			</td><td valign='top'> Camera x movement, scaled by sensitivity. Only valid in InputValue.</td></tr><tr><td class='first' valign='top'>cameray			</td><td valign='top'> Camera y movement, scaled by sensitivity. Only valid in InputValue.</td></tr><tr><td class='first' valign='top'>tool_group_prev	</td><td valign='top'> Switch to previous tool group</td></tr><tr><td class='first' valign='top'>tool_group_next	</td><td valign='top'> Switch to next tool group</td></tr><tr><td class='first' valign='top'>extra0			</td><td valign='top'> Extra action 0</td></tr><tr><td class='first' valign='top'>extra1			</td><td valign='top'> Extra action 1</td></tr><tr><td class='first' valign='top'>extra2			</td><td valign='top'> Extra action 2</td></tr><tr><td class='first' valign='top'>extra3			</td><td valign='top'> Extra action 3</td></tr><tr><td class='first' valign='top'>extra4			</td><td valign='top'> Extra action 4</td></tr><tr><td class='first' valign='top'>extra5			</td><td valign='top'> Extra action 5</td></tr><tr><td class='first' valign='top'>extra6			</td><td valign='top'> Extra action 6</td></tr><tr><td class='first' valign='top'>photomode		</td><td valign='top'> Photomode</td></tr><tr><td class='first' valign='top'>zoom			</td><td valign='top'> Zoom</td></tr><tr><td class='first' valign='top'>menu_left		</td><td valign='top'> Menu left</td></tr><tr><td class='first' valign='top'>menu_right		</td><td valign='top'> Menu right</td></tr><tr><td class='first' valign='top'>menu_up			</td><td valign='top'> Menu up</td></tr><tr><td class='first' valign='top'>menu_down		</td><td valign='top'> Menu down</td></tr><tr><td class='first' valign='top'>menu_next		</td><td valign='top'> Menu next</td></tr><tr><td class='first' valign='top'>menu_prev		</td><td valign='top'> Menu prev</td></tr><tr><td class='first' valign='top'>menu_accept		</td><td valign='top'> Menu accept</td></tr><tr><td class='first' valign='top'>menu_cancel		</td><td valign='top'> Menu cancel</td></tr><table/>
<p>

<p>
<a href='#GetVersion'>GetVersion</a></br>
<a href='#HasVersion'>HasVersion</a></br>
<a href='#GetTime'>GetTime</a></br>
<a href='#GetTimeStep'>GetTimeStep</a></br>
<a href='#InputLastPressedKey'>InputLastPressedKey</a></br>
<a href='#InputPressed'>InputPressed</a></br>
<a href='#InputReleased'>InputReleased</a></br>
<a href='#InputDown'>InputDown</a></br>
<a href='#InputValue'>InputValue</a></br>
<a href='#InputClear'>InputClear</a></br>
<a href='#InputResetOnTransition'>InputResetOnTransition</a></br>
<a href='#LastInputDevice'>LastInputDevice</a></br>
<a href='#SetValue'>SetValue</a></br>
<a href='#SetValueInTable'>SetValueInTable</a></br>
<a href='#PauseMenuButton'>PauseMenuButton</a></br>
<a href='#HasFile'>HasFile</a></br>
<a href='#StartLevel'>StartLevel</a></br>
<a href='#SetPaused'>SetPaused</a></br>
<a href='#Restart'>Restart</a></br>
<a href='#Menu'>Menu</a></br>
<hr/>
<h2>Registry</h2>
<p>
The Teardown engine uses a global key/value-pair registry that scripts
can read and write. The engine exposes a lot of internal information through
the registry, but it can also be used as way for scripts to communicate with
each other.
<p>
The registry is a hierarchical node structure and can store a value in each node (parent nodes can also have a value).
The values can be of type floating point number, integer, boolean or string, but all types are automatically converted if another type is requested.
Some registry nodes are reserved and used for special purposes.
<p>
Registry node names may only contain the characters a-z, numbers 0-9, dot, dash and underscore.
<p>
<table border=0><tr><td class='header'>&nbsp;Key	</td><td class='header'>&nbsp;Description</td></tr>
<tr><td class='first' valign='top'>options			</td><td valign='top'> reserved for game settings (write protected from mods)</td></tr><tr><td class='first' valign='top'>game			</td><td valign='top'> reserved for the game engine internals (see documentation)</td></tr><tr><td class='first' valign='top'>savegame		</td><td valign='top'> used for persistent game data (write protected for mods)</td></tr><tr><td class='first' valign='top'>savegame.mod	</td><td valign='top'> used for persistent mod data. Use only alphanumeric character for key name.</td></tr><tr><td class='first' valign='top'>level			</td><td valign='top'> not reserved, but recommended for level specific entries and script communication</td></tr><table/>
<p>

<p>
<a href='#ClearKey'>ClearKey</a></br>
<a href='#ListKeys'>ListKeys</a></br>
<a href='#HasKey'>HasKey</a></br>
<a href='#SetInt'>SetInt</a></br>
<a href='#GetInt'>GetInt</a></br>
<a href='#SetFloat'>SetFloat</a></br>
<a href='#GetFloat'>GetFloat</a></br>
<a href='#SetBool'>SetBool</a></br>
<a href='#GetBool'>GetBool</a></br>
<a href='#SetString'>SetString</a></br>
<a href='#GetString'>GetString</a></br>
<a href='#GetEventCount'>GetEventCount</a></br>
<a href='#GetEvent'>GetEvent</a></br>
<a href='#SetColor'>SetColor</a></br>
<a href='#GetColor'>GetColor</a></br>
<a href='#GetTranslatedStringByKey'>GetTranslatedStringByKey</a></br>
<a href='#HasTranslationByKey'>HasTranslationByKey</a></br>
<a href='#LoadLanguageTable'>LoadLanguageTable</a></br>
<a href='#GetUserNickname'>GetUserNickname</a></br>
<hr/>
<h2>Vector math</h2>
<p>
Vector math is used in Teardown scripts to represent 3D positions, directions,
rotations and transforms. The base types are vectors, quaternions and transforms.
Vectors and quaternions are indexed tables with three and four components. Transforms
are tables consisting of one vector (pos) and one quaternion (rot)
<p>

<p>
<a href='#Vec'>Vec</a></br>
<a href='#VecCopy'>VecCopy</a></br>
<a href='#VecStr'>VecStr</a></br>
<a href='#VecLength'>VecLength</a></br>
<a href='#VecNormalize'>VecNormalize</a></br>
<a href='#VecScale'>VecScale</a></br>
<a href='#VecAdd'>VecAdd</a></br>
<a href='#VecSub'>VecSub</a></br>
<a href='#VecDot'>VecDot</a></br>
<a href='#VecCross'>VecCross</a></br>
<a href='#VecLerp'>VecLerp</a></br>
<a href='#Quat'>Quat</a></br>
<a href='#QuatCopy'>QuatCopy</a></br>
<a href='#QuatAxisAngle'>QuatAxisAngle</a></br>
<a href='#QuatDeltaNormals'>QuatDeltaNormals</a></br>
<a href='#QuatDeltaVectors'>QuatDeltaVectors</a></br>
<a href='#QuatEuler'>QuatEuler</a></br>
<a href='#QuatAlignXZ'>QuatAlignXZ</a></br>
<a href='#GetQuatEuler'>GetQuatEuler</a></br>
<a href='#QuatLookAt'>QuatLookAt</a></br>
<a href='#QuatSlerp'>QuatSlerp</a></br>
<a href='#QuatStr'>QuatStr</a></br>
<a href='#QuatRotateQuat'>QuatRotateQuat</a></br>
<a href='#QuatRotateVec'>QuatRotateVec</a></br>
<a href='#Transform'>Transform</a></br>
<a href='#TransformCopy'>TransformCopy</a></br>
<a href='#TransformStr'>TransformStr</a></br>
<a href='#TransformToParentTransform'>TransformToParentTransform</a></br>
<a href='#TransformToLocalTransform'>TransformToLocalTransform</a></br>
<a href='#TransformToParentVec'>TransformToParentVec</a></br>
<a href='#TransformToLocalVec'>TransformToLocalVec</a></br>
<a href='#TransformToParentPoint'>TransformToParentPoint</a></br>
<a href='#TransformToLocalPoint'>TransformToLocalPoint</a></br>
<hr/>
<h2>Entity</h2>
<p>
An Entity is the basis of most objects in the Teardown engine (bodies, shapes, lights, locations, etc). 
All entities can have tags, which is a way to store custom properties on entities for scripting purposes.
Some tags are also reserved for engine use. See documentation for details.
<p>

<p>
<a href='#FindEntity'>FindEntity</a></br>
<a href='#FindEntities'>FindEntities</a></br>
<a href='#GetEntityChildren'>GetEntityChildren</a></br>
<a href='#GetEntityParent'>GetEntityParent</a></br>
<a href='#SetTag'>SetTag</a></br>
<a href='#RemoveTag'>RemoveTag</a></br>
<a href='#HasTag'>HasTag</a></br>
<a href='#GetTagValue'>GetTagValue</a></br>
<a href='#ListTags'>ListTags</a></br>
<a href='#GetDescription'>GetDescription</a></br>
<a href='#SetDescription'>SetDescription</a></br>
<a href='#Delete'>Delete</a></br>
<a href='#IsHandleValid'>IsHandleValid</a></br>
<a href='#GetEntityType'>GetEntityType</a></br>
<a href='#GetProperty'>GetProperty</a></br>
<a href='#SetProperty'>SetProperty</a></br>
<hr/>
<h2>Body</h2>
<p>
A body represents a rigid body in the scene. It can be either static or dynamic. Only dynamic bodies are
affected by physics.
<p>

<p>
<a href='#FindBody'>FindBody</a></br>
<a href='#FindBodies'>FindBodies</a></br>
<a href='#GetBodyTransform'>GetBodyTransform</a></br>
<a href='#SetBodyTransform'>SetBodyTransform</a></br>
<a href='#GetBodyMass'>GetBodyMass</a></br>
<a href='#IsBodyDynamic'>IsBodyDynamic</a></br>
<a href='#SetBodyDynamic'>SetBodyDynamic</a></br>
<a href='#SetBodyVelocity'>SetBodyVelocity</a></br>
<a href='#GetBodyVelocity'>GetBodyVelocity</a></br>
<a href='#GetBodyVelocityAtPos'>GetBodyVelocityAtPos</a></br>
<a href='#SetBodyAngularVelocity'>SetBodyAngularVelocity</a></br>
<a href='#GetBodyAngularVelocity'>GetBodyAngularVelocity</a></br>
<a href='#IsBodyActive'>IsBodyActive</a></br>
<a href='#SetBodyActive'>SetBodyActive</a></br>
<a href='#ApplyBodyImpulse'>ApplyBodyImpulse</a></br>
<a href='#GetBodyShapes'>GetBodyShapes</a></br>
<a href='#GetBodyVehicle'>GetBodyVehicle</a></br>
<a href='#GetBodyBounds'>GetBodyBounds</a></br>
<a href='#GetBodyCenterOfMass'>GetBodyCenterOfMass</a></br>
<a href='#IsBodyVisible'>IsBodyVisible</a></br>
<a href='#IsBodyBroken'>IsBodyBroken</a></br>
<a href='#IsBodyJointedToStatic'>IsBodyJointedToStatic</a></br>
<a href='#DrawBodyOutline'>DrawBodyOutline</a></br>
<a href='#DrawBodyHighlight'>DrawBodyHighlight</a></br>
<a href='#GetBodyClosestPoint'>GetBodyClosestPoint</a></br>
<a href='#ConstrainVelocity'>ConstrainVelocity</a></br>
<a href='#ConstrainAngularVelocity'>ConstrainAngularVelocity</a></br>
<a href='#ConstrainPosition'>ConstrainPosition</a></br>
<a href='#ConstrainOrientation'>ConstrainOrientation</a></br>
<a href='#GetWorldBody'>GetWorldBody</a></br>
<hr/>
<h2>Shape</h2>
<p>
A shape is a voxel object and always owned by a body. A single body may contain multiple shapes. The transform
of shape is expressed in the parent body coordinate system.
<p>

<p>
<a href='#FindShape'>FindShape</a></br>
<a href='#FindShapes'>FindShapes</a></br>
<a href='#GetShapeLocalTransform'>GetShapeLocalTransform</a></br>
<a href='#SetShapeLocalTransform'>SetShapeLocalTransform</a></br>
<a href='#GetShapeWorldTransform'>GetShapeWorldTransform</a></br>
<a href='#GetShapeBody'>GetShapeBody</a></br>
<a href='#GetShapeJoints'>GetShapeJoints</a></br>
<a href='#GetShapeLights'>GetShapeLights</a></br>
<a href='#GetShapeBounds'>GetShapeBounds</a></br>
<a href='#SetShapeEmissiveScale'>SetShapeEmissiveScale</a></br>
<a href='#SetShapeDensity'>SetShapeDensity</a></br>
<a href='#GetShapeMaterialAtPosition'>GetShapeMaterialAtPosition</a></br>
<a href='#GetShapeMaterialAtIndex'>GetShapeMaterialAtIndex</a></br>
<a href='#GetShapeSize'>GetShapeSize</a></br>
<a href='#GetShapeVoxelCount'>GetShapeVoxelCount</a></br>
<a href='#IsShapeVisible'>IsShapeVisible</a></br>
<a href='#IsShapeBroken'>IsShapeBroken</a></br>
<a href='#DrawShapeOutline'>DrawShapeOutline</a></br>
<a href='#DrawShapeHighlight'>DrawShapeHighlight</a></br>
<a href='#SetShapeCollisionFilter'>SetShapeCollisionFilter</a></br>
<a href='#GetShapeCollisionFilter'>GetShapeCollisionFilter</a></br>
<a href='#CreateShape'>CreateShape</a></br>
<a href='#ClearShape'>ClearShape</a></br>
<a href='#ResizeShape'>ResizeShape</a></br>
<a href='#SetShapeBody'>SetShapeBody</a></br>
<a href='#CopyShapeContent'>CopyShapeContent</a></br>
<a href='#CopyShapePalette'>CopyShapePalette</a></br>
<a href='#GetShapePalette'>GetShapePalette</a></br>
<a href='#GetShapeMaterial'>GetShapeMaterial</a></br>
<a href='#SetBrush'>SetBrush</a></br>
<a href='#DrawShapeLine'>DrawShapeLine</a></br>
<a href='#DrawShapeBox'>DrawShapeBox</a></br>
<a href='#ExtrudeShape'>ExtrudeShape</a></br>
<a href='#TrimShape'>TrimShape</a></br>
<a href='#SplitShape'>SplitShape</a></br>
<a href='#MergeShape'>MergeShape</a></br>
<a href='#IsShapeDisconnected'>IsShapeDisconnected</a></br>
<a href='#IsStaticShapeDetached'>IsStaticShapeDetached</a></br>
<a href='#GetShapeClosestPoint'>GetShapeClosestPoint</a></br>
<a href='#IsShapeTouching'>IsShapeTouching</a></br>
<hr/>
<h2>Location</h2>
<p>
Locations are transforms placed in the editor as markers. Location transforms are always expressed in 
world space coordinates.
<p>

<p>
<a href='#FindLocation'>FindLocation</a></br>
<a href='#FindLocations'>FindLocations</a></br>
<a href='#GetLocationTransform'>GetLocationTransform</a></br>
<hr/>
<h2>Joint</h2>
<p>
Joints are used to physically connect two shapes. There are several types of joints and they are typically
placed in the editor. When destruction occurs, joints may be transferred to new shapes, detached or
completely disabled.
<p>

<p>
<a href='#FindJoint'>FindJoint</a></br>
<a href='#FindJoints'>FindJoints</a></br>
<a href='#IsJointBroken'>IsJointBroken</a></br>
<a href='#GetJointType'>GetJointType</a></br>
<a href='#GetJointOtherShape'>GetJointOtherShape</a></br>
<a href='#GetJointShapes'>GetJointShapes</a></br>
<a href='#SetJointMotor'>SetJointMotor</a></br>
<a href='#SetJointMotorTarget'>SetJointMotorTarget</a></br>
<a href='#GetJointLimits'>GetJointLimits</a></br>
<a href='#GetJointMovement'>GetJointMovement</a></br>
<a href='#GetJointedBodies'>GetJointedBodies</a></br>
<a href='#DetachJointFromShape'>DetachJointFromShape</a></br>
<a href='#GetRopeNumberOfPoints'>GetRopeNumberOfPoints</a></br>
<a href='#GetRopePointPosition'>GetRopePointPosition</a></br>
<a href='#GetRopeBounds'>GetRopeBounds</a></br>
<a href='#BreakRope'>BreakRope</a></br>
<hr/>
<h2>Animation</h2>
<p>
An animator manages a prefab hierarchy using a matching skeleton and a set of animation sequences. These animations are processed sequentially, generating a "blend-tree."
<p>
There are two types of animations: looping and single-shot. Looping animations must be called every frame to keep them active; otherwise, they will stop. In contrast, single-shot animations are triggered once and will play to completion.
<p>
Single-shot animations are automatically processed after all looping animations, but they can be executed earlier if necessary. To ensure that single-shot animations are processed in the correct order within the blend-tree, an instance API is available.
<p>
Inverse Kinematics (IK) can be used, typically as the final step, to control specific parts of the skeleton, such as reaching for an object.
<p>

<p>
<a href='#SetAnimatorPositionIK'>SetAnimatorPositionIK</a></br>
<a href='#SetAnimatorTransformIK'>SetAnimatorTransformIK</a></br>
<a href='#GetBoneChainLength'>GetBoneChainLength</a></br>
<a href='#FindAnimator'>FindAnimator</a></br>
<a href='#FindAnimators'>FindAnimators</a></br>
<a href='#GetAnimatorTransform'>GetAnimatorTransform</a></br>
<a href='#GetAnimatorAdjustTransformIK'>GetAnimatorAdjustTransformIK</a></br>
<a href='#SetAnimatorTransform'>SetAnimatorTransform</a></br>
<a href='#MakeRagdoll'>MakeRagdoll</a></br>
<a href='#UnRagdoll'>UnRagdoll</a></br>
<a href='#PlayAnimation'>PlayAnimation</a></br>
<a href='#PlayAnimationLoop'>PlayAnimationLoop</a></br>
<a href='#PlayAnimationInstance'>PlayAnimationInstance</a></br>
<a href='#StopAnimationInstance'>StopAnimationInstance</a></br>
<a href='#PlayAnimationFrame'>PlayAnimationFrame</a></br>
<a href='#BeginAnimationGroup'>BeginAnimationGroup</a></br>
<a href='#EndAnimationGroup'>EndAnimationGroup</a></br>
<a href='#PlayAnimationInstances'>PlayAnimationInstances</a></br>
<a href='#GetAnimationClipNames'>GetAnimationClipNames</a></br>
<a href='#GetAnimationClipDuration'>GetAnimationClipDuration</a></br>
<a href='#SetAnimationClipFade'>SetAnimationClipFade</a></br>
<a href='#SetAnimationClipSpeed'>SetAnimationClipSpeed</a></br>
<a href='#TrimAnimationClip'>TrimAnimationClip</a></br>
<a href='#GetAnimationClipLoopPosition'>GetAnimationClipLoopPosition</a></br>
<a href='#GetAnimationInstancePosition'>GetAnimationInstancePosition</a></br>
<a href='#SetAnimationClipLoopPosition'>SetAnimationClipLoopPosition</a></br>
<a href='#SetBoneRotation'>SetBoneRotation</a></br>
<a href='#SetBoneLookAt'>SetBoneLookAt</a></br>
<a href='#RotateBone'>RotateBone</a></br>
<a href='#GetBoneNames'>GetBoneNames</a></br>
<a href='#GetBoneBody'>GetBoneBody</a></br>
<a href='#GetBoneWorldTransform'>GetBoneWorldTransform</a></br>
<a href='#GetBoneBindPoseTransform'>GetBoneBindPoseTransform</a></br>
<hr/>
<h2>Light</h2>
<p>
Light sources can be of several differnt types and configured in the editor. If a light source is owned 
by a shape, the intensity of the light source is scaled by the emissive scale of that shape. If the 
parent shape breaks, the emissive scale is set to zero and the light source is disabled. A light source
without a parent shape will always emit light, unless exlicitly disabled by a script.
<p>

<p>
<a href='#FindLight'>FindLight</a></br>
<a href='#FindLights'>FindLights</a></br>
<a href='#SetLightEnabled'>SetLightEnabled</a></br>
<a href='#SetLightColor'>SetLightColor</a></br>
<a href='#SetLightIntensity'>SetLightIntensity</a></br>
<a href='#GetLightTransform'>GetLightTransform</a></br>
<a href='#GetLightShape'>GetLightShape</a></br>
<a href='#IsLightActive'>IsLightActive</a></br>
<a href='#IsPointAffectedByLight'>IsPointAffectedByLight</a></br>
<a href='#GetFlashlight'>GetFlashlight</a></br>
<a href='#SetFlashlight'>SetFlashlight</a></br>
<hr/>
<h2>Trigger</h2>
<p>
Triggers can be placed in the scene and queried by scripts to see if something is within a certain part
of the scene.
<p>

<p>
<a href='#FindTrigger'>FindTrigger</a></br>
<a href='#FindTriggers'>FindTriggers</a></br>
<a href='#GetTriggerTransform'>GetTriggerTransform</a></br>
<a href='#SetTriggerTransform'>SetTriggerTransform</a></br>
<a href='#GetTriggerBounds'>GetTriggerBounds</a></br>
<a href='#IsBodyInTrigger'>IsBodyInTrigger</a></br>
<a href='#IsVehicleInTrigger'>IsVehicleInTrigger</a></br>
<a href='#IsShapeInTrigger'>IsShapeInTrigger</a></br>
<a href='#IsPointInTrigger'>IsPointInTrigger</a></br>
<a href='#IsPointInBoundaries'>IsPointInBoundaries</a></br>
<a href='#IsTriggerEmpty'>IsTriggerEmpty</a></br>
<a href='#GetTriggerDistance'>GetTriggerDistance</a></br>
<a href='#GetTriggerClosestPoint'>GetTriggerClosestPoint</a></br>
<hr/>
<h2>Screen</h2>
<p>
Screens display the content of UI scripts and can be made interactive.
<p>

<p>
<a href='#FindScreen'>FindScreen</a></br>
<a href='#FindScreens'>FindScreens</a></br>
<a href='#SetScreenEnabled'>SetScreenEnabled</a></br>
<a href='#IsScreenEnabled'>IsScreenEnabled</a></br>
<a href='#GetScreenShape'>GetScreenShape</a></br>
<hr/>
<h2>Vehicle</h2>
<p>
Vehicles are set up in the editor and consists of multiple parts owned by a vehicle entity.
<p>

<p>
<a href='#FindVehicle'>FindVehicle</a></br>
<a href='#FindVehicles'>FindVehicles</a></br>
<a href='#GetVehicleTransform'>GetVehicleTransform</a></br>
<a href='#GetVehicleExhaustTransforms'>GetVehicleExhaustTransforms</a></br>
<a href='#GetVehicleVitalTransforms'>GetVehicleVitalTransforms</a></br>
<a href='#GetVehicleBodies'>GetVehicleBodies</a></br>
<a href='#GetVehicleBody'>GetVehicleBody</a></br>
<a href='#GetVehicleHealth'>GetVehicleHealth</a></br>
<a href='#GetVehicleParams'>GetVehicleParams</a></br>
<a href='#SetVehicleParam'>SetVehicleParam</a></br>
<a href='#GetVehicleDriverPos'>GetVehicleDriverPos</a></br>
<a href='#GetVehicleSteering'>GetVehicleSteering</a></br>
<a href='#GetVehicleDrive'>GetVehicleDrive</a></br>
<a href='#DriveVehicle'>DriveVehicle</a></br>
<hr/>
<h2>Player</h2>
<p>
The player functions expose certain information about the player.
<p>

<p>
<a href='#GetPlayerPos'>GetPlayerPos</a></br>
<a href='#GetPlayerAimInfo'>GetPlayerAimInfo</a></br>
<a href='#GetPlayerPitch'>GetPlayerPitch</a></br>
<a href='#GetPlayerYaw'>GetPlayerYaw</a></br>
<a href='#SetPlayerPitch'>SetPlayerPitch</a></br>
<a href='#GetPlayerCrouch'>GetPlayerCrouch</a></br>
<a href='#GetPlayerTransform'>GetPlayerTransform</a></br>
<a href='#SetPlayerTransform'>SetPlayerTransform</a></br>
<a href='#ClearPlayerRig'>ClearPlayerRig</a></br>
<a href='#SetPlayerRigLocationLocalTransform'>SetPlayerRigLocationLocalTransform</a></br>
<a href='#SetPlayerRigTransform'>SetPlayerRigTransform</a></br>
<a href='#GetPlayerRigTransform'>GetPlayerRigTransform</a></br>
<a href='#GetPlayerRigLocationWorldTransform'>GetPlayerRigLocationWorldTransform</a></br>
<a href='#SetPlayerRigTags'>SetPlayerRigTags</a></br>
<a href='#GetPlayerRigHasTag'>GetPlayerRigHasTag</a></br>
<a href='#GetPlayerRigTagValue'>GetPlayerRigTagValue</a></br>
<a href='#SetPlayerGroundVelocity'>SetPlayerGroundVelocity</a></br>
<a href='#GetPlayerEyeTransform'>GetPlayerEyeTransform</a></br>
<a href='#GetPlayerCameraTransform'>GetPlayerCameraTransform</a></br>
<a href='#SetPlayerCameraOffsetTransform'>SetPlayerCameraOffsetTransform</a></br>
<a href='#SetPlayerSpawnTransform'>SetPlayerSpawnTransform</a></br>
<a href='#SetPlayerSpawnHealth'>SetPlayerSpawnHealth</a></br>
<a href='#SetPlayerSpawnTool'>SetPlayerSpawnTool</a></br>
<a href='#GetPlayerVelocity'>GetPlayerVelocity</a></br>
<a href='#SetPlayerVehicle'>SetPlayerVehicle</a></br>
<a href='#SetPlayerAnimator'>SetPlayerAnimator</a></br>
<a href='#GetPlayerAnimator'>GetPlayerAnimator</a></br>
<a href='#SetPlayerVelocity'>SetPlayerVelocity</a></br>
<a href='#GetPlayerVehicle'>GetPlayerVehicle</a></br>
<a href='#IsPlayerGrounded'>IsPlayerGrounded</a></br>
<a href='#GetPlayerGroundContact'>GetPlayerGroundContact</a></br>
<a href='#GetPlayerGrabShape'>GetPlayerGrabShape</a></br>
<a href='#GetPlayerGrabBody'>GetPlayerGrabBody</a></br>
<a href='#ReleasePlayerGrab'>ReleasePlayerGrab</a></br>
<a href='#GetPlayerGrabPoint'>GetPlayerGrabPoint</a></br>
<a href='#GetPlayerPickShape'>GetPlayerPickShape</a></br>
<a href='#GetPlayerPickBody'>GetPlayerPickBody</a></br>
<a href='#GetPlayerInteractShape'>GetPlayerInteractShape</a></br>
<a href='#GetPlayerInteractBody'>GetPlayerInteractBody</a></br>
<a href='#SetPlayerScreen'>SetPlayerScreen</a></br>
<a href='#GetPlayerScreen'>GetPlayerScreen</a></br>
<a href='#SetPlayerHealth'>SetPlayerHealth</a></br>
<a href='#GetPlayerHealth'>GetPlayerHealth</a></br>
<a href='#SetPlayerRegenerationState'>SetPlayerRegenerationState</a></br>
<a href='#RespawnPlayer'>RespawnPlayer</a></br>
<a href='#GetPlayerWalkingSpeed'>GetPlayerWalkingSpeed</a></br>
<a href='#SetPlayerWalkingSpeed'>SetPlayerWalkingSpeed</a></br>
<a href='#GetPlayerParam'>GetPlayerParam</a></br>
<a href='#SetPlayerParam'>SetPlayerParam</a></br>
<a href='#SetPlayerHidden'>SetPlayerHidden</a></br>
<a href='#RegisterTool'>RegisterTool</a></br>
<a href='#GetToolBody'>GetToolBody</a></br>
<a href='#GetToolHandPoseLocalTransform'>GetToolHandPoseLocalTransform</a></br>
<a href='#GetToolHandPoseWorldTransform'>GetToolHandPoseWorldTransform</a></br>
<a href='#SetToolHandPoseLocalTransform'>SetToolHandPoseLocalTransform</a></br>
<a href='#GetToolLocationLocalTransform'>GetToolLocationLocalTransform</a></br>
<a href='#GetToolLocationWorldTransform'>GetToolLocationWorldTransform</a></br>
<a href='#SetToolTransform'>SetToolTransform</a></br>
<a href='#SetToolAllowedZoom'>SetToolAllowedZoom</a></br>
<a href='#SetToolTransformOverride'>SetToolTransformOverride</a></br>
<a href='#SetToolOffset'>SetToolOffset</a></br>
<hr/>
<h2>Sound</h2>
<p>
Sound functions are used for playing sounds or loops in the world. There sound functions are 
alwyas positioned and will be affected by acoustics simulation. If you want to play dry sounds
without acoustics you should use UiSound and UiSoundLoop in the User Interface section.
<p>

<p>
<a href='#LoadSound'>LoadSound</a></br>
<a href='#UnloadSound'>UnloadSound</a></br>
<a href='#LoadLoop'>LoadLoop</a></br>
<a href='#UnloadLoop'>UnloadLoop</a></br>
<a href='#SetSoundLoopUser'>SetSoundLoopUser</a></br>
<a href='#PlaySound'>PlaySound</a></br>
<a href='#PlaySoundForUser'>PlaySoundForUser</a></br>
<a href='#StopSound'>StopSound</a></br>
<a href='#IsSoundPlaying'>IsSoundPlaying</a></br>
<a href='#GetSoundProgress'>GetSoundProgress</a></br>
<a href='#SetSoundProgress'>SetSoundProgress</a></br>
<a href='#PlayLoop'>PlayLoop</a></br>
<a href='#GetSoundLoopProgress'>GetSoundLoopProgress</a></br>
<a href='#SetSoundLoopProgress'>SetSoundLoopProgress</a></br>
<a href='#PlayMusic'>PlayMusic</a></br>
<a href='#StopMusic'>StopMusic</a></br>
<a href='#IsMusicPlaying'>IsMusicPlaying</a></br>
<a href='#SetMusicPaused'>SetMusicPaused</a></br>
<a href='#GetMusicProgress'>GetMusicProgress</a></br>
<a href='#SetMusicProgress'>SetMusicProgress</a></br>
<a href='#SetMusicVolume'>SetMusicVolume</a></br>
<a href='#SetMusicLowPass'>SetMusicLowPass</a></br>
<hr/>
<h2>Sprite</h2>
<p>
Sprites are 2D images in PNG or JPG format that can be drawn into the world. Sprites can be 
drawn with ot without depth test (occluded by geometry). Sprites will not be affected by lighting
but they will go through post processing. If you want to display positioned information to the player as 
an overlay, you probably want to use the Ui functions in combination with UiWorldToPixel instead.
<p>

<p>
<a href='#LoadSprite'>LoadSprite</a></br>
<a href='#DrawSprite'>DrawSprite</a></br>
<hr/>
<h2>Scene queries</h2>
<p>
Query the level in various ways.
<p>

<p>
<a href='#QueryRequire'>QueryRequire</a></br>
<a href='#QueryInclude'>QueryInclude</a></br>
<a href='#QueryRejectAnimator'>QueryRejectAnimator</a></br>
<a href='#QueryRejectVehicle'>QueryRejectVehicle</a></br>
<a href='#QueryRejectBody'>QueryRejectBody</a></br>
<a href='#QueryRejectBodies'>QueryRejectBodies</a></br>
<a href='#QueryRejectShape'>QueryRejectShape</a></br>
<a href='#QueryRejectShapes'>QueryRejectShapes</a></br>
<a href='#QueryRaycast'>QueryRaycast</a></br>
<a href='#QueryRaycastRope'>QueryRaycastRope</a></br>
<a href='#QueryClosestPoint'>QueryClosestPoint</a></br>
<a href='#QueryAabbShapes'>QueryAabbShapes</a></br>
<a href='#QueryAabbBodies'>QueryAabbBodies</a></br>
<a href='#QueryPath'>QueryPath</a></br>
<a href='#CreatePathPlanner'>CreatePathPlanner</a></br>
<a href='#DeletePathPlanner'>DeletePathPlanner</a></br>
<a href='#PathPlannerQuery'>PathPlannerQuery</a></br>
<a href='#AbortPath'>AbortPath</a></br>
<a href='#GetPathState'>GetPathState</a></br>
<a href='#GetPathLength'>GetPathLength</a></br>
<a href='#GetPathPoint'>GetPathPoint</a></br>
<a href='#GetLastSound'>GetLastSound</a></br>
<a href='#IsPointInWater'>IsPointInWater</a></br>
<a href='#GetWindVelocity'>GetWindVelocity</a></br>
<hr/>
<h2>Particles</h2>
<p>
Functions to configure and emit particles, used for fire, smoke and other visual effects. There are 
two types of particles in Teardown - plain particles and smoke particles. Plain particles are simple 
billboard particles simulated with gravity and velocity that can be used for fire, debris, rain, snow and such. 
Smoke particles are only intended for smoke and they are simulated with fluid dynamics internally and rendered
with some special tricks to get a more smoke-like appearance.
<p>
All functions in the particle API, except for SpawnParticle modify properties in the particle state, which is
then used when emitting particles, so the idea is to set up a state, and then emit one or several particles 
using that state.
<p>
Most properties in the particle state can be either constant or animated over time. Supply a single argument
for constant, two argument for linear interpolation, and optionally a third argument for other types of 
interpolation. There are also fade in and fade out parameters that fade from and to zero.
<p>

<p>
<a href='#ParticleReset'>ParticleReset</a></br>
<a href='#ParticleType'>ParticleType</a></br>
<a href='#ParticleTile'>ParticleTile</a></br>
<a href='#ParticleColor'>ParticleColor</a></br>
<a href='#ParticleRadius'>ParticleRadius</a></br>
<a href='#ParticleAlpha'>ParticleAlpha</a></br>
<a href='#ParticleGravity'>ParticleGravity</a></br>
<a href='#ParticleDrag'>ParticleDrag</a></br>
<a href='#ParticleEmissive'>ParticleEmissive</a></br>
<a href='#ParticleRotation'>ParticleRotation</a></br>
<a href='#ParticleStretch'>ParticleStretch</a></br>
<a href='#ParticleSticky'>ParticleSticky</a></br>
<a href='#ParticleCollide'>ParticleCollide</a></br>
<a href='#ParticleFlags'>ParticleFlags</a></br>
<a href='#SpawnParticle'>SpawnParticle</a></br>
<hr/>
<h2>Spawning</h2>
<p>
The spawn API can be used to add entities into the existing scenes. You can spawn existing 
prefab XML files or generate XML and pass it in as a lua string.
<p>

<p>
<a href='#Spawn'>Spawn</a></br>
<a href='#SpawnLayer'>SpawnLayer</a></br>
<hr/>
<h2>Miscellaneous</h2>
<p>
Functions of peripheral nature that doesn't fit in anywhere else
<p>

<p>
<a href='#Shoot'>Shoot</a></br>
<a href='#Paint'>Paint</a></br>
<a href='#PaintRGBA'>PaintRGBA</a></br>
<a href='#MakeHole'>MakeHole</a></br>
<a href='#Explosion'>Explosion</a></br>
<a href='#SpawnFire'>SpawnFire</a></br>
<a href='#GetFireCount'>GetFireCount</a></br>
<a href='#QueryClosestFire'>QueryClosestFire</a></br>
<a href='#QueryAabbFireCount'>QueryAabbFireCount</a></br>
<a href='#RemoveAabbFires'>RemoveAabbFires</a></br>
<a href='#GetCameraTransform'>GetCameraTransform</a></br>
<a href='#SetCameraTransform'>SetCameraTransform</a></br>
<a href='#RequestFirstPerson'>RequestFirstPerson</a></br>
<a href='#RequestThirdPerson'>RequestThirdPerson</a></br>
<a href='#SetCameraOffsetTransform'>SetCameraOffsetTransform</a></br>
<a href='#AttachCameraTo'>AttachCameraTo</a></br>
<a href='#SetPivotClipBody'>SetPivotClipBody</a></br>
<a href='#ShakeCamera'>ShakeCamera</a></br>
<a href='#SetCameraFov'>SetCameraFov</a></br>
<a href='#SetCameraDof'>SetCameraDof</a></br>
<a href='#PointLight'>PointLight</a></br>
<a href='#SetTimeScale'>SetTimeScale</a></br>
<a href='#SetEnvironmentDefault'>SetEnvironmentDefault</a></br>
<a href='#SetEnvironmentProperty'>SetEnvironmentProperty</a></br>
<a href='#GetEnvironmentProperty'>GetEnvironmentProperty</a></br>
<a href='#SetPostProcessingDefault'>SetPostProcessingDefault</a></br>
<a href='#SetPostProcessingProperty'>SetPostProcessingProperty</a></br>
<a href='#GetPostProcessingProperty'>GetPostProcessingProperty</a></br>
<a href='#DrawLine'>DrawLine</a></br>
<a href='#DebugLine'>DebugLine</a></br>
<a href='#DebugCross'>DebugCross</a></br>
<a href='#DebugTransform'>DebugTransform</a></br>
<a href='#DebugWatch'>DebugWatch</a></br>
<a href='#DebugPrint'>DebugPrint</a></br>
<a href='#RegisterListenerTo'>RegisterListenerTo</a></br>
<a href='#UnregisterListener'>UnregisterListener</a></br>
<a href='#TriggerEvent'>TriggerEvent</a></br>
<a href='#LoadHaptic'>LoadHaptic</a></br>
<a href='#CreateHaptic'>CreateHaptic</a></br>
<a href='#PlayHaptic'>PlayHaptic</a></br>
<a href='#PlayHapticDirectional'>PlayHapticDirectional</a></br>
<a href='#HapticIsPlaying'>HapticIsPlaying</a></br>
<a href='#SetToolHaptic'>SetToolHaptic</a></br>
<a href='#StopHaptic'>StopHaptic</a></br>
<a href='#SetVehicleHealth'>SetVehicleHealth</a></br>
<a href='#QueryRaycastWater'>QueryRaycastWater</a></br>
<a href='#AddHeat'>AddHeat</a></br>
<a href='#GetGravity'>GetGravity</a></br>
<a href='#SetGravity'>SetGravity</a></br>
<a href='#SetPlayerOrientation'>SetPlayerOrientation</a></br>
<a href='#GetPlayerOrientation'>GetPlayerOrientation</a></br>
<a href='#GetPlayerUp'>GetPlayerUp</a></br>
<a href='#GetFps'>GetFps</a></br>
<hr/>
<h2>User Interface</h2>
<p>
The user interface functions are used for drawing interactive 2D graphics and can only be
called from the draw function of a script. The ui functions are designed with the immediate
mode gui paradigm in mind and uses a cursor and state stack. Pushing and popping the stack is cheap 
and designed to be called often.
<p>

<p>
<a href='#UiMakeInteractive'>UiMakeInteractive</a></br>
<a href='#UiPush'>UiPush</a></br>
<a href='#UiPop'>UiPop</a></br>
<a href='#UiWidth'>UiWidth</a></br>
<a href='#UiHeight'>UiHeight</a></br>
<a href='#UiCenter'>UiCenter</a></br>
<a href='#UiMiddle'>UiMiddle</a></br>
<a href='#UiColor'>UiColor</a></br>
<a href='#UiColorFilter'>UiColorFilter</a></br>
<a href='#UiResetColor'>UiResetColor</a></br>
<a href='#UiTranslate'>UiTranslate</a></br>
<a href='#UiRotate'>UiRotate</a></br>
<a href='#UiScale'>UiScale</a></br>
<a href='#UiGetScale'>UiGetScale</a></br>
<a href='#UiClipRect'>UiClipRect</a></br>
<a href='#UiWindow'>UiWindow</a></br>
<a href='#UiGetCurrentWindow'>UiGetCurrentWindow</a></br>
<a href='#UiIsInCurrentWindow'>UiIsInCurrentWindow</a></br>
<a href='#UiIsRectFullyClipped'>UiIsRectFullyClipped</a></br>
<a href='#UiIsInClipRegion'>UiIsInClipRegion</a></br>
<a href='#UiIsFullyClipped'>UiIsFullyClipped</a></br>
<a href='#UiSafeMargins'>UiSafeMargins</a></br>
<a href='#UiCanvasSize'>UiCanvasSize</a></br>
<a href='#UiAlign'>UiAlign</a></br>
<a href='#UiTextAlignment'>UiTextAlignment</a></br>
<a href='#UiModalBegin'>UiModalBegin</a></br>
<a href='#UiModalEnd'>UiModalEnd</a></br>
<a href='#UiDisableInput'>UiDisableInput</a></br>
<a href='#UiEnableInput'>UiEnableInput</a></br>
<a href='#UiReceivesInput'>UiReceivesInput</a></br>
<a href='#UiGetMousePos'>UiGetMousePos</a></br>
<a href='#UiGetCanvasMousePos'>UiGetCanvasMousePos</a></br>
<a href='#UiIsMouseInRect'>UiIsMouseInRect</a></br>
<a href='#UiWorldToPixel'>UiWorldToPixel</a></br>
<a href='#UiPixelToWorld'>UiPixelToWorld</a></br>
<a href='#UiGetCursorPos'>UiGetCursorPos</a></br>
<a href='#UiBlur'>UiBlur</a></br>
<a href='#UiFont'>UiFont</a></br>
<a href='#UiFontHeight'>UiFontHeight</a></br>
<a href='#UiText'>UiText</a></br>
<a href='#UiTextDisableWildcards'>UiTextDisableWildcards</a></br>
<a href='#UiTextUniformHeight'>UiTextUniformHeight</a></br>
<a href='#UiGetTextSize'>UiGetTextSize</a></br>
<a href='#UiMeasureText'>UiMeasureText</a></br>
<a href='#UiGetSymbolsCount'>UiGetSymbolsCount</a></br>
<a href='#UiTextSymbolsSub'>UiTextSymbolsSub</a></br>
<a href='#UiWordWrap'>UiWordWrap</a></br>
<a href='#UiTextLineSpacing'>UiTextLineSpacing</a></br>
<a href='#UiTextOutline'>UiTextOutline</a></br>
<a href='#UiTextShadow'>UiTextShadow</a></br>
<a href='#UiRect'>UiRect</a></br>
<a href='#UiRectOutline'>UiRectOutline</a></br>
<a href='#UiRoundedRect'>UiRoundedRect</a></br>
<a href='#UiRoundedRectOutline'>UiRoundedRectOutline</a></br>
<a href='#UiCircle'>UiCircle</a></br>
<a href='#UiCircleOutline'>UiCircleOutline</a></br>
<a href='#UiFillImage'>UiFillImage</a></br>
<a href='#UiImage'>UiImage</a></br>
<a href='#UiUnloadImage'>UiUnloadImage</a></br>
<a href='#UiHasImage'>UiHasImage</a></br>
<a href='#UiGetImageSize'>UiGetImageSize</a></br>
<a href='#UiImageBox'>UiImageBox</a></br>
<a href='#UiSound'>UiSound</a></br>
<a href='#UiSoundLoop'>UiSoundLoop</a></br>
<a href='#UiMute'>UiMute</a></br>
<a href='#UiButtonImageBox'>UiButtonImageBox</a></br>
<a href='#UiButtonHoverColor'>UiButtonHoverColor</a></br>
<a href='#UiButtonPressColor'>UiButtonPressColor</a></br>
<a href='#UiButtonPressDist'>UiButtonPressDist</a></br>
<a href='#UiButtonTextHandling'>UiButtonTextHandling</a></br>
<a href='#UiTextButton'>UiTextButton</a></br>
<a href='#UiImageButton'>UiImageButton</a></br>
<a href='#UiBlankButton'>UiBlankButton</a></br>
<a href='#UiSlider'>UiSlider</a></br>
<a href='#UiSliderHoverColorFilter'>UiSliderHoverColorFilter</a></br>
<a href='#UiSliderThumbSize'>UiSliderThumbSize</a></br>
<a href='#UiGetScreen'>UiGetScreen</a></br>
<a href='#UiNavComponent'>UiNavComponent</a></br>
<a href='#UiIgnoreNavigation'>UiIgnoreNavigation</a></br>
<a href='#UiResetNavigation'>UiResetNavigation</a></br>
<a href='#UiNavSkipUpdate'>UiNavSkipUpdate</a></br>
<a href='#UiIsComponentInFocus'>UiIsComponentInFocus</a></br>
<a href='#UiNavGroupBegin'>UiNavGroupBegin</a></br>
<a href='#UiNavGroupEnd'>UiNavGroupEnd</a></br>
<a href='#UiNavGroupSize'>UiNavGroupSize</a></br>
<a href='#UiForceFocus'>UiForceFocus</a></br>
<a href='#UiFocusedComponentId'>UiFocusedComponentId</a></br>
<a href='#UiFocusedComponentRect'>UiFocusedComponentRect</a></br>
<a href='#UiGetItemSize'>UiGetItemSize</a></br>
<a href='#UiAutoTranslate'>UiAutoTranslate</a></br>
<a href='#UiBeginFrame'>UiBeginFrame</a></br>
<a href='#UiResetFrame'>UiResetFrame</a></br>
<a href='#UiFrameOccupy'>UiFrameOccupy</a></br>
<a href='#UiEndFrame'>UiEndFrame</a></br>
<a href='#UiFrameSkipItem'>UiFrameSkipItem</a></br>
<a href='#UiGetFrameNo'>UiGetFrameNo</a></br>
<a href='#UiGetLanguage'>UiGetLanguage</a></br>
<a href='#UiSetCursorState'>UiSetCursorState</a></br>
<hr/>
<a name='GetIntParam'></a><h3 class='function'>GetIntParam</h3>
<pre class='funcdef'><span class='retname'>value = </span>GetIntParam(<span class='argname'>name, default</span>)</pre>
<p>Arguments<br/>
<span class='argname'>name</span> <span class='argtype'>(string)</span> &ndash; Parameter name<br/>
<span class='argname'>default</span> <span class='argtype'>(number)</span> &ndash; Default parameter value<br/>
<p>Return value<br/>
<span class='retname'>value</span> <span class='argtype'>(number)</span> &ndash; Parameter value<br/>
<p><p>
</p>
<pre class='example'>
function init()
	--Retrieve blinkcount parameter, or set to 5 if omitted
	local parameterBlinkCount = GetIntParam("blinkcount", 5)
	DebugPrint(parameterBlinkCount)
end

</pre>
<hr/>
<a name='GetFloatParam'></a><h3 class='function'>GetFloatParam</h3>
<pre class='funcdef'><span class='retname'>value = </span>GetFloatParam(<span class='argname'>name, default</span>)</pre>
<p>Arguments<br/>
<span class='argname'>name</span> <span class='argtype'>(string)</span> &ndash; Parameter name<br/>
<span class='argname'>default</span> <span class='argtype'>(number)</span> &ndash; Default parameter value<br/>
<p>Return value<br/>
<span class='retname'>value</span> <span class='argtype'>(number)</span> &ndash; Parameter value<br/>
<p><p>
</p>
<pre class='example'>
function init()
	--Retrieve speed parameter, or set to 10.0 if omitted
	local parameterSpeed = GetFloatParam("speed", 10.0)
	DebugPrint(parameterSpeed)
end

</pre>
<hr/>
<a name='GetBoolParam'></a><h3 class='function'>GetBoolParam</h3>
<pre class='funcdef'><span class='retname'>value = </span>GetBoolParam(<span class='argname'>name, default</span>)</pre>
<p>Arguments<br/>
<span class='argname'>name</span> <span class='argtype'>(string)</span> &ndash; Parameter name<br/>
<span class='argname'>default</span> <span class='argtype'>(boolean)</span> &ndash; Default parameter value<br/>
<p>Return value<br/>
<span class='retname'>value</span> <span class='argtype'>(boolean)</span> &ndash; Parameter value<br/>
<p><p>
</p>
<pre class='example'>
function init()
	--Retrieve playsound parameter, or false if omitted
	local parameterPlaySound = GetBoolParam("playsound", false)
	DebugPrint(parameterPlaySound)
end

</pre>
<hr/>
<a name='GetStringParam'></a><h3 class='function'>GetStringParam</h3>
<pre class='funcdef'><span class='retname'>value = </span>GetStringParam(<span class='argname'>name, default</span>)</pre>
<p>Arguments<br/>
<span class='argname'>name</span> <span class='argtype'>(string)</span> &ndash; Parameter name<br/>
<span class='argname'>default</span> <span class='argtype'>(string)</span> &ndash; Default parameter value<br/>
<p>Return value<br/>
<span class='retname'>value</span> <span class='argtype'>(string)</span> &ndash; Parameter value<br/>
<p><p>
</p>
<pre class='example'>
function init()
	--Retrieve mode parameter, or "idle" if omitted
	local parameterMode = GetStringParam("mode", "idle")
	DebugPrint(parameterMode)
end

</pre>
<hr/>
<a name='GetColorParam'></a><h3 class='function'>GetColorParam</h3>
<pre class='funcdef'><span class='retname'>value = </span>GetColorParam(<span class='argname'>name, default</span>)</pre>
<p>Arguments<br/>
<span class='argname'>name</span> <span class='argtype'>(string)</span> &ndash; Parameter name<br/>
<span class='argname'>default</span> <span class='argtype'>(number)</span> &ndash; Default parameter value<br/>
<p>Return value<br/>
<span class='retname'>value</span> <span class='argtype'>(number)</span> &ndash; Parameter value<br/>
<p><p>
</p>
<pre class='example'>
function init()
	--Retrieve color parameter, or set to 0.39, 0.39, 0.39 if omitted
	local color_r, color_g, color_b = GetColorParam("color", 0.39, 0.39, 0.39)
	DebugPrint(color_r .. " " .. color_g .. " " .. color_b)
end

</pre>
<hr/>
<a name='GetVersion'></a><h3 class='function'>GetVersion</h3>
<pre class='funcdef'><span class='retname'>version = </span>GetVersion(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>version</span> <span class='argtype'>(string)</span> &ndash; Dot separated string of current version of the game<br/>
<p><p>
</p>
<pre class='example'>
function init()
	local v = GetVersion()
	--v is "0.5.0"
	DebugPrint(v)
end

</pre>
<hr/>
<a name='HasVersion'></a><h3 class='function'>HasVersion</h3>
<pre class='funcdef'><span class='retname'>match = </span>HasVersion(<span class='argname'>version</span>)</pre>
<p>Arguments<br/>
<span class='argname'>version</span> <span class='argtype'>(string)</span> &ndash; Reference version<br/>
<p>Return value<br/>
<span class='retname'>match</span> <span class='argtype'>(boolean)</span> &ndash; True if current version is at least provided one<br/>
<p><p>
</p>
<pre class='example'>
function init()
	if HasVersion("1.5.0") then
		--conditional code that only works on 0.6.0 or above
		DebugPrint("New version")
	else
		--legacy code that works on earlier versions
		DebugPrint("Earlier version")
	end
end

</pre>
<hr/>
<a name='GetTime'></a><h3 class='function'>GetTime</h3>
<pre class='funcdef'><span class='retname'>time = </span>GetTime(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>time</span> <span class='argtype'>(number)</span> &ndash; The time in seconds since level was started<br/>
<p>Returns running time of this script. If called from update, this returns
the simulated time, otherwise it returns wall time.
<p>
</p>
<pre class='example'>
function update()
	local t = GetTime()
	DebugPrint(t)
end

</pre>
<hr/>
<a name='GetTimeStep'></a><h3 class='function'>GetTimeStep</h3>
<pre class='funcdef'><span class='retname'>dt = </span>GetTimeStep(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>dt</span> <span class='argtype'>(number)</span> &ndash; The timestep in seconds<br/>
<p>Returns timestep of the last frame. If called from update, this returns
the simulation time step, which is always one 60th of a second (0.0166667).
If called from tick or draw it returns the actual time since last frame.
<p>
</p>
<pre class='example'>
function tick()
	local dt = GetTimeStep()
	DebugPrint("tick dt: " .. dt)
end

function update()
	local dt = GetTimeStep()
	DebugPrint("update dt: " .. dt)
end

</pre>
<hr/>
<a name='InputLastPressedKey'></a><h3 class='function'>InputLastPressedKey</h3>
<pre class='funcdef'><span class='retname'>name = </span>InputLastPressedKey(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>name</span> <span class='argtype'>(string)</span> &ndash; Name of last pressed key, empty if no key is pressed<br/>
<p><p>
</p>
<pre class='example'>
function tick()
	local name = InputLastPressedKey()
	if string.len(name) > 0 then
		DebugPrint(name) 
	end
end

</pre>
<hr/>
<a name='InputPressed'></a><h3 class='function'>InputPressed</h3>
<pre class='funcdef'><span class='retname'>pressed = </span>InputPressed(<span class='argname'>input</span>)</pre>
<p>Arguments<br/>
<span class='argname'>input</span> <span class='argtype'>(string)</span> &ndash; The input identifier<br/>
<p>Return value<br/>
<span class='retname'>pressed</span> <span class='argtype'>(boolean)</span> &ndash; True if input was pressed during last frame<br/>
<p><p>
</p>
<pre class='example'>
function tick()
	if InputPressed("interact") then
		DebugPrint("interact")
	end
end

</pre>
<hr/>
<a name='InputReleased'></a><h3 class='function'>InputReleased</h3>
<pre class='funcdef'><span class='retname'>pressed = </span>InputReleased(<span class='argname'>input</span>)</pre>
<p>Arguments<br/>
<span class='argname'>input</span> <span class='argtype'>(string)</span> &ndash; The input identifier<br/>
<p>Return value<br/>
<span class='retname'>pressed</span> <span class='argtype'>(boolean)</span> &ndash; True if input was released during last frame<br/>
<p><p>
</p>
<pre class='example'>
function tick()
	if InputReleased("interact") then
		DebugPrint("interact")
	end
end

</pre>
<hr/>
<a name='InputDown'></a><h3 class='function'>InputDown</h3>
<pre class='funcdef'><span class='retname'>pressed = </span>InputDown(<span class='argname'>input</span>)</pre>
<p>Arguments<br/>
<span class='argname'>input</span> <span class='argtype'>(string)</span> &ndash; The input identifier<br/>
<p>Return value<br/>
<span class='retname'>pressed</span> <span class='argtype'>(boolean)</span> &ndash; True if input is currently held down<br/>
<p><p>
</p>
<pre class='example'>
function tick()
	if InputDown("interact") then
		DebugPrint("interact")
	end
end

</pre>
<hr/>
<a name='InputValue'></a><h3 class='function'>InputValue</h3>
<pre class='funcdef'><span class='retname'>value = </span>InputValue(<span class='argname'>input</span>)</pre>
<p>Arguments<br/>
<span class='argname'>input</span> <span class='argtype'>(string)</span> &ndash; The input identifier<br/>
<p>Return value<br/>
<span class='retname'>value</span> <span class='argtype'>(number)</span> &ndash; Depends on input type<br/>
<p><p>
</p>
<pre class='example'>
local scrollPos = 0
function tick()
	scrollPos = scrollPos + InputValue("mousewheel")
	DebugPrint(scrollPos)
end

</pre>
<hr/>
<a name='InputClear'></a><h3 class='function'>InputClear</h3>
<pre class='funcdef'><span class='retname'></span>InputClear(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>none</span>
<p>All player input is "forgotten" by the game after calling this function
<p>
</p>
<pre class='example'>
function update()
    -- Prints '2' because InputClear() allows the game to "forget" the player's input
	if InputDown("interact") then
        InputClear()
		if InputDown("interact") then
			DebugPrint(1)
		else
			DebugPrint(2)
		end
	end
end

</pre>
<hr/>
<a name='InputResetOnTransition'></a><h3 class='function'>InputResetOnTransition</h3>
<pre class='funcdef'><span class='retname'></span>InputResetOnTransition(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>none</span>
<p>This function will reset everything we need to reset during state transition
<p>
</p>
<pre class='example'>
function update()
	if InputDown("interact") then
        -- In this form, you won't be able to notice the result of the function; you need a specific context
		InputResetOnTransition()
	end
end

</pre>
<hr/>
<a name='LastInputDevice'></a><h3 class='function'>LastInputDevice</h3>
<pre class='funcdef'><span class='retname'>value = </span>LastInputDevice(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>value</span> <span class='argtype'>(number)</span> &ndash; Last device id<br/>
<p>Returns the last input device id.
0 - none, 1 - mouse, 2 - gamepad
<p>
</p>
<pre class='example'>
#include "ui/ui_helpers.lua"

function update()
	if LastInputDevice() == UI_DEVICE_GAMEPAD then
		DebugPrint("Last input was from gamepad")
	elseif LastInputDevice() == UI_DEVICE_MOUSE then
		DebugPrint("Last input was mouse & keyboard")
	elseif LastInputDevice() == UI_DEVICE_TOUCHSCREEN then
		DebugPrint("Last input was touchscreen")
	end
end

</pre>
<hr/>
<a name='SetValue'></a><h3 class='function'>SetValue</h3>
<pre class='funcdef'><span class='retname'></span>SetValue(<span class='argname'>variable, value, [transition], [time]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>variable</span> <span class='argtype'>(string)</span> &ndash; Name of number variable in the global context<br/>
<span class='argname'>value</span> <span class='argtype'>(number)</span> &ndash; The new value<br/>
<span class='argname'>transition</span> <span class='argtype'>(string, optional)</span> &ndash; Transition type. See description.<br/>
<span class='argname'>time</span> <span class='argtype'>(number, optional)</span> &ndash; Transition time (seconds)<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Set value of a number variable in the global context with an optional transition.
If a transition is provided the value will animate from current value to the new value during the transition time.
Transition can be one of the following:
<table border=0><tr><td class='header'>&nbsp;Transition&nbsp;</td><td class='header'>&nbsp;Description</td></tr>
<tr><td class='first' valign='top'>linear	</td><td valign='top'> Linear transition</td></tr><tr><td class='first' valign='top'>cosine	</td><td valign='top'> Slow at beginning and end</td></tr><tr><td class='first' valign='top'>easein	</td><td valign='top'> Slow at beginning</td></tr><tr><td class='first' valign='top'>easeout	</td><td valign='top'> Slow at end</td></tr><tr><td class='first' valign='top'>bounce	</td><td valign='top'> Bounce and overshoot new value</td></tr><table/>
<p>
</p>
<pre class='example'>
myValue = 0
function tick()
	--This will change the value of myValue from 0 to 1 in a linear fasion over 0.5 seconds
	SetValue("myValue", 1, "linear", 0.5)
	DebugPrint(myValue)
end

</pre>
<hr/>
<a name='SetValueInTable'></a><h3 class='function'>SetValueInTable</h3>
<pre class='funcdef'><span class='retname'></span>SetValueInTable(<span class='argname'>tableId, memberName, newValue, type, length</span>)</pre>
<p>Arguments<br/>
<span class='argname'>tableId</span> <span class='argtype'>(table)</span> &ndash; Id of the table<br/>
<span class='argname'>memberName</span> <span class='argtype'>(string)</span> &ndash; Name of the member<br/>
<span class='argname'>newValue</span> <span class='argtype'>(number)</span> &ndash; New value<br/>
<span class='argname'>type</span> <span class='argtype'>(string)</span> &ndash; Transition type<br/>
<span class='argname'>length</span> <span class='argtype'>(number)</span> &ndash; Transition length<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Chages the value of a table member in time according to specified args.
Works similar to SetValue but for global variables of trivial types
<p>
</p>
<pre class='example'>
local t = {}
function init()
	SetValueInTable(t, "score", 1, "number", 1)
end
function update()
	if InputPressed("interact") then
		SetValueInTable(t, "score", t.score + 1, "number", 1)
        DebugPrint(t.score)
	end
end

</pre>
<hr/>
<a name='PauseMenuButton'></a><h3 class='function'>PauseMenuButton</h3>
<pre class='funcdef'><span class='retname'>clicked = </span>PauseMenuButton(<span class='argname'>title, [location]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>title</span> <span class='argtype'>(string)</span> &ndash; Text on button<br/>
<span class='argname'>location</span> <span class='argtype'>(string, optional)</span> &ndash; Button location. If "bottom_bar" - bottom bar, if "main_bottom" - below "Main menu" button, if "main_top" - above "Main menu" button. Default "bottom_bar".<br/>
<p>Return value<br/>
<span class='retname'>clicked</span> <span class='argtype'>(boolean)</span> &ndash; True if clicked, false otherwise<br/>
<p>Calling this function will add a button on the bottom bar or in the main pause menu (center of the screen) when the game is paused.
Identified by 'location' parameter, it can be below "Main menu" button (by passing "main_bottom" value)or above (by passing "main_top").
A primary button will be placed in the main pause menu if this function is called from a playable mod. There can be only one primary button.
Use this as a way to bring up mod settings or other user interfaces while the game is running. 
Call this function every frame from the tick function for as long as the pause menu button
should still be visible.
Only one button per script is allowed. Consecutive calls replace button added in previous calls.
<p>
</p>
<pre class='example'>
function tick()

    -- Primary button which will be placed in the main pause menu below "Main menu" button
	if PauseMenuButton("Back to Hub", "main_bottom") then
		StartLevel("hub", "level/hub.xml")
	end

	-- Primary button which will be placed in the main pause menu above "Main menu" button
	if PauseMenuButton("Back to Hub", "main_top") then
		StartLevel("hub", "level/hub.xml")
	end
	
	-- Button will be placed in the bottom bar of the pause menu
	if PauseMenuButton("MyMod Settings") then
		visible = true
	end
end

function draw()
	if visible then
		UiMakeInteractive()
	end
end


</pre>
<hr/>
<a name='HasFile'></a><h3 class='function'>HasFile</h3>
<pre class='funcdef'><span class='retname'>exists = </span>HasFile(<span class='argname'>path</span>)</pre>
<p>Arguments<br/>
<span class='argname'>path</span> <span class='argtype'>(string)</span> &ndash; Path to file<br/>
<p>Return value<br/>
<span class='retname'>exists</span> <span class='argtype'>(boolean)</span> &ndash; True if file exists<br/>
<p>Checks that file exists on the specified path.
It is preferable to use UiHasImage whenever possible - it has better performance
<p>
</p>
<pre class='example'>
local file = "gfx/circle.png"

function draw()
	if HasFile(image) then
		DebugPrint("file " .. file .. " exists")
	end
end

</pre>
<hr/>
<a name='StartLevel'></a><h3 class='function'>StartLevel</h3>
<pre class='funcdef'><span class='retname'></span>StartLevel(<span class='argname'>mission, path, [layers], [passThrough]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>mission</span> <span class='argtype'>(string)</span> &ndash; An identifier of your choice<br/>
<span class='argname'>path</span> <span class='argtype'>(string)</span> &ndash; Path to level XML file<br/>
<span class='argname'>layers</span> <span class='argtype'>(string, optional)</span> &ndash; Active layers. Default is no layers.<br/>
<span class='argname'>passThrough</span> <span class='argtype'>(boolean, optional)</span> &ndash; If set, loading screen will have no text and music will keep playing<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Start a level
<p>
</p>
<pre class='example'>
function init()
	--Start level with no active layers
	StartLevel("level1", "MOD/level1.xml")

	--Start level with two layers
	StartLevel("level1", "MOD/level1.xml", "vehicles targets")
end

</pre>
<hr/>
<a name='SetPaused'></a><h3 class='function'>SetPaused</h3>
<pre class='funcdef'><span class='retname'></span>SetPaused(<span class='argname'>paused</span>)</pre>
<p>Arguments<br/>
<span class='argname'>paused</span> <span class='argtype'>(boolean)</span> &ndash; True if game should be paused<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Set paused state of the game
<p>
</p>
<pre class='example'>
function tick()
	if InputPressed("interact") then
		--Pause game and bring up pause menu on HUD
		SetPaused(true)
	end
end

</pre>
<hr/>
<a name='Restart'></a><h3 class='function'>Restart</h3>
<pre class='funcdef'><span class='retname'></span>Restart(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Restart level
<p>
</p>
<pre class='example'>
function tick()
	if InputPressed("interact") then
		Restart()
	end
end

</pre>
<hr/>
<a name='Menu'></a><h3 class='function'>Menu</h3>
<pre class='funcdef'><span class='retname'></span>Menu(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Go to main menu
<p>
</p>
<pre class='example'>
function tick()
	if InputPressed("interact") then
		Menu()
	end
end

</pre>
<hr/>
<a name='ClearKey'></a><h3 class='function'>ClearKey</h3>
<pre class='funcdef'><span class='retname'></span>ClearKey(<span class='argname'>key</span>)</pre>
<p>Arguments<br/>
<span class='argname'>key</span> <span class='argtype'>(string)</span> &ndash; Registry key to clear<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Remove registry node, including all child nodes.
<p>
</p>
<pre class='example'>
function init()
	--If the registry looks like this:
	--	score
	--		levels
	--			level1 = 5
	--			level2 = 4

	ClearKey("score.levels")

	--Afterwards, the registry will look like this:
	--	score
end

</pre>
<hr/>
<a name='ListKeys'></a><h3 class='function'>ListKeys</h3>
<pre class='funcdef'><span class='retname'>children = </span>ListKeys(<span class='argname'>parent</span>)</pre>
<p>Arguments<br/>
<span class='argname'>parent</span> <span class='argtype'>(string)</span> &ndash; The parent registry key<br/>
<p>Return value<br/>
<span class='retname'>children</span> <span class='argtype'>(table)</span> &ndash; Indexed table of strings with child keys<br/>
<p>List all child keys of a registry node.
<p>
</p>
<pre class='example'>
--If the registry looks like this:
--	game
--		tool
--			steroid
--			rifle
--			...

function init()
	local list = ListKeys("game.tool")
	for i=1, #list do
		DebugPrint(list[i])
	end
end

--This will output:
--steroid
--rifle
-- ...

</pre>
<hr/>
<a name='HasKey'></a><h3 class='function'>HasKey</h3>
<pre class='funcdef'><span class='retname'>exists = </span>HasKey(<span class='argname'>key</span>)</pre>
<p>Arguments<br/>
<span class='argname'>key</span> <span class='argtype'>(string)</span> &ndash; Registry key<br/>
<p>Return value<br/>
<span class='retname'>exists</span> <span class='argtype'>(boolean)</span> &ndash; True if key exists<br/>
<p>Returns true if the registry contains a certain key
<p>
</p>
<pre class='example'>
function init()
	DebugPrint(HasKey("score.levels"))
	DebugPrint(HasKey("game.tool.rifle"))
end

</pre>
<hr/>
<a name='SetInt'></a><h3 class='function'>SetInt</h3>
<pre class='funcdef'><span class='retname'></span>SetInt(<span class='argname'>key, value</span>)</pre>
<p>Arguments<br/>
<span class='argname'>key</span> <span class='argtype'>(string)</span> &ndash; Registry key<br/>
<span class='argname'>value</span> <span class='argtype'>(number)</span> &ndash; Desired value<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p><p>
</p>
<pre class='example'>
function init()
	SetInt("score.levels.level1", 4)
	DebugPrint(GetInt("score.levels.level1"))
end

</pre>
<hr/>
<a name='GetInt'></a><h3 class='function'>GetInt</h3>
<pre class='funcdef'><span class='retname'>value = </span>GetInt(<span class='argname'>key</span>)</pre>
<p>Arguments<br/>
<span class='argname'>key</span> <span class='argtype'>(string)</span> &ndash; Registry key<br/>
<p>Return value<br/>
<span class='retname'>value</span> <span class='argtype'>(number)</span> &ndash; Integer value of registry node or zero if not found<br/>
<p><p>
</p>
<pre class='example'>
function init()
	SetInt("score.levels.level1", 4)
	DebugPrint(GetInt("score.levels.level1"))
end

</pre>
<hr/>
<a name='SetFloat'></a><h3 class='function'>SetFloat</h3>
<pre class='funcdef'><span class='retname'></span>SetFloat(<span class='argname'>key, value</span>)</pre>
<p>Arguments<br/>
<span class='argname'>key</span> <span class='argtype'>(string)</span> &ndash; Registry key<br/>
<span class='argname'>value</span> <span class='argtype'>(number)</span> &ndash; Desired value<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p><p>
</p>
<pre class='example'>
function init()
	SetFloat("level.time", 22.3)
	DebugPrint(GetFloat("level.time"))
end

</pre>
<hr/>
<a name='GetFloat'></a><h3 class='function'>GetFloat</h3>
<pre class='funcdef'><span class='retname'>value = </span>GetFloat(<span class='argname'>key</span>)</pre>
<p>Arguments<br/>
<span class='argname'>key</span> <span class='argtype'>(string)</span> &ndash; Registry key<br/>
<p>Return value<br/>
<span class='retname'>value</span> <span class='argtype'>(number)</span> &ndash; Float value of registry node or zero if not found<br/>
<p><p>
</p>
<pre class='example'>
function init()
	SetFloat("level.time", 22.3)
	DebugPrint(GetFloat("level.time"))
end

</pre>
<hr/>
<a name='SetBool'></a><h3 class='function'>SetBool</h3>
<pre class='funcdef'><span class='retname'></span>SetBool(<span class='argname'>key, value</span>)</pre>
<p>Arguments<br/>
<span class='argname'>key</span> <span class='argtype'>(string)</span> &ndash; Registry key<br/>
<span class='argname'>value</span> <span class='argtype'>(boolean)</span> &ndash; Desired value<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p><p>
</p>
<pre class='example'>
function init()
	SetBool("level.robots.enabled", true)
	DebugPrint(GetBool("level.robots.enabled"))
end

</pre>
<hr/>
<a name='GetBool'></a><h3 class='function'>GetBool</h3>
<pre class='funcdef'><span class='retname'>value = </span>GetBool(<span class='argname'>key</span>)</pre>
<p>Arguments<br/>
<span class='argname'>key</span> <span class='argtype'>(string)</span> &ndash; Registry key<br/>
<p>Return value<br/>
<span class='retname'>value</span> <span class='argtype'>(boolean)</span> &ndash; Boolean value of registry node or false if not found<br/>
<p><p>
</p>
<pre class='example'>
function init()
	SetBool("level.robots.enabled", true)
	DebugPrint(GetBool("level.robots.enabled"))
end

</pre>
<hr/>
<a name='SetString'></a><h3 class='function'>SetString</h3>
<pre class='funcdef'><span class='retname'></span>SetString(<span class='argname'>key, value</span>)</pre>
<p>Arguments<br/>
<span class='argname'>key</span> <span class='argtype'>(string)</span> &ndash; Registry key<br/>
<span class='argname'>value</span> <span class='argtype'>(string)</span> &ndash; Desired value<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p><p>
</p>
<pre class='example'>
function init()
	SetString("level.name", "foo")
	DebugPrint(GetString("level.name"))
end

</pre>
<hr/>
<a name='GetString'></a><h3 class='function'>GetString</h3>
<pre class='funcdef'><span class='retname'>value = </span>GetString(<span class='argname'>key</span>)</pre>
<p>Arguments<br/>
<span class='argname'>key</span> <span class='argtype'>(string)</span> &ndash; Registry key<br/>
<p>Return value<br/>
<span class='retname'>value</span> <span class='argtype'>(string)</span> &ndash; String value of registry node or "" if not found<br/>
<p><p>
</p>
<pre class='example'>
function init()
	SetString("level.name", "foo")
	DebugPrint(GetString("level.name"))
end

</pre>
<hr/>
<a name='GetEventCount'></a><h3 class='function'>GetEventCount</h3>
<pre class='funcdef'><span class='retname'>value = </span>GetEventCount(<span class='argname'>type</span>)</pre>
<p>Arguments<br/>
<span class='argname'>type</span> <span class='argtype'>(string)</span> &ndash; Event type<br/>
<p>Return value<br/>
<span class='retname'>value</span> <span class='argtype'>(number)</span> &ndash; Number of event available<br/>
<p><p>
</p>
<pre class='example'>
local count = GetEventCount("playerdead")
for i=1, count do
	local id, attacker = GetEvent("playerdead", i)
end

</pre>
<hr/>
<a name='GetEvent'></a><h3 class='function'>GetEvent</h3>
<pre class='funcdef'><span class='retname'>returnValues = </span>GetEvent(<span class='argname'>type, index</span>)</pre>
<p>Arguments<br/>
<span class='argname'>type</span> <span class='argtype'>(string)</span> &ndash; Event type<br/>
<span class='argname'>index</span> <span class='argtype'>(number)</span> &ndash; Event index (starting with one)<br/>
<p>Return value<br/>
<span class='retname'>returnValues</span> <span class='argtype'>(varying)</span> &ndash; Return values depending on event type<br/>
<p><p>
</p>
<pre class='example'>
local count = GetEventCount("playerdead")
for i=1, count do
	local id, attacker = GetEvent("playerdead", i)
end

</pre>
<hr/>
<a name='SetColor'></a><h3 class='function'>SetColor</h3>
<pre class='funcdef'><span class='retname'></span>SetColor(<span class='argname'>key, r, g, b, [a]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>key</span> <span class='argtype'>(string)</span> &ndash; Registry key<br/>
<span class='argname'>r</span> <span class='argtype'>(number)</span> &ndash; Desired red channel value<br/>
<span class='argname'>g</span> <span class='argtype'>(number)</span> &ndash; Desired green channel value<br/>
<span class='argname'>b</span> <span class='argtype'>(number)</span> &ndash; Desired blue channel value<br/>
<span class='argname'>a</span> <span class='argtype'>(number, optional)</span> &ndash; Desired alpha channel value<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Sets the color registry key value
<p>
</p>
<pre class='example'>
function init()
	SetColor("game.tool.wire.color", 1.0, 0.5, 0.3)
end

</pre>
<hr/>
<a name='GetColor'></a><h3 class='function'>GetColor</h3>
<pre class='funcdef'><span class='retname'>r, g, b, a = </span>GetColor(<span class='argname'>key</span>)</pre>
<p>Arguments<br/>
<span class='argname'>key</span> <span class='argtype'>(string)</span> &ndash; Registry key<br/>
<p>Return value<br/>
<span class='retname'>r</span> <span class='argtype'>(number)</span> &ndash; Desired red channel value<br/>
<span class='retname'>g</span> <span class='argtype'>(number)</span> &ndash; Desired green channel value<br/>
<span class='retname'>b</span> <span class='argtype'>(number)</span> &ndash; Desired blue channel value<br/>
<span class='retname'>a</span> <span class='argtype'>(number)</span> &ndash; Desired alpha channel value<br/>
<p>Returns the color registry key value
<p>
</p>
<pre class='example'>
function init()
	SetColor("red", 1.0, 0.1, 0.1)
	color = GetColor("red")
	DebugPrint("RGBA: " .. color[1] .. " " .. color[2] .. " " .. color[3] .. " " .. color[4])
end

</pre>
<hr/>
<a name='GetTranslatedStringByKey'></a><h3 class='function'>GetTranslatedStringByKey</h3>
<pre class='funcdef'><span class='retname'>value = </span>GetTranslatedStringByKey(<span class='argname'>key, [default]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>key</span> <span class='argtype'>(string)</span> &ndash; Translation key<br/>
<span class='argname'>default</span> <span class='argtype'>(string, optional)</span> &ndash; Default value<br/>
<p>Return value<br/>
<span class='retname'>value</span> <span class='argtype'>(string)</span> &ndash; Translation<br/>
<p>Returns the translation for the specified key from the translation table. If the key is not found returns the default value
<p>
</p>
<pre class='example'>
function init()
	DebugPrint(GetTranslatedStringByKey("TOOL_CAMERA"))
end

</pre>
<hr/>
<a name='HasTranslationByKey'></a><h3 class='function'>HasTranslationByKey</h3>
<pre class='funcdef'><span class='retname'>value = </span>HasTranslationByKey(<span class='argname'>key</span>)</pre>
<p>Arguments<br/>
<span class='argname'>key</span> <span class='argtype'>(string)</span> &ndash; Translation key<br/>
<p>Return value<br/>
<span class='retname'>value</span> <span class='argtype'>(boolean)</span> &ndash; True if translation exists<br/>
<p>Checks that translation for specified key exists
<p>
</p>
<pre class='example'>
function init()
	DebugPrint(HasTranslationByKey("TOOL_CAMERA"))
end

</pre>
<hr/>
<a name='LoadLanguageTable'></a><h3 class='function'>LoadLanguageTable</h3>
<pre class='funcdef'><span class='retname'></span>LoadLanguageTable(<span class='argname'>id</span>)</pre>
<p>Arguments<br/>
<span class='argname'>id</span> <span class='argtype'>(number)</span> &ndash; Language id (enum)<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Loads the language table for specified language id for further localization.
Possible id values are:<br>
<table border=0><tr><td class='header'>&nbsp;Id&nbsp;</td><td class='header'>&nbsp;Language</td></tr>
<tr><td class='first' valign='top'>0&nbsp;</td><td valign='top'> English</td></tr><tr><td class='first' valign='top'>1&nbsp;</td><td valign='top'> French</td></tr><tr><td class='first' valign='top'>2&nbsp;</td><td valign='top'> Spanish</td></tr><tr><td class='first' valign='top'>3&nbsp;</td><td valign='top'> Italian</td></tr><tr><td class='first' valign='top'>4&nbsp;</td><td valign='top'> German</td></tr><tr><td class='first' valign='top'>5&nbsp;</td><td valign='top'> Simplified Chinese</td></tr><tr><td class='first' valign='top'>6&nbsp;</td><td valign='top'> Japenese</td></tr><tr><td class='first' valign='top'>7&nbsp;</td><td valign='top'> Russian</td></tr><tr><td class='first' valign='top'>8&nbsp;</td><td valign='top'> Polish</td></tr><table/>
<p>
</p>
<pre class='example'>
function init()
	-- loads the english localization table
	LoadLanguageTable(0) 
end

</pre>
<hr/>
<a name='GetUserNickname'></a><h3 class='function'>GetUserNickname</h3>
<pre class='funcdef'><span class='retname'>value = </span>GetUserNickname(<span class='argname'>[id]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>id</span> <span class='argtype'>(number, optional)</span> &ndash; User id<br/>
<p>Return value<br/>
<span class='retname'>value</span> <span class='argtype'>(string)</span> &ndash; User nickname<br/>
<p>Returns the user nickname with the specified id. If id is not specified, returns nickname for user with id '0'
<p>
</p>
<pre class='example'>
function init()
	DebugPrint(GetUserNickname(0))
end

</pre>
<hr/>
<a name='Vec'></a><h3 class='function'>Vec</h3>
<pre class='funcdef'><span class='retname'>vec = </span>Vec(<span class='argname'>[x], [y], [z]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>x</span> <span class='argtype'>(number, optional)</span> &ndash; X value<br/>
<span class='argname'>y</span> <span class='argtype'>(number, optional)</span> &ndash; Y value<br/>
<span class='argname'>z</span> <span class='argtype'>(number, optional)</span> &ndash; Z value<br/>
<p>Return value<br/>
<span class='retname'>vec</span> <span class='argtype'>(TVec)</span> &ndash; New vector<br/>
<p>Create new vector and optionally initializes it to the provided values.
A Vec is equivalent to a regular lua table with three numbers.
<p>
</p>
<pre class='example'>
function init()
	--These are equivalent
	local a1 = Vec()
	local a2 = {0, 0, 0}
	DebugPrint("a1 == a2: " .. tostring(VecStr(a1) == VecStr(a2)))

	--These are equivalent
	local b1 = Vec(0, 1, 0)
	local b2 = {0, 1, 0}
	DebugPrint("b1 == b2: " .. tostring(VecStr(b1) == VecStr(b2)))
end

</pre>
<hr/>
<a name='VecCopy'></a><h3 class='function'>VecCopy</h3>
<pre class='funcdef'><span class='retname'>new = </span>VecCopy(<span class='argname'>org</span>)</pre>
<p>Arguments<br/>
<span class='argname'>org</span> <span class='argtype'>(TVec)</span> &ndash; A vector<br/>
<p>Return value<br/>
<span class='retname'>new</span> <span class='argtype'>(TVec)</span> &ndash; Copy of org vector<br/>
<p>Vectors should never be assigned like regular numbers. Since they are
implemented with lua tables assignment means two references pointing to
the same data. Use this function instead.
<p>
</p>
<pre class='example'>
function init()
	--Do this to assign a vector
	local right1 = Vec(1, 2, 3)
	local right2 = VecCopy(right1)

	--Never do this unless you REALLY know what you're doing
	local wrong1 = Vec(1, 2, 3)
	local wrong2 = wrong1
end

</pre>
<hr/>
<a name='VecStr'></a><h3 class='function'>VecStr</h3>
<pre class='funcdef'><span class='retname'>str = </span>VecStr(<span class='argname'>vector</span>)</pre>
<p>Arguments<br/>
<span class='argname'>vector</span> <span class='argtype'>(TVec)</span> &ndash; Vector<br/>
<p>Return value<br/>
<span class='retname'>str</span> <span class='argtype'>(string)</span> &ndash; String representation<br/>
<p>Returns the string representation of vector
<p>
</p>
<pre class='example'>
function init()
	local v = Vec(0, 10, 0)
	DebugPrint(VecStr(v))
end

</pre>
<hr/>
<a name='VecLength'></a><h3 class='function'>VecLength</h3>
<pre class='funcdef'><span class='retname'>length = </span>VecLength(<span class='argname'>vec</span>)</pre>
<p>Arguments<br/>
<span class='argname'>vec</span> <span class='argtype'>(TVec)</span> &ndash; A vector<br/>
<p>Return value<br/>
<span class='retname'>length</span> <span class='argtype'>(number)</span> &ndash; Length (magnitude) of the vector<br/>
<p><p>
</p>
<pre class='example'>
function init()
	local v = Vec(1,1,0)
	local l = VecLength(v)
	--l now equals 1.4142
	DebugPrint(l)
end

</pre>
<hr/>
<a name='VecNormalize'></a><h3 class='function'>VecNormalize</h3>
<pre class='funcdef'><span class='retname'>norm = </span>VecNormalize(<span class='argname'>vec</span>)</pre>
<p>Arguments<br/>
<span class='argname'>vec</span> <span class='argtype'>(TVec)</span> &ndash; A vector<br/>
<p>Return value<br/>
<span class='retname'>norm</span> <span class='argtype'>(TVec)</span> &ndash; A vector of length 1.0<br/>
<p>If the input vector is of zero length, the function returns {0,0,1}
<p>
</p>
<pre class='example'>
function init()
	local v = Vec(0,3,0)
	local n = VecNormalize(v)
	--n now equals {0,1,0}
	DebugPrint(VecStr(n))
end

</pre>
<hr/>
<a name='VecScale'></a><h3 class='function'>VecScale</h3>
<pre class='funcdef'><span class='retname'>norm = </span>VecScale(<span class='argname'>vec, scale</span>)</pre>
<p>Arguments<br/>
<span class='argname'>vec</span> <span class='argtype'>(TVec)</span> &ndash; A vector<br/>
<span class='argname'>scale</span> <span class='argtype'>(number)</span> &ndash; A scale factor<br/>
<p>Return value<br/>
<span class='retname'>norm</span> <span class='argtype'>(TVec)</span> &ndash; A scaled version of input vector<br/>
<p><p>
</p>
<pre class='example'>
function init()
	local v = Vec(1,2,3)
	local n = VecScale(v, 2)
	--n now equals {2,4,6}
	DebugPrint(VecStr(n))
end

</pre>
<hr/>
<a name='VecAdd'></a><h3 class='function'>VecAdd</h3>
<pre class='funcdef'><span class='retname'>c = </span>VecAdd(<span class='argname'>a, b</span>)</pre>
<p>Arguments<br/>
<span class='argname'>a</span> <span class='argtype'>(TVec)</span> &ndash; Vector<br/>
<span class='argname'>b</span> <span class='argtype'>(TVec)</span> &ndash; Vector<br/>
<p>Return value<br/>
<span class='retname'>c</span> <span class='argtype'>(TVec)</span> &ndash; New vector with sum of a and b<br/>
<p><p>
</p>
<pre class='example'>
function init()
	local a = Vec(1,2,3)
	local b = Vec(3,0,0)
	local c = VecAdd(a, b)
	--c now equals {4,2,3}
	DebugPrint(VecStr(c))
end

</pre>
<hr/>
<a name='VecSub'></a><h3 class='function'>VecSub</h3>
<pre class='funcdef'><span class='retname'>c = </span>VecSub(<span class='argname'>a, b</span>)</pre>
<p>Arguments<br/>
<span class='argname'>a</span> <span class='argtype'>(TVec)</span> &ndash; Vector<br/>
<span class='argname'>b</span> <span class='argtype'>(TVec)</span> &ndash; Vector<br/>
<p>Return value<br/>
<span class='retname'>c</span> <span class='argtype'>(TVec)</span> &ndash; New vector representing a-b<br/>
<p><p>
</p>
<pre class='example'>
function init()
	local a = Vec(1,2,3)
	local b = Vec(3,0,0)
	local c = VecSub(a, b)
	--c now equals {-2,2,3}
	DebugPrint(VecStr(c))
end

</pre>
<hr/>
<a name='VecDot'></a><h3 class='function'>VecDot</h3>
<pre class='funcdef'><span class='retname'>c = </span>VecDot(<span class='argname'>a, b</span>)</pre>
<p>Arguments<br/>
<span class='argname'>a</span> <span class='argtype'>(TVec)</span> &ndash; Vector<br/>
<span class='argname'>b</span> <span class='argtype'>(TVec)</span> &ndash; Vector<br/>
<p>Return value<br/>
<span class='retname'>c</span> <span class='argtype'>(number)</span> &ndash; Dot product of a and b<br/>
<p><p>
</p>
<pre class='example'>
function init()
	local a = Vec(1,2,3)
	local b = Vec(3,1,0)
	local c = VecDot(a, b)
	--c now equals 5
	DebugPrint(c)
end

</pre>
<hr/>
<a name='VecCross'></a><h3 class='function'>VecCross</h3>
<pre class='funcdef'><span class='retname'>c = </span>VecCross(<span class='argname'>a, b</span>)</pre>
<p>Arguments<br/>
<span class='argname'>a</span> <span class='argtype'>(TVec)</span> &ndash; Vector<br/>
<span class='argname'>b</span> <span class='argtype'>(TVec)</span> &ndash; Vector<br/>
<p>Return value<br/>
<span class='retname'>c</span> <span class='argtype'>(TVec)</span> &ndash; Cross product of a and b (also called vector product)<br/>
<p><p>
</p>
<pre class='example'>
function init()
	local a = Vec(1,0,0)
	local b = Vec(0,1,0)
	local c = VecCross(a, b)
	--c now equals {0,0,1}
	DebugPrint(VecStr(c))
end

</pre>
<hr/>
<a name='VecLerp'></a><h3 class='function'>VecLerp</h3>
<pre class='funcdef'><span class='retname'>c = </span>VecLerp(<span class='argname'>a, b, t</span>)</pre>
<p>Arguments<br/>
<span class='argname'>a</span> <span class='argtype'>(TVec)</span> &ndash; Vector<br/>
<span class='argname'>b</span> <span class='argtype'>(TVec)</span> &ndash; Vector<br/>
<span class='argname'>t</span> <span class='argtype'>(number)</span> &ndash; fraction (usually between 0.0 and 1.0)<br/>
<p>Return value<br/>
<span class='retname'>c</span> <span class='argtype'>(TVec)</span> &ndash; Linearly interpolated vector between a and b, using t<br/>
<p><p>
</p>
<pre class='example'>
function init()
	local a = Vec(2,0,0)
	local b = Vec(0,4,2)
	local t = 0.5
	
	--These two are equivalent
	local c1 = VecLerp(a, b, t)
	local c2 = VecAdd(VecScale(a, 1-t), VecScale(b, t))
	
	--c1 and c2 now equals {1, 2, 1}
	DebugPrint("c1" .. VecStr(c1) .. " == c2" .. VecStr(c2))
end

</pre>
<hr/>
<a name='Quat'></a><h3 class='function'>Quat</h3>
<pre class='funcdef'><span class='retname'>quat = </span>Quat(<span class='argname'>[x], [y], [z], [w]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>x</span> <span class='argtype'>(number, optional)</span> &ndash; X value<br/>
<span class='argname'>y</span> <span class='argtype'>(number, optional)</span> &ndash; Y value<br/>
<span class='argname'>z</span> <span class='argtype'>(number, optional)</span> &ndash; Z value<br/>
<span class='argname'>w</span> <span class='argtype'>(number, optional)</span> &ndash; W value<br/>
<p>Return value<br/>
<span class='retname'>quat</span> <span class='argtype'>(TQuat)</span> &ndash; New quaternion<br/>
<p>Create new quaternion and optionally initializes it to the provided values.
Do not attempt to initialize a quaternion with raw values unless you know
what you are doing. Use QuatEuler or QuatAxisAngle instead.
If no arguments are given, a unit quaternion will be created: {0, 0, 0, 1}.
A quaternion is equivalent to a regular lua table with four numbers.
<p>
</p>
<pre class='example'>
function init()
	--These are equivalent
	local a1 = Quat()
	local a2 = {0, 0, 0, 1}

	DebugPrint(QuatStr(a1) == QuatStr(a2))
end

</pre>
<hr/>
<a name='QuatCopy'></a><h3 class='function'>QuatCopy</h3>
<pre class='funcdef'><span class='retname'>new = </span>QuatCopy(<span class='argname'>org</span>)</pre>
<p>Arguments<br/>
<span class='argname'>org</span> <span class='argtype'>(TQuat)</span> &ndash; Quaternion<br/>
<p>Return value<br/>
<span class='retname'>new</span> <span class='argtype'>(TQuat)</span> &ndash; Copy of org quaternion<br/>
<p>Quaternions should never be assigned like regular numbers. Since they are
implemented with lua tables assignment means two references pointing to
the same data. Use this function instead.
<p>
</p>
<pre class='example'>
function init()
	--Do this to assign a quaternion
	local right1 = QuatEuler(0, 90, 0)
	local right2 = QuatCopy(right1)

	--Never do this unless you REALLY know what you're doing
	local wrong1 = QuatEuler(0, 90, 0)
	local wrong2 = wrong1
end

</pre>
<hr/>
<a name='QuatAxisAngle'></a><h3 class='function'>QuatAxisAngle</h3>
<pre class='funcdef'><span class='retname'>quat = </span>QuatAxisAngle(<span class='argname'>axis, angle</span>)</pre>
<p>Arguments<br/>
<span class='argname'>axis</span> <span class='argtype'>(TVec)</span> &ndash; Rotation axis, unit vector<br/>
<span class='argname'>angle</span> <span class='argtype'>(number)</span> &ndash; Rotation angle in degrees<br/>
<p>Return value<br/>
<span class='retname'>quat</span> <span class='argtype'>(TQuat)</span> &ndash; New quaternion<br/>
<p>Create a quaternion representing a rotation around a specific axis
<p>
</p>
<pre class='example'>
function init()
	--Create quaternion representing rotation 30 degrees around Y axis
	local q = QuatAxisAngle(Vec(0,1,0), 30)
	DebugPrint(QuatStr(q))
end

</pre>
<hr/>
<a name='QuatDeltaNormals'></a><h3 class='function'>QuatDeltaNormals</h3>
<pre class='funcdef'><span class='retname'>quat = </span>QuatDeltaNormals(<span class='argname'>normal0, normal1</span>)</pre>
<p>Arguments<br/>
<span class='argname'>normal0</span> <span class='argtype'>(TVec)</span> &ndash; Unit vector<br/>
<span class='argname'>normal1</span> <span class='argtype'>(TVec)</span> &ndash; Unit vector<br/>
<p>Return value<br/>
<span class='retname'>quat</span> <span class='argtype'>(TQuat)</span> &ndash; New quaternion<br/>
<p>Create a quaternion representing a rotation between the input normals
<p>
</p>
<pre class='example'>
function init()
	--Create quaternion representing a rotation between x-axis and y-axis
	local q = QuatDeltaNormals(Vec(1,0,0), Vec(0,1,0))
end

</pre>
<hr/>
<a name='QuatDeltaVectors'></a><h3 class='function'>QuatDeltaVectors</h3>
<pre class='funcdef'><span class='retname'>quat = </span>QuatDeltaVectors(<span class='argname'>vector0, vector1</span>)</pre>
<p>Arguments<br/>
<span class='argname'>vector0</span> <span class='argtype'>(TVec)</span> &ndash; Vector<br/>
<span class='argname'>vector1</span> <span class='argtype'>(TVec)</span> &ndash; Vector<br/>
<p>Return value<br/>
<span class='retname'>quat</span> <span class='argtype'>(TQuat)</span> &ndash; New quaternion<br/>
<p>Create a quaternion representing a rotation between the input vectors that doesn't need to be of unit-length
<p>
</p>
<pre class='example'>
function init()
	--Create quaternion representing a rotation between two non-unit vectors aligned along x-axis and y-axis
	local q = QuatDeltaVectors(Vec(10,0,0), Vec(0,5,0))
end

</pre>
<hr/>
<a name='QuatEuler'></a><h3 class='function'>QuatEuler</h3>
<pre class='funcdef'><span class='retname'>quat = </span>QuatEuler(<span class='argname'>x, y, z</span>)</pre>
<p>Arguments<br/>
<span class='argname'>x</span> <span class='argtype'>(number)</span> &ndash; Angle around X axis in degrees, sometimes also called roll or bank<br/>
<span class='argname'>y</span> <span class='argtype'>(number)</span> &ndash; Angle around Y axis in degrees, sometimes also called yaw or heading<br/>
<span class='argname'>z</span> <span class='argtype'>(number)</span> &ndash; Angle around Z axis in degrees, sometimes also called pitch or attitude<br/>
<p>Return value<br/>
<span class='retname'>quat</span> <span class='argtype'>(TQuat)</span> &ndash; New quaternion<br/>
<p>Create quaternion using euler angle notation. The order of applied rotations uses the
"NASA standard aeroplane" model:
<ol>
<li>Rotation around Y axis (yaw or heading)</li>
<li>Rotation around Z axis (pitch or attitude)</li>
<li>Rotation around X axis (roll or bank)</li>
</ol>
<p>
</p>
<pre class='example'>
function init()
	--Create quaternion representing rotation 30 degrees around Y axis and 25 degrees around Z axis
	local q = QuatEuler(0, 30, 25)
end

</pre>
<hr/>
<a name='QuatAlignXZ'></a><h3 class='function'>QuatAlignXZ</h3>
<pre class='funcdef'><span class='retname'>quat = </span>QuatAlignXZ(<span class='argname'>xAxis, zAxis</span>)</pre>
<p>Arguments<br/>
<span class='argname'>xAxis</span> <span class='argtype'>(TVec)</span> &ndash; X axis<br/>
<span class='argname'>zAxis</span> <span class='argtype'>(TVec)</span> &ndash; Z axis<br/>
<p>Return value<br/>
<span class='retname'>quat</span> <span class='argtype'>(TQuat)</span> &ndash; Quaternion<br/>
<p>Return the quaternion aligned to specified axes
<p>
</p>
<pre class='example'>
function update()
	local laserSprite = LoadSprite("gfx/laser.png")
	local origin = Vec(0, 0, 0)
	local dir = Vec(1, 0, 0)
	local length = 10
	local hitPoint = VecAdd(origin, VecScale(dir, length))
	local t = Transform(VecLerp(origin, hitPoint, 0.5))
	local xAxis = VecNormalize(VecSub(hitPoint, origin))
	local zAxis = VecNormalize(VecSub(origin, GetCameraTransform().pos))
	t.rot = QuatAlignXZ(xAxis, zAxis)
	DrawSprite(laserSprite, t, length, 0.05+math.random()*0.01, 8, 4, 4, 1, true, true)
	DrawSprite(laserSprite, t, length, 0.5, 1.0, 0.3, 0.3, 1, true, true)
end

</pre>
<hr/>
<a name='GetQuatEuler'></a><h3 class='function'>GetQuatEuler</h3>
<pre class='funcdef'><span class='retname'>x, y, z = </span>GetQuatEuler(<span class='argname'>quat</span>)</pre>
<p>Arguments<br/>
<span class='argname'>quat</span> <span class='argtype'>(TQuat)</span> &ndash; Quaternion<br/>
<p>Return value<br/>
<span class='retname'>x</span> <span class='argtype'>(number)</span> &ndash; Angle around X axis in degrees, sometimes also called roll or bank<br/>
<span class='retname'>y</span> <span class='argtype'>(number)</span> &ndash; Angle around Y axis in degrees, sometimes also called yaw or heading<br/>
<span class='retname'>z</span> <span class='argtype'>(number)</span> &ndash; Angle around Z axis in degrees, sometimes also called pitch or attitude<br/>
<p>Return euler angles from quaternion. The order of rotations uses the "NASA standard aeroplane" model:
<ol>
<li>Rotation around Y axis (yaw or heading)</li>
<li>Rotation around Z axis (pitch or attitude)</li>
<li>Rotation around X axis (roll or bank)</li>
</ol>
<p>
</p>
<pre class='example'>
function init()
	--Return euler angles from quaternion q
	q = QuatEuler(30, 45, 0)
	rx, ry, rz = GetQuatEuler(q)
	DebugPrint(rx .. " " .. ry .. " " .. rz)
end

</pre>
<hr/>
<a name='QuatLookAt'></a><h3 class='function'>QuatLookAt</h3>
<pre class='funcdef'><span class='retname'>quat = </span>QuatLookAt(<span class='argname'>eye, target</span>)</pre>
<p>Arguments<br/>
<span class='argname'>eye</span> <span class='argtype'>(TVec)</span> &ndash; Vector representing the camera location<br/>
<span class='argname'>target</span> <span class='argtype'>(TVec)</span> &ndash; Vector representing the point to look at<br/>
<p>Return value<br/>
<span class='retname'>quat</span> <span class='argtype'>(TQuat)</span> &ndash; New quaternion<br/>
<p>Create a quaternion pointing the negative Z axis (forward) towards
a specific point, keeping the Y axis upwards. This is very useful
for creating camera transforms.
<p>
</p>
<pre class='example'>
function init()
	local eye = Vec(0, 10, 0)
	local target = Vec(0, 1, 5)
	local rot = QuatLookAt(eye, target)
	SetCameraTransform(Transform(eye, rot))
end

</pre>
<hr/>
<a name='QuatSlerp'></a><h3 class='function'>QuatSlerp</h3>
<pre class='funcdef'><span class='retname'>c = </span>QuatSlerp(<span class='argname'>a, b, t</span>)</pre>
<p>Arguments<br/>
<span class='argname'>a</span> <span class='argtype'>(TQuat)</span> &ndash; Quaternion<br/>
<span class='argname'>b</span> <span class='argtype'>(TQuat)</span> &ndash; Quaternion<br/>
<span class='argname'>t</span> <span class='argtype'>(number)</span> &ndash; fraction (usually between 0.0 and 1.0)<br/>
<p>Return value<br/>
<span class='retname'>c</span> <span class='argtype'>(TQuat)</span> &ndash; New quaternion<br/>
<p>Spherical, linear interpolation between a and b, using t. This is
very useful for animating between two rotations.
<p>
</p>
<pre class='example'>
function init()
	local a = QuatEuler(0, 10, 0)
	local b = QuatEuler(0, 0, 45)

	--Create quaternion half way between a and b
	local q = QuatSlerp(a, b, 0.5)
	DebugPrint(QuatStr(q))
end

</pre>
<hr/>
<a name='QuatStr'></a><h3 class='function'>QuatStr</h3>
<pre class='funcdef'><span class='retname'>str = </span>QuatStr(<span class='argname'>quat</span>)</pre>
<p>Arguments<br/>
<span class='argname'>quat</span> <span class='argtype'>(TQuat)</span> &ndash; Quaternion<br/>
<p>Return value<br/>
<span class='retname'>str</span> <span class='argtype'>(string)</span> &ndash; String representation<br/>
<p>Returns the string representation of quaternion
<p>
</p>
<pre class='example'>
function init()
	local q = QuatEuler(0, 10, 0)
	DebugPrint(QuatStr(q))
end

</pre>
<hr/>
<a name='QuatRotateQuat'></a><h3 class='function'>QuatRotateQuat</h3>
<pre class='funcdef'><span class='retname'>c = </span>QuatRotateQuat(<span class='argname'>a, b</span>)</pre>
<p>Arguments<br/>
<span class='argname'>a</span> <span class='argtype'>(TQuat)</span> &ndash; Quaternion<br/>
<span class='argname'>b</span> <span class='argtype'>(TQuat)</span> &ndash; Quaternion<br/>
<p>Return value<br/>
<span class='retname'>c</span> <span class='argtype'>(TQuat)</span> &ndash; New quaternion<br/>
<p>Rotate one quaternion with another quaternion. This is mathematically
equivalent to c = a * b using quaternion multiplication.
<p>
</p>
<pre class='example'>
function init()
	local a = QuatEuler(0, 10, 0)
	local b = QuatEuler(0, 0, 45)
	local q = QuatRotateQuat(a, b)

	--q now represents a rotation first 10 degrees around
	--the Y axis and then 45 degrees around the Z axis.
	local x, y, z = GetQuatEuler(q)
	DebugPrint(x .. " " .. y .. " " .. z)
end


</pre>
<hr/>
<a name='QuatRotateVec'></a><h3 class='function'>QuatRotateVec</h3>
<pre class='funcdef'><span class='retname'>vec = </span>QuatRotateVec(<span class='argname'>a, vec</span>)</pre>
<p>Arguments<br/>
<span class='argname'>a</span> <span class='argtype'>(TQuat)</span> &ndash; Quaternion<br/>
<span class='argname'>vec</span> <span class='argtype'>(TVec)</span> &ndash; Vector<br/>
<p>Return value<br/>
<span class='retname'>vec</span> <span class='argtype'>(TVec)</span> &ndash; Rotated vector<br/>
<p>Rotate a vector by a quaternion
<p>
</p>
<pre class='example'>
function init()
	local q = QuatEuler(0, 10, 0)
	local v = Vec(1, 0, 0)
	local r = QuatRotateVec(q, v)
	
	--r is now vector a rotated 10 degrees around the Y axis
	DebugPrint(VecStr(r))
end

</pre>
<hr/>
<a name='Transform'></a><h3 class='function'>Transform</h3>
<pre class='funcdef'><span class='retname'>transform = </span>Transform(<span class='argname'>[pos], [rot]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>pos</span> <span class='argtype'>(TVec, optional)</span> &ndash; Vector representing transform position<br/>
<span class='argname'>rot</span> <span class='argtype'>(TQuat, optional)</span> &ndash; Quaternion representing transform rotation<br/>
<p>Return value<br/>
<span class='retname'>transform</span> <span class='argtype'>(TTransform)</span> &ndash; New transform<br/>
<p>A transform is a regular lua table with two entries: pos and rot,
a vector and quaternion representing transform position and rotation.
<p>
</p>
<pre class='example'>
function init()
	--Create transform located at {0, 0, 0} with no rotation
	local t1 = Transform()

	--Create transform located at {10, 0, 0} with no rotation
	local t2 = Transform(Vec(10, 0,0))

	--Create transform located at {10, 0, 0}, rotated 45 degrees around Y axis
	local t3 = Transform(Vec(10, 0,0), QuatEuler(0, 45, 0))

	DebugPrint(TransformStr(t1))
	DebugPrint(TransformStr(t2))
	DebugPrint(TransformStr(t3))
end

</pre>
<hr/>
<a name='TransformCopy'></a><h3 class='function'>TransformCopy</h3>
<pre class='funcdef'><span class='retname'>new = </span>TransformCopy(<span class='argname'>org</span>)</pre>
<p>Arguments<br/>
<span class='argname'>org</span> <span class='argtype'>(TTransform)</span> &ndash; Transform<br/>
<p>Return value<br/>
<span class='retname'>new</span> <span class='argtype'>(TTransform)</span> &ndash; Copy of org transform<br/>
<p>Transforms should never be assigned like regular numbers. Since they are
implemented with lua tables assignment means two references pointing to
the same data. Use this function instead.
<p>
</p>
<pre class='example'>
function init()
	--Do this to assign a quaternion
	local right1 = Transform(Vec(1,0,0), QuatEuler(0, 90, 0))
	local right2 = TransformCopy(right1)

	--Never do this unless you REALLY know what you're doing
	local wrong1 = Transform(Vec(1,0,0), QuatEuler(0, 90, 0))
	local wrong2 = wrong1
end

</pre>
<hr/>
<a name='TransformStr'></a><h3 class='function'>TransformStr</h3>
<pre class='funcdef'><span class='retname'>str = </span>TransformStr(<span class='argname'>transform</span>)</pre>
<p>Arguments<br/>
<span class='argname'>transform</span> <span class='argtype'>(TTransform)</span> &ndash; Transform<br/>
<p>Return value<br/>
<span class='retname'>str</span> <span class='argtype'>(string)</span> &ndash; String representation<br/>
<p>Returns the string representation of transform
<p>
</p>
<pre class='example'>
function init()
	local eye = Vec(0, 10, 0)
	local target = Vec(0, 1, 5)
	local rot = QuatLookAt(eye, target)
	local t = Transform(eye, rot)
	DebugPrint(TransformStr(t))
end

</pre>
<hr/>
<a name='TransformToParentTransform'></a><h3 class='function'>TransformToParentTransform</h3>
<pre class='funcdef'><span class='retname'>transform = </span>TransformToParentTransform(<span class='argname'>parent, child</span>)</pre>
<p>Arguments<br/>
<span class='argname'>parent</span> <span class='argtype'>(TTransform)</span> &ndash; Transform<br/>
<span class='argname'>child</span> <span class='argtype'>(TTransform)</span> &ndash; Transform<br/>
<p>Return value<br/>
<span class='retname'>transform</span> <span class='argtype'>(TTransform)</span> &ndash; New transform<br/>
<p>Transform child transform out of the parent transform.
This is the opposite of TransformToLocalTransform.
<p>
</p>
<pre class='example'>
function init()
	local b = GetBodyTransform(body)
	local s = GetShapeLocalTransform(shape)

	--b represents the location of body in world space
	--s represents the location of shape in body space

	local w = TransformToParentTransform(b, s)

	--w now represents the location of shape in world space
	DebugPrint(TransformStr(w))
end

</pre>
<hr/>
<a name='TransformToLocalTransform'></a><h3 class='function'>TransformToLocalTransform</h3>
<pre class='funcdef'><span class='retname'>transform = </span>TransformToLocalTransform(<span class='argname'>parent, child</span>)</pre>
<p>Arguments<br/>
<span class='argname'>parent</span> <span class='argtype'>(TTransform)</span> &ndash; Transform<br/>
<span class='argname'>child</span> <span class='argtype'>(TTransform)</span> &ndash; Transform<br/>
<p>Return value<br/>
<span class='retname'>transform</span> <span class='argtype'>(TTransform)</span> &ndash; New transform<br/>
<p>Transform one transform into the local space of another transform.
This is the opposite of TransformToParentTransform.
<p>
</p>
<pre class='example'>
function init()
	local b = GetBodyTransform(body)
	local w = GetShapeWorldTransform(shape)

	--b represents the location of body in world space
	--w represents the location of shape in world space
	
	local s = TransformToLocalTransform(b, w)

	--s now represents the location of shape in body space.
	DebugPrint(TransformStr(s))
end

</pre>
<hr/>
<a name='TransformToParentVec'></a><h3 class='function'>TransformToParentVec</h3>
<pre class='funcdef'><span class='retname'>r = </span>TransformToParentVec(<span class='argname'>t, v</span>)</pre>
<p>Arguments<br/>
<span class='argname'>t</span> <span class='argtype'>(TTransform)</span> &ndash; Transform<br/>
<span class='argname'>v</span> <span class='argtype'>(TVec)</span> &ndash; Vector<br/>
<p>Return value<br/>
<span class='retname'>r</span> <span class='argtype'>(TVec)</span> &ndash; Transformed vector<br/>
<p>Transfom vector v out of transform t only considering rotation.
<p>
</p>
<pre class='example'>
function init()
	local t = GetBodyTransform(body)
	local localUp = Vec(0, 1, 0)
	local up = TransformToParentVec(t, localUp)

	--up now represents the local body up direction in world space
	DebugPrint(VecStr(up))
end

</pre>
<hr/>
<a name='TransformToLocalVec'></a><h3 class='function'>TransformToLocalVec</h3>
<pre class='funcdef'><span class='retname'>r = </span>TransformToLocalVec(<span class='argname'>t, v</span>)</pre>
<p>Arguments<br/>
<span class='argname'>t</span> <span class='argtype'>(TTransform)</span> &ndash; Transform<br/>
<span class='argname'>v</span> <span class='argtype'>(TVec)</span> &ndash; Vector<br/>
<p>Return value<br/>
<span class='retname'>r</span> <span class='argtype'>(TVec)</span> &ndash; Transformed vector<br/>
<p>Transfom vector v into transform t only considering rotation.
<p>
</p>
<pre class='example'>
function init()
	local t = GetBodyTransform(body)
	local localUp = Vec(0, 1, 0)
	local up = TransformToParentVec(t, localUp)

	--up now represents the local body up direction in world space
	DebugPrint(VecStr(up))
end

</pre>
<hr/>
<a name='TransformToParentPoint'></a><h3 class='function'>TransformToParentPoint</h3>
<pre class='funcdef'><span class='retname'>r = </span>TransformToParentPoint(<span class='argname'>t, p</span>)</pre>
<p>Arguments<br/>
<span class='argname'>t</span> <span class='argtype'>(TTransform)</span> &ndash; Transform<br/>
<span class='argname'>p</span> <span class='argtype'>(TVec)</span> &ndash; Vector representing position<br/>
<p>Return value<br/>
<span class='retname'>r</span> <span class='argtype'>(TVec)</span> &ndash; Transformed position<br/>
<p>Transfom position p out of transform t.
<p>
</p>
<pre class='example'>
function init()
	local t = GetBodyTransform(body)
	local bodyPoint = Vec(0, 0, -1)
	local p = TransformToParentPoint(t, bodyPoint)

	--p now represents the local body point {0, 0, -1 } in world space
	DebugPrint(VecStr(p))
end

</pre>
<hr/>
<a name='TransformToLocalPoint'></a><h3 class='function'>TransformToLocalPoint</h3>
<pre class='funcdef'><span class='retname'>r = </span>TransformToLocalPoint(<span class='argname'>t, p</span>)</pre>
<p>Arguments<br/>
<span class='argname'>t</span> <span class='argtype'>(TTransform)</span> &ndash; Transform<br/>
<span class='argname'>p</span> <span class='argtype'>(TVec)</span> &ndash; Vector representing position<br/>
<p>Return value<br/>
<span class='retname'>r</span> <span class='argtype'>(TVec)</span> &ndash; Transformed position<br/>
<p>Transfom position p into transform t.
<p>
</p>
<pre class='example'>
function init()
	local t = GetBodyTransform(body)
	local worldOrigo = Vec(0, 0, 0)
	local p = TransformToLocalPoint(t, worldOrigo)

	--p now represents the position of world origo in local body space
	DebugPrint(VecStr(p))
end

</pre>
<hr/>
<a name='FindEntity'></a><h3 class='function'>FindEntity</h3>
<pre class='funcdef'><span class='retname'>handle = </span>FindEntity(<span class='argname'>[tag], [global], [type]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>tag</span> <span class='argtype'>(string, optional)</span> &ndash; Tag name<br/>
<span class='argname'>global</span> <span class='argtype'>(boolean, optional)</span> &ndash; Search in entire scene<br/>
<span class='argname'>type</span> <span class='argtype'>(string, optional)</span> &ndash; Entity type ("body", "shape", "light", "location" etc.)<br/>
<p>Return value<br/>
<span class='retname'>handle</span> <span class='argtype'>(number)</span> &ndash; Handle to first entity with specified tag or zero if not found<br/>
<p>Returns an entity with the specified tag and type. This is a universal method that is an alternative to FindBody, FindShape, FindVehicle, etc.
<p>
</p>
<pre class='example'>
function tick()
	--You may use this function in a similar way to other "Find functions" like FindBody, FindShape, FindVehicle, etc.
	local myCar = FindEntity("myCar", false, "vehicle")

	--If you do not specify the tag, the first element found will be returned
	local joint = FindEntity("", true, "joint")

	--If the type is not specified, the search will be performed for all types of entity
	local target = FindEntity("target", true)
end

</pre>
<hr/>
<a name='FindEntities'></a><h3 class='function'>FindEntities</h3>
<pre class='funcdef'><span class='retname'>list = </span>FindEntities(<span class='argname'>[tag], [global], [type]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>tag</span> <span class='argtype'>(string, optional)</span> &ndash; Tag name<br/>
<span class='argname'>global</span> <span class='argtype'>(boolean, optional)</span> &ndash; Search in entire scene<br/>
<span class='argname'>type</span> <span class='argtype'>(string, optional)</span> &ndash; Entity type ("body", "shape", "light", "location" etc.)<br/>
<p>Return value<br/>
<span class='retname'>list</span> <span class='argtype'>(table)</span> &ndash; Indexed table with handles to all entities with specified tag<br/>
<p>Returns a list of entities with the specified tag and type. This is a universal method that is an alternative to FindBody, FindShape, FindVehicle, etc.
<p>
</p>
<pre class='example'>
function tick()
	-- You may use this function in a similar way to other "Find functions" like FindBody, FindShape, FindVehicle, etc.
	local cars = FindEntities("car", false, "vehicle")

	-- You can get all the entities of the specified type by passing an empty string to the tag
	local allJoints = FindEntities("", true, "joint")

	-- If the type is not specified, the search will be performed for all types
	local allUnbreakables = FindEntities("unbreakable", true)
end

</pre>
<hr/>
<a name='GetEntityChildren'></a><h3 class='function'>GetEntityChildren</h3>
<pre class='funcdef'><span class='retname'>list = </span>GetEntityChildren(<span class='argname'>handle, [tag], [recursive], [type]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Entity handle<br/>
<span class='argname'>tag</span> <span class='argtype'>(string, optional)</span> &ndash; Tag name<br/>
<span class='argname'>recursive</span> <span class='argtype'>(boolean, optional)</span> &ndash; Search recursively<br/>
<span class='argname'>type</span> <span class='argtype'>(string, optional)</span> &ndash; Entity type ("body", "shape", "light", "location" etc.)<br/>
<p>Return value<br/>
<span class='retname'>list</span> <span class='argtype'>(table)</span> &ndash; Indexed table with child elements of the entity<br/>
<p>Returns child entities
<p>
</p>
<pre class='example'>
function tick()
	local car = FindEntity("car", true, "vehicle")
	DebugWatch("car", car)

	local children = GetEntityChildren(entity, "", true, "wheel")
	for i = 1, #children do
		DebugWatch("wheel " .. tostring(i), children[i])
	end
end

</pre>
<hr/>
<a name='GetEntityParent'></a><h3 class='function'>GetEntityParent</h3>
<pre class='funcdef'><span class='retname'>handle = </span>GetEntityParent(<span class='argname'>handle, [tag], [type]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Entity handle<br/>
<span class='argname'>tag</span> <span class='argtype'>(string, optional)</span> &ndash; Tag name<br/>
<span class='argname'>type</span> <span class='argtype'>(string, optional)</span> &ndash; Entity type ("body", "shape", "light", "location" etc.)<br/>
<p>Return value<br/>
<span class='retname'>handle</span> <span class='argtype'>(number)</span> &ndash; <br/>
<p><p>
</p>
<pre class='example'>
function tick()
	local wheel = FindEntity("", true, "wheel")
	local vehicle = GetEntityParent(wheel,  "", "vehicle")
	DebugWatch("Wheel vehicle", GetEntityType(vehicle) .. " " .. tostring(vehicle))
end

</pre>
<hr/>
<a name='SetTag'></a><h3 class='function'>SetTag</h3>
<pre class='funcdef'><span class='retname'></span>SetTag(<span class='argname'>handle, tag, [value]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Entity handle<br/>
<span class='argname'>tag</span> <span class='argtype'>(string)</span> &ndash; Tag name<br/>
<span class='argname'>value</span> <span class='argtype'>(string, optional)</span> &ndash; Tag value<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p><p>
</p>
<pre class='example'>
function init()
	local handle = FindBody("body", true)
	--Add "special" tag to an entity
	SetTag(handle, "special")
	DebugPrint(HasTag(handle, "special"))

	--Add "team" tag to an entity and give it value "red"
	SetTag(handle, "team", "red")
	DebugPrint(HasTag(handle, "team"))
end

</pre>
<hr/>
<a name='RemoveTag'></a><h3 class='function'>RemoveTag</h3>
<pre class='funcdef'><span class='retname'></span>RemoveTag(<span class='argname'>handle, tag</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Entity handle<br/>
<span class='argname'>tag</span> <span class='argtype'>(string)</span> &ndash; Tag name<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Remove tag from an entity. If the tag had a value it is removed too.
<p>
</p>
<pre class='example'>
function init()
	local handle = FindBody("body", true)
	--Add "special" tag to an entity
	SetTag(handle, "special")
	RemoveTag(handle, "special")
	DebugPrint(HasTag(handle, "special"))

	--Add "team" tag to an entity and give it value "red"
	SetTag(handle, "team", "red")
	DebugPrint(HasTag(handle, "team"))
end

</pre>
<hr/>
<a name='HasTag'></a><h3 class='function'>HasTag</h3>
<pre class='funcdef'><span class='retname'>exists = </span>HasTag(<span class='argname'>handle, tag</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Entity handle<br/>
<span class='argname'>tag</span> <span class='argtype'>(string)</span> &ndash; Tag name<br/>
<p>Return value<br/>
<span class='retname'>exists</span> <span class='argtype'>(boolean)</span> &ndash; Returns true if entity has tag<br/>
<p><p>
</p>
<pre class='example'>
function init()
	local handle = FindBody("body", true)
	--Add "special" tag to an entity
	SetTag(handle, "special")
	DebugPrint(HasTag(handle, "special"))

	--Add "team" tag to an entity and give it value "red"
	SetTag(handle, "team", "red")
	DebugPrint(HasTag(handle, "team"))
end

</pre>
<hr/>
<a name='GetTagValue'></a><h3 class='function'>GetTagValue</h3>
<pre class='funcdef'><span class='retname'>value = </span>GetTagValue(<span class='argname'>handle, tag</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Entity handle<br/>
<span class='argname'>tag</span> <span class='argtype'>(string)</span> &ndash; Tag name<br/>
<p>Return value<br/>
<span class='retname'>value</span> <span class='argtype'>(string)</span> &ndash; Returns the tag value, if any. Empty string otherwise.<br/>
<p><p>
</p>
<pre class='example'>
function init()
	local handle = FindBody("body", true)

	--Add "team" tag to an entity and give it value "red"
	SetTag(handle, "team", "red")
	DebugPrint(GetTagValue(handle, "team"))
end

</pre>
<hr/>
<a name='ListTags'></a><h3 class='function'>ListTags</h3>
<pre class='funcdef'><span class='retname'>tags = </span>ListTags(<span class='argname'>handle</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Entity handle<br/>
<p>Return value<br/>
<span class='retname'>tags</span> <span class='argtype'>(table)</span> &ndash; Indexed table of tags on entity<br/>
<p><p>
</p>
<pre class='example'>
function init()
	local handle = FindBody("body", true)

	--Add "team" tag to an entity and give it value "red"
	SetTag(handle, "team", "red")
	
	--List all tags and their tag values for a particular entity
	local tags = ListTags(handle)
	for i=1, #tags do
		DebugPrint(tags[i] .. " " .. GetTagValue(handle, tags[i]))
	end
end

</pre>
<hr/>
<a name='GetDescription'></a><h3 class='function'>GetDescription</h3>
<pre class='funcdef'><span class='retname'>description = </span>GetDescription(<span class='argname'>handle</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Entity handle<br/>
<p>Return value<br/>
<span class='retname'>description</span> <span class='argtype'>(string)</span> &ndash; The description string<br/>
<p>All entities can have an associated description. For bodies and
shapes this can be provided through the editor. This function 
retrieves that description.
<p>
</p>
<pre class='example'>
function init()
	local body = FindBody("body", true)
	DebugPrint(GetDescription(body))
end

</pre>
<hr/>
<a name='SetDescription'></a><h3 class='function'>SetDescription</h3>
<pre class='funcdef'><span class='retname'></span>SetDescription(<span class='argname'>handle, description</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Entity handle<br/>
<span class='argname'>description</span> <span class='argtype'>(string)</span> &ndash; The description string<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>All entities can have an associated description. The description for 
bodies and shapes will show up on the HUD when looking at them.
<p>
</p>
<pre class='example'>
function init()
	local body = FindBody("body", true)
	SetDescription(body, "Target object")
	DebugPrint(GetDescription(body))
end

</pre>
<hr/>
<a name='Delete'></a><h3 class='function'>Delete</h3>
<pre class='funcdef'><span class='retname'></span>Delete(<span class='argname'>handle</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Entity handle<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Remove an entity from the scene. All entities owned by this entity
will also be removed.
<p>
</p>
<pre class='example'>
function init()
	local body = FindBody("body", true)
	--All shapes associated with body will also be removed
	Delete(body)
end

</pre>
<hr/>
<a name='IsHandleValid'></a><h3 class='function'>IsHandleValid</h3>
<pre class='funcdef'><span class='retname'>exists = </span>IsHandleValid(<span class='argname'>handle</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Entity handle<br/>
<p>Return value<br/>
<span class='retname'>exists</span> <span class='argtype'>(boolean)</span> &ndash; Returns true if the entity pointed to by handle still exists<br/>
<p><p>
</p>
<pre class='example'>
function init()
	local body = FindBody("body", true)

	--valid is true if body still exists
	DebugPrint(IsHandleValid(body))
	Delete(body)

	--valid will now be false
	DebugPrint(IsHandleValid(body))
end

</pre>
<hr/>
<a name='GetEntityType'></a><h3 class='function'>GetEntityType</h3>
<pre class='funcdef'><span class='retname'>type = </span>GetEntityType(<span class='argname'>handle</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Entity handle<br/>
<p>Return value<br/>
<span class='retname'>type</span> <span class='argtype'>(string)</span> &ndash; Type name of the provided entity<br/>
<p>Returns the type name of provided entity, for example "body", "shape", "light", etc.
<p>
</p>
<pre class='example'>
function init()
	local body = FindBody("body", true)
	DebugPrint(GetEntityType(body))
end

</pre>
<hr/>
<a name='GetProperty'></a><h3 class='function'>GetProperty</h3>
<pre class='funcdef'><span class='retname'>value = </span>GetProperty(<span class='argname'>handle, property</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Entity handle<br/>
<span class='argname'>property</span> <span class='argtype'>(string)</span> &ndash; Property name<br/>
<p>Return value<br/>
<span class='retname'>value</span> <span class='argtype'>(any)</span> &ndash; Property value<br/>
<p><table border=0><tr><td class='header'>&nbsp;Entity&nbsp;type&nbsp;</td><td class='header'>&nbsp;Available&nbsp;params</td></tr>
<tr><td class='first' valign='top'>Body		</td><td valign='top'> desc (string), dynamic (boolean), mass (number), transform, velocity (vector(x, y, z)), angVelocity (vector(x, y, z)), active (boolean), friction (number), restitution (number), frictionMode (average|minimum|multiply|maximum), restitutionMode (average|minimum|multiply|maximum)</td></tr><tr><td class='first' valign='top'>Shape		</td><td valign='top'> density (number), strength (number), size (number), emissiveScale (number), localTransform, worldTransform</td></tr><tr><td class='first' valign='top'>Light		</td><td valign='top'> enabled (boolean), color (vector(r, g, b)), intensity (number), transform, active (boolean), type (string), size (number), reach (number), unshadowed (number), fogscale (number), fogiter (number), glare (number)</td></tr><tr><td class='first' valign='top'>Location	</td><td valign='top'> transform</td></tr><tr><td class='first' valign='top'>Water		</td><td valign='top'> depth (number), wave (number), ripple (number), motion (number), foam (number), color (vector(r, g, b))</td></tr><tr><td class='first' valign='top'>Joint		</td><td valign='top'> type (string), size (number), rotstrength (number), rotspring (number);  only for ropes: slack (number), strength (number), maxstretch (number), ropecolor (vector(r, g, b))</td></tr><tr><td class='first' valign='top'>Vehicle		</td><td valign='top'> spring (number), damping (number), topspeed (number), acceleration (number), strength (number), antispin (number), antiroll (number), difflock (number), steerassist (number), friction (number), smokeintensity (number), transform, brokenthreshold (number)</td></tr><tr><td class='first' valign='top'>Wheel		</td><td valign='top'> drive (number), steer (number), travel (vector(x, y))</td></tr><tr><td class='first' valign='top'>Screen		</td><td valign='top'> enabled (boolean), bulge (number), resolution (number, number), script (string), interactive (boolean), emissive (number), fxraster (number), fxca (number), fxnoise (number), fxglitch (number), size (vector(x, y))</td></tr><tr><td class='first' valign='top'>Trigger		</td><td valign='top'> transform, type (string), size (vector(x, y, z)/number)</td></tr><table/>
<p>
</p>
<pre class='example'>
function tick()
	local body = FindBody("testbody", true)
	local isDynamic = GetProperty(body, "dynamic")
	DebugWatch("isDynamic", isDynamic)
end

</pre>
<hr/>
<a name='SetProperty'></a><h3 class='function'>SetProperty</h3>
<pre class='funcdef'><span class='retname'></span>SetProperty(<span class='argname'>handle, property, value</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Entity handle<br/>
<span class='argname'>property</span> <span class='argtype'>(string)</span> &ndash; Property name<br/>
<span class='argname'>value</span> <span class='argtype'>(any)</span> &ndash; Property value<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p><table border=0><tr><td class='header'>&nbsp;Entity&nbsp;type&nbsp;</td><td class='header'>&nbsp;Available&nbsp;params</td></tr>
<tr><td class='first' valign='top'>Body		</td><td valign='top'> desc (string), dynamic (boolean), transform, velocity (vector(x, y, z)), angVelocity (vector(x,y,z)), active (boolean), friction (number), restitution (number), frictionMode (average|minimum|multiply|maximum), restitutionMode (average|minimum|multiply|maximum)</td></tr><tr><td class='first' valign='top'>Shape		</td><td valign='top'> density (number), strength (number), emissiveScale (number), localTransform</td></tr><tr><td class='first' valign='top'>Light		</td><td valign='top'> enabled (boolean), color (vector(r, g, b)), intensity (number), transform, size (number/vector(x,y)), reach (number), unshadowed (number), fogscale (number), fogiter (number), glare (number)</td></tr><tr><td class='first' valign='top'>Location	</td><td valign='top'> transform</td></tr><tr><td class='first' valign='top'>Water		</td><td valign='top'> type (string), depth (number), wave (number), ripple (number), motion (number), foam (number), color (vector(r, g, b))</td></tr><tr><td class='first' valign='top'>Joint		</td><td valign='top'> size (number), rotstrength (number), rotspring (number);  only for ropes: slack (number), strength (number), maxstretch (number), ropecolor (vector(r, g, b))</td></tr><tr><td class='first' valign='top'>Vehicle		</td><td valign='top'> spring (number), damping (number), topspeed (number), acceleration (number), strength (number), antispin (number), antiroll (number), difflock (number), steerassist (number), friction (number), smokeintensity (number), transform, brokenthreshold (number) </td></tr><tr><td class='first' valign='top'>Wheel		</td><td valign='top'> drive (number), steer (number), travel (vector(x, y))</td></tr><tr><td class='first' valign='top'>Screen		</td><td valign='top'> enabled (boolean), interactive (boolean), emissive (number), fxraster (number), fxca (number), fxnoise (number), fxglitch (number)</td></tr><tr><td class='first' valign='top'>Trigger		</td><td valign='top'> transform, size (vector(x, y, z)/number)</td></tr><table/>
<p>
</p>
<pre class='example'>
function tick()
	local light = FindLight("mylight", true)
	SetProperty(light, "intensity", math.abs(math.sin(GetTime())))
end

</pre>
<hr/>
<a name='FindBody'></a><h3 class='function'>FindBody</h3>
<pre class='funcdef'><span class='retname'>handle = </span>FindBody(<span class='argname'>[tag], [global]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>tag</span> <span class='argtype'>(string, optional)</span> &ndash; Tag name<br/>
<span class='argname'>global</span> <span class='argtype'>(boolean, optional)</span> &ndash; Search in entire scene<br/>
<p>Return value<br/>
<span class='retname'>handle</span> <span class='argtype'>(number)</span> &ndash; Handle to first body with specified tag or zero if not found<br/>
<p><p>
</p>
<pre class='example'>
function init()
	--Search for a body tagged "target" in script scope
	local target = FindBody("body")
	DebugPrint(target)

	--Search for a body tagged "escape" in entire scene
	local escape = FindBody("body", true)
	DebugPrint(escape)
end

</pre>
<hr/>
<a name='FindBodies'></a><h3 class='function'>FindBodies</h3>
<pre class='funcdef'><span class='retname'>list = </span>FindBodies(<span class='argname'>[tag], [global]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>tag</span> <span class='argtype'>(string, optional)</span> &ndash; Tag name<br/>
<span class='argname'>global</span> <span class='argtype'>(boolean, optional)</span> &ndash; Search in entire scene<br/>
<p>Return value<br/>
<span class='retname'>list</span> <span class='argtype'>(table)</span> &ndash; Indexed table with handles to all bodies with specified tag<br/>
<p><p>
</p>
<pre class='example'>
function init()
	--Search for bodies tagged "target" in script scope
	local targets = FindBodies("target", true)
	for i=1, #targets do
		local target = targets[i]
		DebugPrint(target)
	end
end

</pre>
<hr/>
<a name='GetBodyTransform'></a><h3 class='function'>GetBodyTransform</h3>
<pre class='funcdef'><span class='retname'>transform = </span>GetBodyTransform(<span class='argname'>handle</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Body handle<br/>
<p>Return value<br/>
<span class='retname'>transform</span> <span class='argtype'>(TTransform)</span> &ndash; Transform of the body<br/>
<p><p>
</p>
<pre class='example'>
function init()
	local handle = FindBody("target", true)
	local t = GetBodyTransform(handle)
	DebugPrint(TransformStr(t))
end

</pre>
<hr/>
<a name='SetBodyTransform'></a><h3 class='function'>SetBodyTransform</h3>
<pre class='funcdef'><span class='retname'></span>SetBodyTransform(<span class='argname'>handle, transform</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Body handle<br/>
<span class='argname'>transform</span> <span class='argtype'>(TTransform)</span> &ndash; Desired transform<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p><p>
</p>
<pre class='example'>
function init()
	local handle = FindBody("body", true)

	--Move a body 1 meter upwards
	local t = GetBodyTransform(handle)
	t.pos = VecAdd(t.pos, Vec(0, 3, 0))
	SetBodyTransform(handle, t)
end

</pre>
<hr/>
<a name='GetBodyMass'></a><h3 class='function'>GetBodyMass</h3>
<pre class='funcdef'><span class='retname'>mass = </span>GetBodyMass(<span class='argname'>handle</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Body handle<br/>
<p>Return value<br/>
<span class='retname'>mass</span> <span class='argtype'>(number)</span> &ndash; Body mass. Static bodies always return zero mass.<br/>
<p><p>
</p>
<pre class='example'>
function init()
	local handle = FindBody("body", true)

	--Move a body 1 meter upwards
	local mass = GetBodyMass(handle)
	DebugPrint(mass)
end

</pre>
<hr/>
<a name='IsBodyDynamic'></a><h3 class='function'>IsBodyDynamic</h3>
<pre class='funcdef'><span class='retname'>dynamic = </span>IsBodyDynamic(<span class='argname'>handle</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Body handle<br/>
<p>Return value<br/>
<span class='retname'>dynamic</span> <span class='argtype'>(boolean)</span> &ndash; Return true if body is dynamic<br/>
<p>Check if body is dynamic. Note that something that was created static 
may become dynamic due to destruction.
<p>
</p>
<pre class='example'>
function init()
	local handle = FindBody("body", true)
	DebugPrint(IsBodyDynamic(handle))
end

</pre>
<hr/>
<a name='SetBodyDynamic'></a><h3 class='function'>SetBodyDynamic</h3>
<pre class='funcdef'><span class='retname'></span>SetBodyDynamic(<span class='argname'>handle, dynamic</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Body handle<br/>
<span class='argname'>dynamic</span> <span class='argtype'>(boolean)</span> &ndash; True for dynamic. False for static.<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Change the dynamic state of a body. There is very limited use for this
function. In most situations you should leave it up to the engine to decide.
Use with caution.
<p>
</p>
<pre class='example'>
function init()
	local handle = FindBody("body", true)
	SetBodyDynamic(handle, false)
	DebugPrint(IsBodyDynamic(handle))
end

</pre>
<hr/>
<a name='SetBodyVelocity'></a><h3 class='function'>SetBodyVelocity</h3>
<pre class='funcdef'><span class='retname'></span>SetBodyVelocity(<span class='argname'>handle, velocity</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Body handle (should be a dynamic body)<br/>
<span class='argname'>velocity</span> <span class='argtype'>(TVec)</span> &ndash; Vector with linear velocity<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>This can be used for animating bodies with preserved physical interaction,
but in most cases you are better off with a motorized joint instead.
<p>
</p>
<pre class='example'>
function init()
	local handle = FindBody("body", true)
	local vel = Vec(0,10,0)
	SetBodyVelocity(handle, vel)
end

</pre>
<hr/>
<a name='GetBodyVelocity'></a><h3 class='function'>GetBodyVelocity</h3>
<pre class='funcdef'><span class='retname'>velocity = </span>GetBodyVelocity(<span class='argname'>handle</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Body handle (should be a dynamic body)<br/>
<p>Return value<br/>
<span class='retname'>velocity</span> <span class='argtype'>(TVec)</span> &ndash; Linear velocity as vector<br/>
<p><p>
</p>
<pre class='example'>
function init()
	handle = FindBody("body", true)
	local vel = Vec(0,10,0)
	SetBodyVelocity(handle, vel)
end

function tick()
	DebugPrint(VecStr(GetBodyVelocity(handle)))
end

</pre>
<hr/>
<a name='GetBodyVelocityAtPos'></a><h3 class='function'>GetBodyVelocityAtPos</h3>
<pre class='funcdef'><span class='retname'>velocity = </span>GetBodyVelocityAtPos(<span class='argname'>handle, pos</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Body handle (should be a dynamic body)<br/>
<span class='argname'>pos</span> <span class='argtype'>(TVec)</span> &ndash; World space point as vector<br/>
<p>Return value<br/>
<span class='retname'>velocity</span> <span class='argtype'>(TVec)</span> &ndash; Linear velocity on body at pos as vector<br/>
<p>Return the velocity on a body taking both linear and angular velocity into account.
<p>
</p>
<pre class='example'>
function init()
	handle = FindBody("body", true)
	local vel = Vec(0,10,0)
	SetBodyVelocity(handle, vel)
end

function tick()
	DebugPrint(VecStr(GetBodyVelocityAtPos(handle, Vec(0, 0, 0))))
end

</pre>
<hr/>
<a name='SetBodyAngularVelocity'></a><h3 class='function'>SetBodyAngularVelocity</h3>
<pre class='funcdef'><span class='retname'></span>SetBodyAngularVelocity(<span class='argname'>handle, angVel</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Body handle (should be a dynamic body)<br/>
<span class='argname'>angVel</span> <span class='argtype'>(TVec)</span> &ndash; Vector with angular velocity<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>This can be used for animating bodies with preserved physical interaction,
but in most cases you are better off with a motorized joint instead.
<p>
</p>
<pre class='example'>
function init()
	handle = FindBody("body", true)
	local angVel = Vec(0,100,0)
	SetBodyAngularVelocity(handle, angVel)
end

</pre>
<hr/>
<a name='GetBodyAngularVelocity'></a><h3 class='function'>GetBodyAngularVelocity</h3>
<pre class='funcdef'><span class='retname'>angVel = </span>GetBodyAngularVelocity(<span class='argname'>handle</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Body handle (should be a dynamic body)<br/>
<p>Return value<br/>
<span class='retname'>angVel</span> <span class='argtype'>(TVec)</span> &ndash; Angular velocity as vector<br/>
<p><p>
</p>
<pre class='example'>
function init()
	handle = FindBody("body", true)
	local angVel = Vec(0,100,0)
	SetBodyAngularVelocity(handle, angVel)
end

function tick()
	DebugPrint(VecStr(GetBodyAngularVelocity(handle)))
end

</pre>
<hr/>
<a name='IsBodyActive'></a><h3 class='function'>IsBodyActive</h3>
<pre class='funcdef'><span class='retname'>active = </span>IsBodyActive(<span class='argname'>handle</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Body handle<br/>
<p>Return value<br/>
<span class='retname'>active</span> <span class='argtype'>(boolean)</span> &ndash; Return true if body is active<br/>
<p>Check if body is body is currently simulated. For performance reasons,
bodies that don't move are taken out of the simulation. This function
can be used to query the active state of a specific body. Only dynamic
bodies can be active.
<p>
</p>
<pre class='example'>
-- try to break the body to see the logs
function tick()
	handle = FindBody("body", true)
	if IsBodyActive(handle) then
		DebugPrint("Body is active")
	end
end

</pre>
<hr/>
<a name='SetBodyActive'></a><h3 class='function'>SetBodyActive</h3>
<pre class='funcdef'><span class='retname'></span>SetBodyActive(<span class='argname'>handle, active</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Body handle<br/>
<span class='argname'>active</span> <span class='argtype'>(boolean)</span> &ndash; Set to tru if body should be active (simulated)<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>This function makes it possible to manually activate and deactivate bodies to include or
exclude in simulation. The engine normally handles this automatically, so use with care.
<p>
</p>
<pre class='example'>
function tick()
	handle = FindBody("body", true)

	-- Forces body to "sleep"
	SetBodyActive(handle, false)
	if IsBodyActive(handle) then
		DebugPrint("Body is active")
	end
end

</pre>
<hr/>
<a name='ApplyBodyImpulse'></a><h3 class='function'>ApplyBodyImpulse</h3>
<pre class='funcdef'><span class='retname'></span>ApplyBodyImpulse(<span class='argname'>handle, position, impulse</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Body handle (should be a dynamic body)<br/>
<span class='argname'>position</span> <span class='argtype'>(TVec)</span> &ndash; World space position as vector<br/>
<span class='argname'>impulse</span> <span class='argtype'>(TVec)</span> &ndash; World space impulse as vector<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Apply impulse to dynamic body at position (give body a push).
<p>
</p>
<pre class='example'>
function tick()
	handle = FindBody("body", true)

	local pos = Vec(0,1,0)
	local imp = Vec(0,0,10)
	ApplyBodyImpulse(handle, pos, imp)
end

</pre>
<hr/>
<a name='GetBodyShapes'></a><h3 class='function'>GetBodyShapes</h3>
<pre class='funcdef'><span class='retname'>list = </span>GetBodyShapes(<span class='argname'>handle</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Body handle<br/>
<p>Return value<br/>
<span class='retname'>list</span> <span class='argtype'>(table)</span> &ndash; Indexed table of shape handles<br/>
<p>Return handles to all shapes owned by a body
<p>
</p>
<pre class='example'>
function init()
	handle = FindBody("body", true)

	local shapes = GetBodyShapes(handle)
	for i=1,#shapes do
		local shape = shapes[i]
		DebugPrint(shape)
	end
end

</pre>
<hr/>
<a name='GetBodyVehicle'></a><h3 class='function'>GetBodyVehicle</h3>
<pre class='funcdef'><span class='retname'>handle = </span>GetBodyVehicle(<span class='argname'>body</span>)</pre>
<p>Arguments<br/>
<span class='argname'>body</span> <span class='argtype'>(number)</span> &ndash; Body handle<br/>
<p>Return value<br/>
<span class='retname'>handle</span> <span class='argtype'>(number)</span> &ndash; Get parent vehicle for body, or zero if not part of vehicle<br/>
<p><p>
</p>
<pre class='example'>
function init()
	handle = FindBody("body", true)

	local vehicle = GetBodyVehicle(handle)
	DebugPrint(vehicle)
end

</pre>
<hr/>
<a name='GetBodyBounds'></a><h3 class='function'>GetBodyBounds</h3>
<pre class='funcdef'><span class='retname'>min, max = </span>GetBodyBounds(<span class='argname'>handle</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Body handle<br/>
<p>Return value<br/>
<span class='retname'>min</span> <span class='argtype'>(TVec)</span> &ndash; Vector representing the AABB lower bound<br/>
<span class='retname'>max</span> <span class='argtype'>(TVec)</span> &ndash; Vector representing the AABB upper bound<br/>
<p>Return the world space, axis-aligned bounding box for a body.
<p>
</p>
<pre class='example'>
function init()
	handle = FindBody("body", true)

	local min, max = GetBodyBounds(handle)
	local boundsSize = VecSub(max, min)
	local center = VecLerp(min, max, 0.5)
	DebugPrint(VecStr(boundsSize) .. " " .. VecStr(center))
end

</pre>
<hr/>
<a name='GetBodyCenterOfMass'></a><h3 class='function'>GetBodyCenterOfMass</h3>
<pre class='funcdef'><span class='retname'>point = </span>GetBodyCenterOfMass(<span class='argname'>handle</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Body handle<br/>
<p>Return value<br/>
<span class='retname'>point</span> <span class='argtype'>(TVec)</span> &ndash; Vector representing local center of mass in body space<br/>
<p><p>
</p>
<pre class='example'>
function init()
	handle = FindBody("body", true)
end

function tick()
	--Visualize center of mass on for body
	local com = GetBodyCenterOfMass(handle)
	local worldPoint = TransformToParentPoint(GetBodyTransform(handle), com)
	DebugCross(worldPoint)
end

</pre>
<hr/>
<a name='IsBodyVisible'></a><h3 class='function'>IsBodyVisible</h3>
<pre class='funcdef'><span class='retname'>visible = </span>IsBodyVisible(<span class='argname'>handle, maxDist, [rejectTransparent]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Body handle<br/>
<span class='argname'>maxDist</span> <span class='argtype'>(number)</span> &ndash; Maximum visible distance<br/>
<span class='argname'>rejectTransparent</span> <span class='argtype'>(boolean, optional)</span> &ndash; See through transparent materials. Default false.<br/>
<p>Return value<br/>
<span class='retname'>visible</span> <span class='argtype'>(boolean)</span> &ndash; Return true if body is visible<br/>
<p>This function does a very rudimetary check and will only return true if the 
object is visible within 74 degrees of the camera's forward direction, and
only tests line-of-sight visibility for the corners and center of the bounding box.
<p>
</p>
<pre class='example'>
local handle = 0
function init()
	handle = FindBody("body", true)
end

function tick()
	if IsBodyVisible(handle, 25) then
		--Body is within 25 meters visible to the camera
		DebugPrint("visible")
	else
		DebugPrint("not visible")
	end
end

</pre>
<hr/>
<a name='IsBodyBroken'></a><h3 class='function'>IsBodyBroken</h3>
<pre class='funcdef'><span class='retname'>broken = </span>IsBodyBroken(<span class='argname'>handle</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Body handle<br/>
<p>Return value<br/>
<span class='retname'>broken</span> <span class='argtype'>(boolean)</span> &ndash; Return true if body is broken<br/>
<p>Determine if any shape of a body has been broken.
<p>
</p>
<pre class='example'>
local handle = 0
function init()
	handle = FindBody("body", true)
end

function tick()
	DebugPrint(IsBodyBroken(handle))
end

</pre>
<hr/>
<a name='IsBodyJointedToStatic'></a><h3 class='function'>IsBodyJointedToStatic</h3>
<pre class='funcdef'><span class='retname'>result = </span>IsBodyJointedToStatic(<span class='argname'>handle</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Body handle<br/>
<p>Return value<br/>
<span class='retname'>result</span> <span class='argtype'>(boolean)</span> &ndash; Return true if body is in any way connected to a static body<br/>
<p>Determine if a body is in any way connected to a static object, either by being static itself or
be being directly or indirectly jointed to something static.
<p>
</p>
<pre class='example'>
local handle = 0
function init()
	handle = FindBody("body", true)
end

function tick()
	DebugPrint(IsBodyJointedToStatic(handle))
end

</pre>
<hr/>
<a name='DrawBodyOutline'></a><h3 class='function'>DrawBodyOutline</h3>
<pre class='funcdef'><span class='retname'></span>DrawBodyOutline(<span class='argname'>handle, [r], [g], [b], [a]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Body handle<br/>
<span class='argname'>r</span> <span class='argtype'>(number, optional)</span> &ndash; Red<br/>
<span class='argname'>g</span> <span class='argtype'>(number, optional)</span> &ndash; Green<br/>
<span class='argname'>b</span> <span class='argtype'>(number, optional)</span> &ndash; Blue<br/>
<span class='argname'>a</span> <span class='argtype'>(number, optional)</span> &ndash; Alpha<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Render next frame with an outline around specified body.
If no color is given, a white outline will be drawn.
<p>
</p>
<pre class='example'>
local handle = 0
function init()
	handle = FindBody("body", true)
end

function tick()
	if InputDown("interact") then
		--Draw white outline at 50% transparency
		DrawBodyOutline(handle, 0.5)
	else
		--Draw green outline, fully opaque
		DrawBodyOutline(handle, 0, 1, 0, 1)
	end
end

</pre>
<hr/>
<a name='DrawBodyHighlight'></a><h3 class='function'>DrawBodyHighlight</h3>
<pre class='funcdef'><span class='retname'></span>DrawBodyHighlight(<span class='argname'>handle, amount</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Body handle<br/>
<span class='argname'>amount</span> <span class='argtype'>(number)</span> &ndash; Amount<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Flash the appearance of a body when rendering this frame. This is
used for valuables in the game.
<p>
</p>
<pre class='example'>
local handle = 0
function init()
	handle = FindBody("body", true)
end

function tick()
	if InputDown("interact") then
		DrawBodyHighlight(handle, 0.5)
	end
end

</pre>
<hr/>
<a name='GetBodyClosestPoint'></a><h3 class='function'>GetBodyClosestPoint</h3>
<pre class='funcdef'><span class='retname'>hit, point, normal, shape = </span>GetBodyClosestPoint(<span class='argname'>body, origin</span>)</pre>
<p>Arguments<br/>
<span class='argname'>body</span> <span class='argtype'>(number)</span> &ndash; Body handle<br/>
<span class='argname'>origin</span> <span class='argtype'>(TVec)</span> &ndash; World space point<br/>
<p>Return value<br/>
<span class='retname'>hit</span> <span class='argtype'>(boolean)</span> &ndash; True if a point was found<br/>
<span class='retname'>point</span> <span class='argtype'>(TVec)</span> &ndash; World space closest point<br/>
<span class='retname'>normal</span> <span class='argtype'>(TVec)</span> &ndash; World space normal at closest point<br/>
<span class='retname'>shape</span> <span class='argtype'>(number)</span> &ndash; Handle to closest shape<br/>
<p>This will return the closest point of a specific body
<p>
</p>
<pre class='example'>
local handle = 0
function init()
	handle = FindBody("body", true)
end

function tick()
	DebugCross(Vec(1, 0, 0))
	local hit, p, n, s = GetBodyClosestPoint(handle, Vec(1, 0, 0))
	if hit then
		DebugCross(p)
	end
end

</pre>
<hr/>
<a name='ConstrainVelocity'></a><h3 class='function'>ConstrainVelocity</h3>
<pre class='funcdef'><span class='retname'></span>ConstrainVelocity(<span class='argname'>bodyA, bodyB, point, dir, relVel, [min], [max]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>bodyA</span> <span class='argtype'>(number)</span> &ndash; First body handle (zero for static)<br/>
<span class='argname'>bodyB</span> <span class='argtype'>(number)</span> &ndash; Second body handle (zero for static)<br/>
<span class='argname'>point</span> <span class='argtype'>(TVec)</span> &ndash; World space point<br/>
<span class='argname'>dir</span> <span class='argtype'>(TVec)</span> &ndash; World space direction<br/>
<span class='argname'>relVel</span> <span class='argtype'>(number)</span> &ndash; Desired relative velocity along the provided direction<br/>
<span class='argname'>min</span> <span class='argtype'>(number, optional)</span> &ndash; Minimum impulse (default: -infinity)<br/>
<span class='argname'>max</span> <span class='argtype'>(number, optional)</span> &ndash; Maximum impulse (default: infinity)<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>This will tell the physics solver to constrain the velocity between two bodies. The physics solver
will try to reach the desired goal, while not applying an impulse bigger than the min and max values.
This function should only be used from the update callback.
<p>
</p>
<pre class='example'>
local handleA = 0
local handleB = 0
function init()
	handleA = FindBody("body", true)
	handleB = FindBody("target", true)
end

function update()
	--Constrain the velocity between bodies A and B so that the relative velocity 
	--along the X axis at point (0, 5, 0) is always 3 m/s
	ConstrainVelocity(handleA, handleB, Vec(0, 5, 0), Vec(1, 0, 0), 3)
end

</pre>
<hr/>
<a name='ConstrainAngularVelocity'></a><h3 class='function'>ConstrainAngularVelocity</h3>
<pre class='funcdef'><span class='retname'></span>ConstrainAngularVelocity(<span class='argname'>bodyA, bodyB, dir, relAngVel, [min], [max]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>bodyA</span> <span class='argtype'>(number)</span> &ndash; First body handle (zero for static)<br/>
<span class='argname'>bodyB</span> <span class='argtype'>(number)</span> &ndash; Second body handle (zero for static)<br/>
<span class='argname'>dir</span> <span class='argtype'>(TVec)</span> &ndash; World space direction<br/>
<span class='argname'>relAngVel</span> <span class='argtype'>(number)</span> &ndash; Desired relative angular velocity along the provided direction<br/>
<span class='argname'>min</span> <span class='argtype'>(number, optional)</span> &ndash; Minimum angular impulse (default: -infinity)<br/>
<span class='argname'>max</span> <span class='argtype'>(number, optional)</span> &ndash; Maximum angular impulse (default: infinity)<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>This will tell the physics solver to constrain the angular velocity between two bodies. The physics solver
will try to reach the desired goal, while not applying an angular impulse bigger than the min and max values.
This function should only be used from the update callback.
<p>
</p>
<pre class='example'>
local handleA = 0
local handleB = 0
function init()
	handleA = FindBody("body", true)
	handleB = FindBody("target", true)
end

function update()
	--Constrain the angular velocity between bodies A and B so that the relative angular velocity
	--along the Y axis is always 3 rad/s
	ConstrainAngularVelocity(handleA, handleB, Vec(1, 0, 0), 3)
end

</pre>
<hr/>
<a name='ConstrainPosition'></a><h3 class='function'>ConstrainPosition</h3>
<pre class='funcdef'><span class='retname'></span>ConstrainPosition(<span class='argname'>bodyA, bodyB, pointA, pointB, [maxVel], [maxImpulse]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>bodyA</span> <span class='argtype'>(number)</span> &ndash; First body handle (zero for static)<br/>
<span class='argname'>bodyB</span> <span class='argtype'>(number)</span> &ndash; Second body handle (zero for static)<br/>
<span class='argname'>pointA</span> <span class='argtype'>(TVec)</span> &ndash; World space point for first body<br/>
<span class='argname'>pointB</span> <span class='argtype'>(TVec)</span> &ndash; World space point for second body<br/>
<span class='argname'>maxVel</span> <span class='argtype'>(number, optional)</span> &ndash; Maximum relative velocity (default: infinite)<br/>
<span class='argname'>maxImpulse</span> <span class='argtype'>(number, optional)</span> &ndash; Maximum impulse (default: infinite)<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>This is a helper function that uses ConstrainVelocity to constrain a point on one 
body to a point on another body while not affecting the bodies more than the provided 
maximum relative velocity and maximum impulse. In other words: physically push on
the bodies so that pointA and pointB are aligned in world space. This is useful for 
physically animating objects. This function should only be used from the update callback.
<p>
</p>
<pre class='example'>
local handleA = 0
local handleB = 0
function init()
	handleA = FindBody("body", true)
	handleB = FindBody("target", true)
end

function update()
	--Constrain the origo of body a to an animated point in the world
	local worldPos = Vec(0, 3+math.sin(GetTime()), 0)
	ConstrainPosition(handleA, 0, GetBodyTransform(handleA).pos, worldPos)

	--Constrain the origo of body a to the origo of body b (like a ball joint)
	ConstrainPosition(handleA, handleA, GetBodyTransform(handleA).pos, GetBodyTransform(handleB).pos)
end

</pre>
<hr/>
<a name='ConstrainOrientation'></a><h3 class='function'>ConstrainOrientation</h3>
<pre class='funcdef'><span class='retname'></span>ConstrainOrientation(<span class='argname'>bodyA, bodyB, quatA, quatB, [maxAngVel], [maxAngImpulse]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>bodyA</span> <span class='argtype'>(number)</span> &ndash; First body handle (zero for static)<br/>
<span class='argname'>bodyB</span> <span class='argtype'>(number)</span> &ndash; Second body handle (zero for static)<br/>
<span class='argname'>quatA</span> <span class='argtype'>(TQuat)</span> &ndash; World space orientation for first body<br/>
<span class='argname'>quatB</span> <span class='argtype'>(TQuat)</span> &ndash; World space orientation for second body<br/>
<span class='argname'>maxAngVel</span> <span class='argtype'>(number, optional)</span> &ndash; Maximum relative angular velocity (default: infinite)<br/>
<span class='argname'>maxAngImpulse</span> <span class='argtype'>(number, optional)</span> &ndash; Maximum angular impulse (default: infinite)<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>This is the angular counterpart to ConstrainPosition, a helper function that uses
ConstrainAngularVelocity to constrain the orientation of one body to the orientation
on another body while not affecting the bodies more than the provided maximum relative
angular velocity and maximum angular impulse. In other words: physically rotate the
bodies so that quatA and quatB are aligned in world space. This is useful for 
physically animating objects. This function should only be used from the update callback.
<p>
</p>
<pre class='example'>
local handleA = 0
local handleB = 0
function init()
	handleA = FindBody("body", true)
	handleB = FindBody("target", true)
end

function update()
	--Constrain the orietation of body a to an upright orientation in the world
	ConstrainOrientation(handleA, 0, GetBodyTransform(handleA).rot, Quat())

	--Constrain the orientation of body a to the orientation of body b
	ConstrainOrientation(handleA, handleB, GetBodyTransform(handleA).rot, GetBodyTransform(handleB).rot)
end

</pre>
<hr/>
<a name='GetWorldBody'></a><h3 class='function'>GetWorldBody</h3>
<pre class='funcdef'><span class='retname'>body = </span>GetWorldBody(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>body</span> <span class='argtype'>(number)</span> &ndash; Handle to the static world body<br/>
<p>Every scene in Teardown has an implicit static world body that contains all shapes that are not explicitly assigned a body in the editor.
<p>
</p>
<pre class='example'>
local handle
function init()
	handle = GetWorldBody()
end

function tick()
	DebugCross(GetBodyTransform(handle).pos)
end

</pre>
<hr/>
<a name='FindShape'></a><h3 class='function'>FindShape</h3>
<pre class='funcdef'><span class='retname'>handle = </span>FindShape(<span class='argname'>[tag], [global]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>tag</span> <span class='argtype'>(string, optional)</span> &ndash; Tag name<br/>
<span class='argname'>global</span> <span class='argtype'>(boolean, optional)</span> &ndash; Search in entire scene<br/>
<p>Return value<br/>
<span class='retname'>handle</span> <span class='argtype'>(number)</span> &ndash; Handle to first shape with specified tag or zero if not found<br/>
<p><p>
</p>
<pre class='example'>
local target = 0
local escape = 0
function init()
	--Search for a shape tagged "mybox" in script scope
	target = FindShape("mybox")

	--Search for a shape tagged "laserturret" in entire scene
	escape = FindShape("laserturret", true)
end

function tick()
	DebugCross(GetShapeWorldTransform(target).pos)
	DebugCross(GetShapeWorldTransform(escape).pos)
end

</pre>
<hr/>
<a name='FindShapes'></a><h3 class='function'>FindShapes</h3>
<pre class='funcdef'><span class='retname'>list = </span>FindShapes(<span class='argname'>[tag], [global]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>tag</span> <span class='argtype'>(string, optional)</span> &ndash; Tag name<br/>
<span class='argname'>global</span> <span class='argtype'>(boolean, optional)</span> &ndash; Search in entire scene<br/>
<p>Return value<br/>
<span class='retname'>list</span> <span class='argtype'>(table)</span> &ndash; Indexed table with handles to all shapes with specified tag<br/>
<p><p>
</p>
<pre class='example'>
local shapes = {}
function init()
	--Search for shapes tagged "body"
	shapes = FindShapes("body", true)
end

function tick()
	for i=1, #shapes do
		local shape = shapes[i]
		DebugCross(GetShapeWorldTransform(shape).pos)
	end
end

</pre>
<hr/>
<a name='GetShapeLocalTransform'></a><h3 class='function'>GetShapeLocalTransform</h3>
<pre class='funcdef'><span class='retname'>transform = </span>GetShapeLocalTransform(<span class='argname'>handle</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Shape handle<br/>
<p>Return value<br/>
<span class='retname'>transform</span> <span class='argtype'>(TTransform)</span> &ndash; Return shape transform in body space<br/>
<p><p>
</p>
<pre class='example'>
local shape = 0
function init()
	shape = FindShape("shape")
end

function tick()
	--Shape transform in body local space
	local shapeTransform = GetShapeLocalTransform(shape)

	--Body transform in world space
	local bodyTransform = GetBodyTransform(GetShapeBody(shape))

	--Shape transform in world space
	local worldTranform = TransformToParentTransform(bodyTransform, shapeTransform)

	DebugCross(worldTranform)
end

</pre>
<hr/>
<a name='SetShapeLocalTransform'></a><h3 class='function'>SetShapeLocalTransform</h3>
<pre class='funcdef'><span class='retname'></span>SetShapeLocalTransform(<span class='argname'>handle, transform</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Shape handle<br/>
<span class='argname'>transform</span> <span class='argtype'>(TTransform)</span> &ndash; Shape transform in body space<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p><p>
</p>
<pre class='example'>
local shape = 0
function init()
	shape = FindShape("shape")
	local transform = Transform(Vec(0, 1, 0), QuatEuler(0, 90, 0))
	SetShapeLocalTransform(shape, transform)
end

function tick()
	--Shape transform in body local space
	local shapeTransform = GetShapeLocalTransform(shape)

	--Body transform in world space
	local bodyTransform = GetBodyTransform(GetShapeBody(shape))

	--Shape transform in world space
	local worldTranform = TransformToParentTransform(bodyTransform, shapeTransform)

	DebugCross(worldTranform)
end

</pre>
<hr/>
<a name='GetShapeWorldTransform'></a><h3 class='function'>GetShapeWorldTransform</h3>
<pre class='funcdef'><span class='retname'>transform = </span>GetShapeWorldTransform(<span class='argname'>handle</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Shape handle<br/>
<p>Return value<br/>
<span class='retname'>transform</span> <span class='argtype'>(TTransform)</span> &ndash; Return shape transform in world space<br/>
<p>This is a convenience function, transforming the shape out of body space
<p>
</p>
<pre class='example'>
--GetShapeWorldTransform is equivalent to
--local shapeTransform = GetShapeLocalTransform(shape)
--local bodyTransform = GetBodyTransform(GetShapeBody(shape))
--worldTranform = TransformToParentTransform(bodyTransform, shapeTransform)

local shape = 0
function init()
	shape = FindShape("shape", true)
end

function tick()
	DebugCross(GetShapeWorldTransform(shape).pos)
end

</pre>
<hr/>
<a name='GetShapeBody'></a><h3 class='function'>GetShapeBody</h3>
<pre class='funcdef'><span class='retname'>handle = </span>GetShapeBody(<span class='argname'>handle</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Shape handle<br/>
<p>Return value<br/>
<span class='retname'>handle</span> <span class='argtype'>(number)</span> &ndash; Body handle<br/>
<p>Get handle to the body this shape is owned by. A shape is always owned by a body,
but can be transfered to a new body during destruction.
<p>
</p>
<pre class='example'>
local body = 0
function init()
	body = GetShapeBody(FindShape("shape", true), true)
end

function tick()
	DebugCross(GetBodyCenterOfMass(body))
end

</pre>
<hr/>
<a name='GetShapeJoints'></a><h3 class='function'>GetShapeJoints</h3>
<pre class='funcdef'><span class='retname'>list = </span>GetShapeJoints(<span class='argname'>shape</span>)</pre>
<p>Arguments<br/>
<span class='argname'>shape</span> <span class='argtype'>(number)</span> &ndash; Shape handle<br/>
<p>Return value<br/>
<span class='retname'>list</span> <span class='argtype'>(table)</span> &ndash; Indexed table with joints connected to shape<br/>
<p><p>
</p>
<pre class='example'>
local shape = 0
function init()
	shape = FindShape("shape", true)

	local hinges = GetShapeJoints(shape)
	for i=1, #hinges do
		local joint = hinges[i]
		DebugPrint(joint)
	end
end

</pre>
<hr/>
<a name='GetShapeLights'></a><h3 class='function'>GetShapeLights</h3>
<pre class='funcdef'><span class='retname'>list = </span>GetShapeLights(<span class='argname'>shape</span>)</pre>
<p>Arguments<br/>
<span class='argname'>shape</span> <span class='argtype'>(number)</span> &ndash; Shape handle<br/>
<p>Return value<br/>
<span class='retname'>list</span> <span class='argtype'>(table)</span> &ndash; Indexed table of lights owned by shape<br/>
<p><p>
</p>
<pre class='example'>
local shape = 0
function init()
	shape = FindShape("shape", true)

	local light = GetShapeLights(shape)
	for i=1, #light do
		DebugPrint(light[i])
	end
end

</pre>
<hr/>
<a name='GetShapeBounds'></a><h3 class='function'>GetShapeBounds</h3>
<pre class='funcdef'><span class='retname'>min, max = </span>GetShapeBounds(<span class='argname'>handle</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Shape handle<br/>
<p>Return value<br/>
<span class='retname'>min</span> <span class='argtype'>(TVec)</span> &ndash; Vector representing the AABB lower bound<br/>
<span class='retname'>max</span> <span class='argtype'>(TVec)</span> &ndash; Vector representing the AABB upper bound<br/>
<p>Return the world space, axis-aligned bounding box for a shape.
<p>
</p>
<pre class='example'>
local shape = 0
function init()
	shape = FindShape("shape", true)

	local min, max = GetShapeBounds(shape)
	local boundsSize = VecSub(max, min)
	local center = VecLerp(min, max, 0.5)

	DebugPrint(VecStr(boundsSize) .. " " .. VecStr(center))
end

</pre>
<hr/>
<a name='SetShapeEmissiveScale'></a><h3 class='function'>SetShapeEmissiveScale</h3>
<pre class='funcdef'><span class='retname'></span>SetShapeEmissiveScale(<span class='argname'>handle, scale</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Shape handle<br/>
<span class='argname'>scale</span> <span class='argtype'>(number)</span> &ndash; Scale factor for emissiveness<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Scale emissiveness for shape. If the shape has light sources attached,
their intensity will be scaled by the same amount.
<p>
</p>
<pre class='example'>
local shape = 0
function init()
	shape = FindShape("shape", true)

	--Pulsate emissiveness and light intensity for shape
	local scale = math.sin(GetTime())*0.5 + 0.5
	SetShapeEmissiveScale(shape, scale)
end

</pre>
<hr/>
<a name='SetShapeDensity'></a><h3 class='function'>SetShapeDensity</h3>
<pre class='funcdef'><span class='retname'></span>SetShapeDensity(<span class='argname'>handle, density</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Shape handle<br/>
<span class='argname'>density</span> <span class='argtype'>(number)</span> &ndash; New density for the shape<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Change the material density of the shape.
<p>
</p>
<pre class='example'>
local shape = 0
function init()
	shape = FindShape("shape", true)

	local density = 10.0
	SetShapeDensity(shape, density)
end

</pre>
<hr/>
<a name='GetShapeMaterialAtPosition'></a><h3 class='function'>GetShapeMaterialAtPosition</h3>
<pre class='funcdef'><span class='retname'>type, r, g, b, a, entry = </span>GetShapeMaterialAtPosition(<span class='argname'>handle, pos, [includeUnphysical]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Shape handle<br/>
<span class='argname'>pos</span> <span class='argtype'>(TVec)</span> &ndash; Position in world space<br/>
<span class='argname'>includeUnphysical</span> <span class='argtype'>(boolean, optional)</span> &ndash; Include unphysical voxels in the search. Default false.<br/>
<p>Return value<br/>
<span class='retname'>type</span> <span class='argtype'>(string)</span> &ndash; Material type<br/>
<span class='retname'>r</span> <span class='argtype'>(number)</span> &ndash; Red<br/>
<span class='retname'>g</span> <span class='argtype'>(number)</span> &ndash; Green<br/>
<span class='retname'>b</span> <span class='argtype'>(number)</span> &ndash; Blue<br/>
<span class='retname'>a</span> <span class='argtype'>(number)</span> &ndash; Alpha<br/>
<span class='retname'>entry</span> <span class='argtype'>(number)</span> &ndash; Palette entry for voxel (zero if empty)<br/>
<p>Return material properties for a particular voxel
<p>
</p>
<pre class='example'>
local shape = 0
function init()
	shape = FindShape("shape", true)
end

function tick()
	local pos = GetCameraTransform().pos
	local dir = Vec(0, 0, 1)
	local hit, dist, normal, shape = QueryRaycast(pos, dir, 10)
	if hit then
		local hitPoint = VecAdd(pos, VecScale(dir, dist))
		local mat = GetShapeMaterialAtPosition(shape, hitPoint)
		DebugPrint("Raycast hit voxel made out of " .. mat)
	end
	DebugLine(pos, VecAdd(pos, VecScale(dir, 10)))
end

</pre>
<hr/>
<a name='GetShapeMaterialAtIndex'></a><h3 class='function'>GetShapeMaterialAtIndex</h3>
<pre class='funcdef'><span class='retname'>type, r, g, b, a, entry = </span>GetShapeMaterialAtIndex(<span class='argname'>handle, x, y, z</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Shape handle<br/>
<span class='argname'>x</span> <span class='argtype'>(number)</span> &ndash; X integer coordinate<br/>
<span class='argname'>y</span> <span class='argtype'>(number)</span> &ndash; Y integer coordinate<br/>
<span class='argname'>z</span> <span class='argtype'>(number)</span> &ndash; Z integer coordinate<br/>
<p>Return value<br/>
<span class='retname'>type</span> <span class='argtype'>(string)</span> &ndash; Material type<br/>
<span class='retname'>r</span> <span class='argtype'>(number)</span> &ndash; Red<br/>
<span class='retname'>g</span> <span class='argtype'>(number)</span> &ndash; Green<br/>
<span class='retname'>b</span> <span class='argtype'>(number)</span> &ndash; Blue<br/>
<span class='retname'>a</span> <span class='argtype'>(number)</span> &ndash; Alpha<br/>
<span class='retname'>entry</span> <span class='argtype'>(number)</span> &ndash; Palette entry for voxel (zero if empty)<br/>
<p>Return material properties for a particular voxel in the voxel grid indexed by integer values.
The first index is zero (not one, as opposed to a lot of lua related things)
<p>
</p>
<pre class='example'>
local shape = 0
function init()
	shape = FindShape("shape", true)
	local mat = GetShapeMaterialAtIndex(shape, 0, 0, 0)
	DebugPrint("The voxel is of material: " .. mat)
end

</pre>
<hr/>
<a name='GetShapeSize'></a><h3 class='function'>GetShapeSize</h3>
<pre class='funcdef'><span class='retname'>xsize, ysize, zsize, scale = </span>GetShapeSize(<span class='argname'>handle</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Shape handle<br/>
<p>Return value<br/>
<span class='retname'>xsize</span> <span class='argtype'>(number)</span> &ndash; Size in voxels along x axis<br/>
<span class='retname'>ysize</span> <span class='argtype'>(number)</span> &ndash; Size in voxels along y axis<br/>
<span class='retname'>zsize</span> <span class='argtype'>(number)</span> &ndash; Size in voxels along z axis<br/>
<span class='retname'>scale</span> <span class='argtype'>(number)</span> &ndash; The size of one voxel in meters (with default scale it is 0.1)<br/>
<p>Return the size of a shape in voxels
<p>
</p>
<pre class='example'>
local shape = 0
function init()
	shape = FindShape("shape", true)
	local x, y, z = GetShapeSize(shape)
	DebugPrint("Shape size: " .. x .. ";" .. y .. ";" .. z)
end

</pre>
<hr/>
<a name='GetShapeVoxelCount'></a><h3 class='function'>GetShapeVoxelCount</h3>
<pre class='funcdef'><span class='retname'>count = </span>GetShapeVoxelCount(<span class='argname'>handle</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Shape handle<br/>
<p>Return value<br/>
<span class='retname'>count</span> <span class='argtype'>(number)</span> &ndash; Number of voxels in shape<br/>
<p>Return the number of voxels in a shape, not including empty space
<p>
</p>
<pre class='example'>
local shape = 0
function init()
	shape = FindShape("shape", true)
	local voxelCount = GetShapeVoxelCount(shape)
	DebugPrint(voxelCount)
end

</pre>
<hr/>
<a name='IsShapeVisible'></a><h3 class='function'>IsShapeVisible</h3>
<pre class='funcdef'><span class='retname'>visible = </span>IsShapeVisible(<span class='argname'>handle, maxDist, [rejectTransparent]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Shape handle<br/>
<span class='argname'>maxDist</span> <span class='argtype'>(number)</span> &ndash; Maximum visible distance<br/>
<span class='argname'>rejectTransparent</span> <span class='argtype'>(boolean, optional)</span> &ndash; See through transparent materials. Default false.<br/>
<p>Return value<br/>
<span class='retname'>visible</span> <span class='argtype'>(boolean)</span> &ndash; Return true if shape is visible<br/>
<p>This function does a very rudimetary check and will only return true if the 
object is visible within 74 degrees of the camera's forward direction, and
only tests line-of-sight visibility for the corners and center of the bounding box.
<p>
</p>
<pre class='example'>
local shape = 0
function init()
	shape = FindShape("shape", true)
end

function tick()
	if IsShapeVisible(shape, 25) then
		DebugPrint("Shape is visible")
	else
		DebugPrint("Shape is not visible")
	end
end

</pre>
<hr/>
<a name='IsShapeBroken'></a><h3 class='function'>IsShapeBroken</h3>
<pre class='funcdef'><span class='retname'>broken = </span>IsShapeBroken(<span class='argname'>handle</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Shape handle<br/>
<p>Return value<br/>
<span class='retname'>broken</span> <span class='argtype'>(boolean)</span> &ndash; Return true if shape is broken<br/>
<p>Determine if shape has been broken. Note that a shape can be transfered
to another body during destruction, but might still not be considered
broken if all voxels are intact.
<p>
</p>
<pre class='example'>
local shape = 0
function init()
	shape = FindShape("shape", true)
end

function tick()
	DebugPrint("Is shape broken: " .. tostring(IsShapeBroken(shape)))
end

</pre>
<hr/>
<a name='DrawShapeOutline'></a><h3 class='function'>DrawShapeOutline</h3>
<pre class='funcdef'><span class='retname'></span>DrawShapeOutline(<span class='argname'>handle, [r], [g], [b], a</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Shape handle<br/>
<span class='argname'>r</span> <span class='argtype'>(number, optional)</span> &ndash; Red<br/>
<span class='argname'>g</span> <span class='argtype'>(number, optional)</span> &ndash; Green<br/>
<span class='argname'>b</span> <span class='argtype'>(number, optional)</span> &ndash; Blue<br/>
<span class='argname'>a</span> <span class='argtype'>(number)</span> &ndash; Alpha<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Render next frame with an outline around specified shape.
If no color is given, a white outline will be drawn.
<p>
</p>
<pre class='example'>
local shape = 0
function init()
	shape = FindShape("shape", true)
end

function tick()
	if InputDown("interact") then
		--Draw white outline at 50% transparency
		DrawShapeOutline(shape, 0.5)
	else
		--Draw green outline, fully opaque
		DrawShapeOutline(shape, 0, 1, 0, 1)
	end
end

</pre>
<hr/>
<a name='DrawShapeHighlight'></a><h3 class='function'>DrawShapeHighlight</h3>
<pre class='funcdef'><span class='retname'></span>DrawShapeHighlight(<span class='argname'>handle, amount</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Shape handle<br/>
<span class='argname'>amount</span> <span class='argtype'>(number)</span> &ndash; Amount<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Flash the appearance of a shape when rendering this frame.
<p>
</p>
<pre class='example'>
local shape = 0
function init()
	shape = FindShape("shape", true)
end

function tick()
	if InputDown("interact") then
		DrawShapeHighlight(shape, 0.5)
	end
end

</pre>
<hr/>
<a name='SetShapeCollisionFilter'></a><h3 class='function'>SetShapeCollisionFilter</h3>
<pre class='funcdef'><span class='retname'></span>SetShapeCollisionFilter(<span class='argname'>handle, layer, mask</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Shape handle<br/>
<span class='argname'>layer</span> <span class='argtype'>(number)</span> &ndash; Layer bits (0-255)<br/>
<span class='argname'>mask</span> <span class='argtype'>(number)</span> &ndash; Mask bits (0-255)<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>This is used to filter out collisions with other shapes. Each shape can be given a layer 
bitmask (8 bits, 0-255) along with a mask (also 8 bits). The layer of one object must be in
the mask of the other object and vice versa for the collision to be valid. The default layer
for all objects is 1 and the default mask is 255 (collide with all layers).
<p>
</p>
<pre class='example'>
local shapeA = 0
local shapeB = 0
local shapeC = 0
local shapeD = 0
function init()
	shapeA = FindShape("shapeA")
	shapeB = FindShape("shapeB")
	shapeC = FindShape("shapeC")
	shapeD = FindShape("shapeD")
	--This will put shapes a and b in layer 2 and disable collisions with
	--object shapes in layers 2, preventing any collisions between the two.
	SetShapeCollisionFilter(shapeA, 2, 255-2)
	SetShapeCollisionFilter(shapeB, 2, 255-2)

	--This will put shapes c and d in layer 4 and allow collisions with other
	--shapes in layer 4, but ignore all other collisions with the rest of the world.
	SetShapeCollisionFilter(shapeC, 4, 4)
	SetShapeCollisionFilter(shapeD, 4, 4)
end

</pre>
<hr/>
<a name='GetShapeCollisionFilter'></a><h3 class='function'>GetShapeCollisionFilter</h3>
<pre class='funcdef'><span class='retname'>layer, mask = </span>GetShapeCollisionFilter(<span class='argname'>handle</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Shape handle<br/>
<p>Return value<br/>
<span class='retname'>layer</span> <span class='argtype'>(number)</span> &ndash; Layer bits (0-255)<br/>
<span class='retname'>mask</span> <span class='argtype'>(number)</span> &ndash; Mask bits (0-255)<br/>
<p>Returns the current layer/mask settings of the shape
<p>
</p>
<pre class='example'>
function init()
	local shape = FindShape("some_shape")
	local layer, mask = GetShapeCollisionFilter(shape)
end

</pre>
<hr/>
<a name='CreateShape'></a><h3 class='function'>CreateShape</h3>
<pre class='funcdef'><span class='retname'>newShape = </span>CreateShape(<span class='argname'>body, transform, refShape</span>)</pre>
<p>Arguments<br/>
<span class='argname'>body</span> <span class='argtype'>(number)</span> &ndash; Body handle<br/>
<span class='argname'>transform</span> <span class='argtype'>(TTransform)</span> &ndash; Shape transform in body space<br/>
<span class='argname'>refShape</span> <span class='argtype'>(number)</span> &ndash; Handle to reference shape or path to vox file<br/>
<p>Return value<br/>
<span class='retname'>newShape</span> <span class='argtype'>(number)</span> &ndash; Handle of new shape<br/>
<p>Create new, empty shape on existing body using the palette of a reference shape.
The reference shape can be any existing shape in the scene or an external vox file.
The size of the new shape will be 1x1x1.
<p>
</p>
<pre class='example'>
function tick()
	if InputPressed("interact") then
		local t = Transform(Vec(0, 5, 0), QuatEuler(0, 0, 0))
		local handle = CreateShape(FindBody("shape", true), t, FindShape("shape", true))
		DebugPrint(handle)
	end
end

</pre>
<hr/>
<a name='ClearShape'></a><h3 class='function'>ClearShape</h3>
<pre class='funcdef'><span class='retname'></span>ClearShape(<span class='argname'>shape</span>)</pre>
<p>Arguments<br/>
<span class='argname'>shape</span> <span class='argtype'>(number)</span> &ndash; Shape handle<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Fill a voxel shape with zeroes, thus removing all voxels.
<p>
</p>
<pre class='example'>
function init()
	ClearShape(FindShape("shape", true))
end

</pre>
<hr/>
<a name='ResizeShape'></a><h3 class='function'>ResizeShape</h3>
<pre class='funcdef'><span class='retname'>resized, offset = </span>ResizeShape(<span class='argname'>shape, xmi, ymi, zmi, xma, yma, zma</span>)</pre>
<p>Arguments<br/>
<span class='argname'>shape</span> <span class='argtype'>(number)</span> &ndash; Shape handle<br/>
<span class='argname'>xmi</span> <span class='argtype'>(number)</span> &ndash; Lower X coordinate<br/>
<span class='argname'>ymi</span> <span class='argtype'>(number)</span> &ndash; Lower Y coordinate<br/>
<span class='argname'>zmi</span> <span class='argtype'>(number)</span> &ndash; Lower Z coordinate<br/>
<span class='argname'>xma</span> <span class='argtype'>(number)</span> &ndash; Upper X coordinate<br/>
<span class='argname'>yma</span> <span class='argtype'>(number)</span> &ndash; Upper Y coordinate<br/>
<span class='argname'>zma</span> <span class='argtype'>(number)</span> &ndash; Upper Z coordinate<br/>
<p>Return value<br/>
<span class='retname'>resized</span> <span class='argtype'>(boolean)</span> &ndash; Resized successfully<br/>
<span class='retname'>offset</span> <span class='argtype'>(TVec)</span> &ndash; Offset vector in shape local space<br/>
<p>Resize an existing shape. The new coordinates are expressed in the existing shape coordinate frame,
so you can provide negative values. The existing content is preserved, but may be cropped if needed.
The local shape transform will be moved automatically with an offset vector to preserve the original content in body space.
This offset vector is returned in shape local space.
<p>
</p>
<pre class='example'>
function init()
	ResizeShape(FindShape("shape", true), -5, 0, -5, 5, 5, 5)
end

</pre>
<hr/>
<a name='SetShapeBody'></a><h3 class='function'>SetShapeBody</h3>
<pre class='funcdef'><span class='retname'></span>SetShapeBody(<span class='argname'>shape, body, [transform]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>shape</span> <span class='argtype'>(number)</span> &ndash; Shape handle<br/>
<span class='argname'>body</span> <span class='argtype'>(number)</span> &ndash; Body handle<br/>
<span class='argname'>transform</span> <span class='argtype'>(TTransform, optional)</span> &ndash; New local shape transform. Default is existing local transform.<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Move existing shape to a new body, optionally providing a new local transform.
<p>
</p>
<pre class='example'>
function init()
	SetShapeBody(FindShape("shape", true), FindBody("custombody", true), true)
end

</pre>
<hr/>
<a name='CopyShapeContent'></a><h3 class='function'>CopyShapeContent</h3>
<pre class='funcdef'><span class='retname'></span>CopyShapeContent(<span class='argname'>src, dst</span>)</pre>
<p>Arguments<br/>
<span class='argname'>src</span> <span class='argtype'>(number)</span> &ndash; Source shape handle<br/>
<span class='argname'>dst</span> <span class='argtype'>(number)</span> &ndash; Destination shape handle<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Copy voxel content from source shape to destination shape. If destination
shape has a different size, it will be resized to match the source shape.
<p>
</p>
<pre class='example'>
function init()
	CopyShapeContent(FindShape("shape", true), FindShape("shape2", true))
end

</pre>
<hr/>
<a name='CopyShapePalette'></a><h3 class='function'>CopyShapePalette</h3>
<pre class='funcdef'><span class='retname'></span>CopyShapePalette(<span class='argname'>src, dst</span>)</pre>
<p>Arguments<br/>
<span class='argname'>src</span> <span class='argtype'>(number)</span> &ndash; Source shape handle<br/>
<span class='argname'>dst</span> <span class='argtype'>(number)</span> &ndash; Destination shape handle<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Copy the palette from source shape to destination shape.
<p>
</p>
<pre class='example'>
function init()
	CopyShapePalette(FindShape("shape", true), FindShape("shape2", true))
end

</pre>
<hr/>
<a name='GetShapePalette'></a><h3 class='function'>GetShapePalette</h3>
<pre class='funcdef'><span class='retname'>entries = </span>GetShapePalette(<span class='argname'>shape</span>)</pre>
<p>Arguments<br/>
<span class='argname'>shape</span> <span class='argtype'>(number)</span> &ndash; Shape handle<br/>
<p>Return value<br/>
<span class='retname'>entries</span> <span class='argtype'>(table)</span> &ndash; Palette material entries<br/>
<p>Return list of material entries, each entry is a material index that
can be provided to GetShapeMaterial or used as brush for populating a
shape.
<p>
</p>
<pre class='example'>
function init()
	local palette = GetShapePalette(FindShape("shape2", true))
	for i = 1, #palette do
		DebugPrint(palette[i])
	end
end

</pre>
<hr/>
<a name='GetShapeMaterial'></a><h3 class='function'>GetShapeMaterial</h3>
<pre class='funcdef'><span class='retname'>type, red, green, blue, alpha, reflectivity, shininess, metallic, emissive = </span>GetShapeMaterial(<span class='argname'>shape, entry</span>)</pre>
<p>Arguments<br/>
<span class='argname'>shape</span> <span class='argtype'>(number)</span> &ndash; Shape handle<br/>
<span class='argname'>entry</span> <span class='argtype'>(number)</span> &ndash; Material entry<br/>
<p>Return value<br/>
<span class='retname'>type</span> <span class='argtype'>(string)</span> &ndash; Type<br/>
<span class='retname'>red</span> <span class='argtype'>(number)</span> &ndash; Red value<br/>
<span class='retname'>green</span> <span class='argtype'>(number)</span> &ndash; Green value<br/>
<span class='retname'>blue</span> <span class='argtype'>(number)</span> &ndash; Blue value<br/>
<span class='retname'>alpha</span> <span class='argtype'>(number)</span> &ndash; Alpha value<br/>
<span class='retname'>reflectivity</span> <span class='argtype'>(number)</span> &ndash; Range 0 to 1<br/>
<span class='retname'>shininess</span> <span class='argtype'>(number)</span> &ndash; Range 0 to 1<br/>
<span class='retname'>metallic</span> <span class='argtype'>(number)</span> &ndash; Range 0 to 1<br/>
<span class='retname'>emissive</span> <span class='argtype'>(number)</span> &ndash; Range 0 to 32<br/>
<p>Return material properties for specific matirial entry.
<p>
</p>
<pre class='example'>
function init()
	local type, r, g, b, a, reflectivity, shininess, metallic, emissive = GetShapeMaterial(FindShape("shape2", true), 1)
	DebugPrint(type)
end

</pre>
<hr/>
<a name='SetBrush'></a><h3 class='function'>SetBrush</h3>
<pre class='funcdef'><span class='retname'></span>SetBrush(<span class='argname'>type, size, index, [object]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>type</span> <span class='argtype'>(string)</span> &ndash; One of "sphere", "cube" or "noise"<br/>
<span class='argname'>size</span> <span class='argtype'>(number)</span> &ndash; Size of brush in voxels (must be in range 1 to 16)<br/>
<span class='argname'>index</span> <span class='argtype'>(or)</span> &ndash; Material index or path to brush vox file<br/>
<span class='argname'>object</span> <span class='argtype'>(string, optional)</span> &ndash; Optional object in brush vox file if brush vox file is used<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Set material index to be used for following calls to DrawShapeLine and DrawShapeBox and ExtrudeShape.
An optional brush vox file and subobject can be used and provided instead of material index,
in which case the content of the brush will be used and repeated. Use material index zero 
to remove of voxels.
<p>
</p>
<pre class='example'>
function init()
	SetBrush("sphere", 3, 3)
end

</pre>
<hr/>
<a name='DrawShapeLine'></a><h3 class='function'>DrawShapeLine</h3>
<pre class='funcdef'><span class='retname'></span>DrawShapeLine(<span class='argname'>shape, x0, y0, z0, x1, y1, z1, [paint], [noOverwrite]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>shape</span> <span class='argtype'>(number)</span> &ndash; Handle to shape<br/>
<span class='argname'>x0</span> <span class='argtype'>(number)</span> &ndash; Start X coordinate<br/>
<span class='argname'>y0</span> <span class='argtype'>(number)</span> &ndash; Start Y coordinate<br/>
<span class='argname'>z0</span> <span class='argtype'>(number)</span> &ndash; Start Z coordinate<br/>
<span class='argname'>x1</span> <span class='argtype'>(number)</span> &ndash; End X coordinate<br/>
<span class='argname'>y1</span> <span class='argtype'>(number)</span> &ndash; End Y coordinate<br/>
<span class='argname'>z1</span> <span class='argtype'>(number)</span> &ndash; End Z coordinate<br/>
<span class='argname'>paint</span> <span class='argtype'>(boolean, optional)</span> &ndash; Paint mode. Default is false.<br/>
<span class='argname'>noOverwrite</span> <span class='argtype'>(boolean, optional)</span> &ndash; Only fill in voxels if space isn't already occupied. Default is false.<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Draw voxelized line between (x0,y0,z0) and (x1,y1,z1) into shape using the material 
set up with SetBrush. Paint mode will only change material of existing voxels (where
the current material index is non-zero). noOverwrite mode will only fill in voxels if the
space isn't already accupied by another shape in the scene.
<p>
</p>
<pre class='example'>
function init()
	SetBrush("sphere", 3, 1)
	DrawShapeLine(FindShape("shape"), 0, 0, 0, 10, 50, 5, false, true)
end

</pre>
<hr/>
<a name='DrawShapeBox'></a><h3 class='function'>DrawShapeBox</h3>
<pre class='funcdef'><span class='retname'></span>DrawShapeBox(<span class='argname'>shape, x0, y0, z0, x1, y1, z1</span>)</pre>
<p>Arguments<br/>
<span class='argname'>shape</span> <span class='argtype'>(number)</span> &ndash; Handle to shape<br/>
<span class='argname'>x0</span> <span class='argtype'>(number)</span> &ndash; Start X coordinate<br/>
<span class='argname'>y0</span> <span class='argtype'>(number)</span> &ndash; Start Y coordinate<br/>
<span class='argname'>z0</span> <span class='argtype'>(number)</span> &ndash; Start Z coordinate<br/>
<span class='argname'>x1</span> <span class='argtype'>(number)</span> &ndash; End X coordinate<br/>
<span class='argname'>y1</span> <span class='argtype'>(number)</span> &ndash; End Y coordinate<br/>
<span class='argname'>z1</span> <span class='argtype'>(number)</span> &ndash; End Z coordinate<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Draw box between (x0,y0,z0) and (x1,y1,z1) into shape using the material
set up with SetBrush.
<p>
</p>
<pre class='example'>
function init()
	SetBrush("sphere", 3, 4)
	DrawShapeBox(FindShape("shape", true), 0, 0, 0, 10, 50, 5)
end

</pre>
<hr/>
<a name='ExtrudeShape'></a><h3 class='function'>ExtrudeShape</h3>
<pre class='funcdef'><span class='retname'></span>ExtrudeShape(<span class='argname'>shape, x, y, z, dx, dy, dz, steps, mode</span>)</pre>
<p>Arguments<br/>
<span class='argname'>shape</span> <span class='argtype'>(number)</span> &ndash; Handle to shape<br/>
<span class='argname'>x</span> <span class='argtype'>(number)</span> &ndash; X coordinate to extrude<br/>
<span class='argname'>y</span> <span class='argtype'>(number)</span> &ndash; Y coordinate to extrude<br/>
<span class='argname'>z</span> <span class='argtype'>(number)</span> &ndash; Z coordinate to extrude<br/>
<span class='argname'>dx</span> <span class='argtype'>(number)</span> &ndash; X component of extrude direction, should be -1, 0 or 1<br/>
<span class='argname'>dy</span> <span class='argtype'>(number)</span> &ndash; Y component of extrude direction, should be -1, 0 or 1<br/>
<span class='argname'>dz</span> <span class='argtype'>(number)</span> &ndash; Z component of extrude direction, should be -1, 0 or 1<br/>
<span class='argname'>steps</span> <span class='argtype'>(number)</span> &ndash; Length of extrusion in voxels<br/>
<span class='argname'>mode</span> <span class='argtype'>(string)</span> &ndash; Extrusion mode, one of "exact", "material", "geometry". Default is "exact"<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Extrude region of shape. The extruded region will be filled in with the material set up with SetBrush.
The mode parameter sepcifies how the region is determined.
Exact mode selects region of voxels that exactly match the input voxel at input coordinate.
Material mode selects region that has the same material type as the input voxel.
Geometry mode selects any connected voxel in the same plane as the input voxel.
<p>
</p>
<pre class='example'>
local shape = 0
function init()
	SetBrush("sphere", 3, 4)
	shape = FindShape("shape")
	ExtrudeShape(shape, 0, 5, 0, -1, 0, 0, 50, "exact")
end

</pre>
<hr/>
<a name='TrimShape'></a><h3 class='function'>TrimShape</h3>
<pre class='funcdef'><span class='retname'>offset = </span>TrimShape(<span class='argname'>shape</span>)</pre>
<p>Arguments<br/>
<span class='argname'>shape</span> <span class='argtype'>(number)</span> &ndash; Source handle<br/>
<p>Return value<br/>
<span class='retname'>offset</span> <span class='argtype'>(TVec)</span> &ndash; Offset vector in shape local space<br/>
<p>Trim away empty regions of shape, thus potentially making it smaller.
If the size of the shape changes, the shape will be automatically moved
to preserve the shape content in body space. The offset vector for this 
translation is returned in shape local space.
<p>
</p>
<pre class='example'>
local shape = 0
function init()
	shape = FindShape("shape", true)
	TrimShape(shape)
end

</pre>
<hr/>
<a name='SplitShape'></a><h3 class='function'>SplitShape</h3>
<pre class='funcdef'><span class='retname'>newShapes = </span>SplitShape(<span class='argname'>shape, removeResidual</span>)</pre>
<p>Arguments<br/>
<span class='argname'>shape</span> <span class='argtype'>(number)</span> &ndash; Source handle<br/>
<span class='argname'>removeResidual</span> <span class='argtype'>(boolean)</span> &ndash; Remove residual shapes (default false)<br/>
<p>Return value<br/>
<span class='retname'>newShapes</span> <span class='argtype'>(table)</span> &ndash; List of shape handles created<br/>
<p>Split up a shape into multiple shapes based on connectivity. If the removeResidual flag
is used, small disconnected chunks will be removed during this process to reduce the number
of newly created shapes.
<p>
</p>
<pre class='example'>
local shape = 0
function init()
	shape = FindShape("shape", true)
	SplitShape(shape, true)
end

</pre>
<hr/>
<a name='MergeShape'></a><h3 class='function'>MergeShape</h3>
<pre class='funcdef'><span class='retname'>shape = </span>MergeShape(<span class='argname'>shape</span>)</pre>
<p>Arguments<br/>
<span class='argname'>shape</span> <span class='argtype'>(number)</span> &ndash; Input shape<br/>
<p>Return value<br/>
<span class='retname'>shape</span> <span class='argtype'>(number)</span> &ndash; Shape handle after merge<br/>
<p>Try to merge shape with a nearby, matching shape. For a merge to happen, the
shapes need to be aligned to the same rotation and touching. If the
provided shape was merged into another shape, that shape may be resized to
fit the merged content. If shape was merged, the handle to the other shape is
returned, otherwise the input handle is returned.
<p>
</p>
<pre class='example'>
local shape = 0
function init()
	shape = FindShape("shape", true)
	DebugPrint(shape)
	shape = MergeShape(shape)
	DebugPrint(shape)
end

</pre>
<hr/>
<a name='IsShapeDisconnected'></a><h3 class='function'>IsShapeDisconnected</h3>
<pre class='funcdef'><span class='retname'>disconnected = </span>IsShapeDisconnected(<span class='argname'>shape</span>)</pre>
<p>Arguments<br/>
<span class='argname'>shape</span> <span class='argtype'>(number)</span> &ndash; Input shape<br/>
<p>Return value<br/>
<span class='retname'>disconnected</span> <span class='argtype'>(boolean)</span> &ndash; True if shape disconnected (has detached parts)<br/>
<p><p>
</p>
<pre class='example'>
function tick()
	DebugWatch("IsShapeDisconnected", IsShapeDisconnected(FindShape("shape", true)))
end

</pre>
<hr/>
<a name='IsStaticShapeDetached'></a><h3 class='function'>IsStaticShapeDetached</h3>
<pre class='funcdef'><span class='retname'>disconnected = </span>IsStaticShapeDetached(<span class='argname'>shape</span>)</pre>
<p>Arguments<br/>
<span class='argname'>shape</span> <span class='argtype'>(number)</span> &ndash; Input shape<br/>
<p>Return value<br/>
<span class='retname'>disconnected</span> <span class='argtype'>(boolean)</span> &ndash; True if static shape has detached parts<br/>
<p><p>
</p>
<pre class='example'>
function tick()
	DebugWatch("IsStaticShapeDetached", IsStaticShapeDetached(FindShape("shape_glass", true)))
end

</pre>
<hr/>
<a name='GetShapeClosestPoint'></a><h3 class='function'>GetShapeClosestPoint</h3>
<pre class='funcdef'><span class='retname'>hit, point, normal = </span>GetShapeClosestPoint(<span class='argname'>shape, origin</span>)</pre>
<p>Arguments<br/>
<span class='argname'>shape</span> <span class='argtype'>(number)</span> &ndash; Shape handle<br/>
<span class='argname'>origin</span> <span class='argtype'>(TVec)</span> &ndash; World space point<br/>
<p>Return value<br/>
<span class='retname'>hit</span> <span class='argtype'>(boolean)</span> &ndash; True if a point was found<br/>
<span class='retname'>point</span> <span class='argtype'>(TVec)</span> &ndash; World space closest point<br/>
<span class='retname'>normal</span> <span class='argtype'>(TVec)</span> &ndash; World space normal at closest point<br/>
<p>This will return the closest point of a specific shape
<p>
</p>
<pre class='example'>
local shape = 0
function init()
	shape = FindShape("shape", true)
end

function tick()
	DebugCross(Vec(1, 0, 0))
	local hit, p, n, s = GetShapeClosestPoint(shape, Vec(1, 0, 0))
	if hit then
		DebugCross(p)
	end
end

</pre>
<hr/>
<a name='IsShapeTouching'></a><h3 class='function'>IsShapeTouching</h3>
<pre class='funcdef'><span class='retname'>touching = </span>IsShapeTouching(<span class='argname'>a, b</span>)</pre>
<p>Arguments<br/>
<span class='argname'>a</span> <span class='argtype'>(number)</span> &ndash; Handle to first shape<br/>
<span class='argname'>b</span> <span class='argtype'>(number)</span> &ndash; Handle to second shape<br/>
<p>Return value<br/>
<span class='retname'>touching</span> <span class='argtype'>(boolean)</span> &ndash; True is shapes a and b are touching each other<br/>
<p>This will check if two shapes has physical overlap
<p>
</p>
<pre class='example'>
local shapeA = 0
local shapeB = 0
function init()
	shapeA = FindShape("shape")
	shapeB = FindShape("shape2")
end

function tick()
	DebugPrint(IsShapeTouching(shapeA, shapeB))
end

</pre>
<hr/>
<a name='FindLocation'></a><h3 class='function'>FindLocation</h3>
<pre class='funcdef'><span class='retname'>handle = </span>FindLocation(<span class='argname'>[tag], [global]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>tag</span> <span class='argtype'>(string, optional)</span> &ndash; Tag name<br/>
<span class='argname'>global</span> <span class='argtype'>(boolean, optional)</span> &ndash; Search in entire scene<br/>
<p>Return value<br/>
<span class='retname'>handle</span> <span class='argtype'>(number)</span> &ndash; Handle to first location with specified tag or zero if not found<br/>
<p><p>
</p>
<pre class='example'>
local loc = 0
function init()
	loc = FindLocation("loc1")
end

function tick()
	DebugCross(GetLocationTransform(loc).pos)
end

</pre>
<hr/>
<a name='FindLocations'></a><h3 class='function'>FindLocations</h3>
<pre class='funcdef'><span class='retname'>list = </span>FindLocations(<span class='argname'>[tag], [global]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>tag</span> <span class='argtype'>(string, optional)</span> &ndash; Tag name<br/>
<span class='argname'>global</span> <span class='argtype'>(boolean, optional)</span> &ndash; Search in entire scene<br/>
<p>Return value<br/>
<span class='retname'>list</span> <span class='argtype'>(table)</span> &ndash; Indexed table with handles to all locations with specified tag<br/>
<p><p>
</p>
<pre class='example'>
local locations
function init()
	locations = FindLocations("loc1")

	for i=1, #locations do
		local loc = locations[i]
		DebugPrint(DebugPrint(loc))
	end
end

</pre>
<hr/>
<a name='GetLocationTransform'></a><h3 class='function'>GetLocationTransform</h3>
<pre class='funcdef'><span class='retname'>transform = </span>GetLocationTransform(<span class='argname'>handle</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Location handle<br/>
<p>Return value<br/>
<span class='retname'>transform</span> <span class='argtype'>(TTransform)</span> &ndash; Transform of the location<br/>
<p><p>
</p>
<pre class='example'>
local location = 0
function init()
	location = FindLocation("loc1")
	DebugPrint(VecStr(GetLocationTransform(location).pos))
end

</pre>
<hr/>
<a name='FindJoint'></a><h3 class='function'>FindJoint</h3>
<pre class='funcdef'><span class='retname'>handle = </span>FindJoint(<span class='argname'>[tag], [global]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>tag</span> <span class='argtype'>(string, optional)</span> &ndash; Tag name<br/>
<span class='argname'>global</span> <span class='argtype'>(boolean, optional)</span> &ndash; Search in entire scene<br/>
<p>Return value<br/>
<span class='retname'>handle</span> <span class='argtype'>(number)</span> &ndash; Handle to first joint with specified tag or zero if not found<br/>
<p><p>
</p>
<pre class='example'>
function init()
	local joint = FindJoint("doorhinge")
	DebugPrint(joint)
end

</pre>
<hr/>
<a name='FindJoints'></a><h3 class='function'>FindJoints</h3>
<pre class='funcdef'><span class='retname'>list = </span>FindJoints(<span class='argname'>[tag], [global]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>tag</span> <span class='argtype'>(string, optional)</span> &ndash; Tag name<br/>
<span class='argname'>global</span> <span class='argtype'>(boolean, optional)</span> &ndash; Search in entire scene<br/>
<p>Return value<br/>
<span class='retname'>list</span> <span class='argtype'>(table)</span> &ndash; Indexed table with handles to all joints with specified tag<br/>
<p><p>
</p>
<pre class='example'>
--Search for locations tagged "doorhinge" in script scope
function init()
	local hinges = FindJoints("doorhinge")
	for i=1, #hinges do
		local joint = hinges[i]
		DebugPrint(joint)
	end
end

</pre>
<hr/>
<a name='IsJointBroken'></a><h3 class='function'>IsJointBroken</h3>
<pre class='funcdef'><span class='retname'>broken = </span>IsJointBroken(<span class='argname'>joint</span>)</pre>
<p>Arguments<br/>
<span class='argname'>joint</span> <span class='argtype'>(number)</span> &ndash; Joint handle<br/>
<p>Return value<br/>
<span class='retname'>broken</span> <span class='argtype'>(boolean)</span> &ndash; True if joint is broken<br/>
<p><p>
</p>
<pre class='example'>
function init()
	local broken = IsJointBroken(FindJoint("joint"))
	DebugPrint(broken)
end

</pre>
<hr/>
<a name='GetJointType'></a><h3 class='function'>GetJointType</h3>
<pre class='funcdef'><span class='retname'>type = </span>GetJointType(<span class='argname'>joint</span>)</pre>
<p>Arguments<br/>
<span class='argname'>joint</span> <span class='argtype'>(number)</span> &ndash; Joint handle<br/>
<p>Return value<br/>
<span class='retname'>type</span> <span class='argtype'>(string)</span> &ndash; Joint type<br/>
<p>Joint type is one of the following: "ball", "hinge", "prismatic" or "rope".
An empty string is returned if joint handle is invalid.
<p>
</p>
<pre class='example'>
function init()
	local joint = FindJoint("joint")
	if GetJointType(joint) == "rope" then
		DebugPrint("Joint is rope")
	end
end

</pre>
<hr/>
<a name='GetJointOtherShape'></a><h3 class='function'>GetJointOtherShape</h3>
<pre class='funcdef'><span class='retname'>other = </span>GetJointOtherShape(<span class='argname'>joint, shape</span>)</pre>
<p>Arguments<br/>
<span class='argname'>joint</span> <span class='argtype'>(number)</span> &ndash; Joint handle<br/>
<span class='argname'>shape</span> <span class='argtype'>(number)</span> &ndash; Shape handle<br/>
<p>Return value<br/>
<span class='retname'>other</span> <span class='argtype'>(number)</span> &ndash; Other shape handle<br/>
<p>A joint is always connected to two shapes. Use this function if you know 
one shape and want to find the other one.
<p>
</p>
<pre class='example'>
function init()
	local joint = FindJoint("joint")
	--joint is connected to A and B

	otherShape = GetJointOtherShape(joint, FindShape("shapeA"))
	--otherShape is now B

	otherShape = GetJointOtherShape(joint, FindShape("shapeB"))
	--otherShape is now A
end

</pre>
<hr/>
<a name='GetJointShapes'></a><h3 class='function'>GetJointShapes</h3>
<pre class='funcdef'><span class='retname'>shapes = </span>GetJointShapes(<span class='argname'>joint</span>)</pre>
<p>Arguments<br/>
<span class='argname'>joint</span> <span class='argtype'>(number)</span> &ndash; Joint handle<br/>
<p>Return value<br/>
<span class='retname'>shapes</span> <span class='argtype'>(number)</span> &ndash; Shape handles<br/>
<p><p>
Get shapes connected to the joint.
<p>
<p>
</p>
<pre class='example'>
local mainBody
local shapes
local joint
function init()
	joint = FindJoint("joint")
	mainBody = GetVehicleBody(FindVehicle("vehicle"))
	shapes = GetJointShapes(joint)
end

function tick()
	-- Check to see if joint chain is still connected to vehicle main body
	-- If not then disable motors

	local connected = false
	for i=1,#shapes do
	
		local body = GetShapeBody(shapes[i])
	
		if body == mainBody then
			connected = true
		end
	
	end
	
	if connected then
		SetJointMotor(joint, 0.5)
	else
		SetJointMotor(joint, 0.0)
	end
end

</pre>
<hr/>
<a name='SetJointMotor'></a><h3 class='function'>SetJointMotor</h3>
<pre class='funcdef'><span class='retname'></span>SetJointMotor(<span class='argname'>joint, velocity, [strength]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>joint</span> <span class='argtype'>(number)</span> &ndash; Joint handle<br/>
<span class='argname'>velocity</span> <span class='argtype'>(number)</span> &ndash; Desired velocity<br/>
<span class='argname'>strength</span> <span class='argtype'>(number, optional)</span> &ndash; Desired strength. Default is infinite. Zero to disable.<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Set joint motor target velocity. If joint is of type hinge, velocity is
given in radians per second angular velocity. If joint type is prismatic joint
velocity is given in meters per second. Calling this function will override and
void any previous call to SetJointMotorTarget.
<p>
</p>
<pre class='example'>
function init()
	--Set motor speed to 0.5 radians per second
	SetJointMotor(FindJoint("hinge"), 0.5)
end

</pre>
<hr/>
<a name='SetJointMotorTarget'></a><h3 class='function'>SetJointMotorTarget</h3>
<pre class='funcdef'><span class='retname'></span>SetJointMotorTarget(<span class='argname'>joint, target, [maxVel], [strength]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>joint</span> <span class='argtype'>(number)</span> &ndash; Joint handle<br/>
<span class='argname'>target</span> <span class='argtype'>(number)</span> &ndash; Desired movement target<br/>
<span class='argname'>maxVel</span> <span class='argtype'>(number, optional)</span> &ndash; Maximum velocity to reach target. Default is infinite.<br/>
<span class='argname'>strength</span> <span class='argtype'>(number, optional)</span> &ndash; Desired strength. Default is infinite. Zero to disable.<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>If a joint has a motor target, it will try to maintain its relative movement. This
is very useful for elevators or other animated, jointed mechanisms.
If joint is of type hinge, target is an angle in degrees (-180 to 180) and velocity
is given in radians per second. If joint type is prismatic, target is given
in meters and velocity is given in meters per second. Setting a motor target will
override any previous call to SetJointMotor.
<p>
</p>
<pre class='example'>
function init()
	--Make joint reach a 45 degree angle, going at a maximum of 3 radians per second
	SetJointMotorTarget(FindJoint("hinge"), 45, 3)
end

</pre>
<hr/>
<a name='GetJointLimits'></a><h3 class='function'>GetJointLimits</h3>
<pre class='funcdef'><span class='retname'>min, max = </span>GetJointLimits(<span class='argname'>joint</span>)</pre>
<p>Arguments<br/>
<span class='argname'>joint</span> <span class='argtype'>(number)</span> &ndash; Joint handle<br/>
<p>Return value<br/>
<span class='retname'>min</span> <span class='argtype'>(number)</span> &ndash; Minimum joint limit (angle or distance)<br/>
<span class='retname'>max</span> <span class='argtype'>(number)</span> &ndash; Maximum joint limit (angle or distance)<br/>
<p>Return joint limits for hinge or prismatic joint. Returns angle or distance
depending on joint type.
<p>
</p>
<pre class='example'>
function init()
	local min, max = GetJointLimits(FindJoint("hinge"))
	DebugPrint(min .. "-" .. max)
end

</pre>
<hr/>
<a name='GetJointMovement'></a><h3 class='function'>GetJointMovement</h3>
<pre class='funcdef'><span class='retname'>movement = </span>GetJointMovement(<span class='argname'>joint</span>)</pre>
<p>Arguments<br/>
<span class='argname'>joint</span> <span class='argtype'>(number)</span> &ndash; Joint handle<br/>
<p>Return value<br/>
<span class='retname'>movement</span> <span class='argtype'>(number)</span> &ndash; Current joint position or angle<br/>
<p>Return the current position or angle or the joint, measured in same way
as joint limits.
<p>
</p>
<pre class='example'>
function init()
	local current = GetJointMovement(FindJoint("hinge"))
	DebugPrint(current)
end

</pre>
<hr/>
<a name='GetJointedBodies'></a><h3 class='function'>GetJointedBodies</h3>
<pre class='funcdef'><span class='retname'>bodies = </span>GetJointedBodies(<span class='argname'>body</span>)</pre>
<p>Arguments<br/>
<span class='argname'>body</span> <span class='argtype'>(number)</span> &ndash; Body handle (must be dynamic)<br/>
<p>Return value<br/>
<span class='retname'>bodies</span> <span class='argtype'>(table)</span> &ndash; Handles to all dynamic bodies in the jointed structure. The input handle will also be included.<br/>
<p><p>
</p>
<pre class='example'>
local body = 0
function init()
	body = FindBody("body")
end

function tick()
	--Draw outline for all bodies in jointed structure
	local all = GetJointedBodies(body)
	for i=1,#all do
		DrawBodyOutline(all[i], 0.5)
	end
end

</pre>
<hr/>
<a name='DetachJointFromShape'></a><h3 class='function'>DetachJointFromShape</h3>
<pre class='funcdef'><span class='retname'></span>DetachJointFromShape(<span class='argname'>joint, shape</span>)</pre>
<p>Arguments<br/>
<span class='argname'>joint</span> <span class='argtype'>(number)</span> &ndash; Joint handle<br/>
<span class='argname'>shape</span> <span class='argtype'>(number)</span> &ndash; Shape handle<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Detach joint from shape. If joint is not connected to shape, nothing happens.
<p>
</p>
<pre class='example'>
function init()
	DetachJointFromShape(FindJoint("joint"), FindShape("door"))
end

</pre>
<hr/>
<a name='GetRopeNumberOfPoints'></a><h3 class='function'>GetRopeNumberOfPoints</h3>
<pre class='funcdef'><span class='retname'>amount = </span>GetRopeNumberOfPoints(<span class='argname'>joint</span>)</pre>
<p>Arguments<br/>
<span class='argname'>joint</span> <span class='argtype'>(number)</span> &ndash; Joint handle<br/>
<p>Return value<br/>
<span class='retname'>amount</span> <span class='argtype'>(number)</span> &ndash; Number of points in a rope or zero if invalid<br/>
<p>Returns the number of points in the rope given its handle.
Will return zero if the handle is not a rope
<p>
</p>
<pre class='example'>
function init()
	local joint = FindJoint("joint")
	local numberPoints = GetRopeNumberOfPoints(joint)
end

</pre>
<hr/>
<a name='GetRopePointPosition'></a><h3 class='function'>GetRopePointPosition</h3>
<pre class='funcdef'><span class='retname'>pos = </span>GetRopePointPosition(<span class='argname'>joint, index</span>)</pre>
<p>Arguments<br/>
<span class='argname'>joint</span> <span class='argtype'>(number)</span> &ndash; Joint handle<br/>
<span class='argname'>index</span> <span class='argtype'>(number)</span> &ndash; The point index, starting at 1<br/>
<p>Return value<br/>
<span class='retname'>pos</span> <span class='argtype'>(TVec)</span> &ndash; World position of the point, or nil, if invalid<br/>
<p>Returns the world position of the rope's point.
Will return nil if the handle is not a rope or the index is not valid
<p>
</p>
<pre class='example'>
function init()
	local joint = FindJoint("joint")
	numberPoints = GetRopeNumberOfPoints(joint)

	for pointIndex = 1, numberPoints do
		DebugCross(GetRopePointPosition(joint, pointIndex))
	end
end

</pre>
<hr/>
<a name='GetRopeBounds'></a><h3 class='function'>GetRopeBounds</h3>
<pre class='funcdef'><span class='retname'>min, max = </span>GetRopeBounds(<span class='argname'>joint</span>)</pre>
<p>Arguments<br/>
<span class='argname'>joint</span> <span class='argtype'>(number)</span> &ndash; Joint handle<br/>
<p>Return value<br/>
<span class='retname'>min</span> <span class='argtype'>(TVec)</span> &ndash; Lower point of rope bounds in world space<br/>
<span class='retname'>max</span> <span class='argtype'>(TVec)</span> &ndash; Upper point of rope bounds in world space<br/>
<p>Returns the bounds of the rope.
Will return nil if the handle is not a rope
<p>
</p>
<pre class='example'>
function init()
	local joint = FindJoint("joint")
	local mi, ma = GetRopeBounds(joint)

	DebugCross(mi)
	DebugCross(ma)
end

</pre>
<hr/>
<a name='BreakRope'></a><h3 class='function'>BreakRope</h3>
<pre class='funcdef'><span class='retname'></span>BreakRope(<span class='argname'>joint, point</span>)</pre>
<p>Arguments<br/>
<span class='argname'>joint</span> <span class='argtype'>(number)</span> &ndash; Rope type joint handle<br/>
<span class='argname'>point</span> <span class='argtype'>(TVec)</span> &ndash; Point of break as world space vector<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Breaks the rope at the specified point.
<p>
</p>
<pre class='example'>
function tick()
	local playerCameraTransform = GetPlayerCameraTransform()
	local dir = TransformToParentVec(playerCameraTransform, Vec(0, 0, -1))

	local hit, dist, joint = QueryRaycastRope(playerCameraTransform.pos, dir, 5)
	if hit then
		local breakPoint = VecAdd(playerCameraTransform.pos, VecScale(dir, dist))
		BreakRope(joint, breakPoint)
	end
end

</pre>
<hr/>
<a name='SetAnimatorPositionIK'></a><h3 class='function'>SetAnimatorPositionIK</h3>
<pre class='funcdef'><span class='retname'></span>SetAnimatorPositionIK(<span class='argname'>handle, begname, endname, target, [weight], [history], [flag]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Animator handle<br/>
<span class='argname'>begname</span> <span class='argtype'>(string)</span> &ndash; Name of the start-bone of the chain<br/>
<span class='argname'>endname</span> <span class='argtype'>(string)</span> &ndash; Name of the end-bone of the chain<br/>
<span class='argname'>target</span> <span class='argtype'>(TVec)</span> &ndash; World target position that the "endname" bone should reach<br/>
<span class='argname'>weight</span> <span class='argtype'>(number, optional)</span> &ndash; Weight [0,1] of this animation, default is 1.0<br/>
<span class='argname'>history</span> <span class='argtype'>(number, optional)</span> &ndash; How much of the previous frames result [0,1] that should be used when start the IK search, default is 0.0<br/>
<span class='argname'>flag</span> <span class='argtype'>(boolean, optional)</span> &ndash; TRUE if constraints should be used, default is TRUE<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p><p>
</p>
<pre class='example'>
SetAnimatorPositionIK(animator, "shoulder_l", "hand_l", Vec(10, 0, 0), 1.0, 0.9, true)

</pre>
<hr/>
<a name='SetAnimatorTransformIK'></a><h3 class='function'>SetAnimatorTransformIK</h3>
<pre class='funcdef'><span class='retname'></span>SetAnimatorTransformIK(<span class='argname'>handle, begname, endname, transform, [weight], [history], [locktarget], [useconstraints]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Animator handle<br/>
<span class='argname'>begname</span> <span class='argtype'>(string)</span> &ndash; Name of the start-bone of the chain<br/>
<span class='argname'>endname</span> <span class='argtype'>(string)</span> &ndash; Name of the end-bone of the chain<br/>
<span class='argname'>transform</span> <span class='argtype'>(TTransform)</span> &ndash; World target transform that the "endname" bone should reach<br/>
<span class='argname'>weight</span> <span class='argtype'>(number, optional)</span> &ndash; Weight [0,1] of this animation, default is 1.0<br/>
<span class='argname'>history</span> <span class='argtype'>(number, optional)</span> &ndash; How much of the previous frames result [0,1] that should be used when start the IK search, default is 0.0<br/>
<span class='argname'>locktarget</span> <span class='argtype'>(boolean, optional)</span> &ndash; TRUE if the end-bone should be fixed to the target-transform, FALSE if IK solution is used<br/>
<span class='argname'>useconstraints</span> <span class='argtype'>(boolean, optional)</span> &ndash; TRUE if constraints should be used, default is TRUE<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p><p>
</p>
<pre class='example'>
SetAnimatorTransformIK(animator, "shoulder_l", "hand_l", Transform(10, 0, 0), 1.0, 0.9, false, true)

</pre>
<hr/>
<a name='GetBoneChainLength'></a><h3 class='function'>GetBoneChainLength</h3>
<pre class='funcdef'><span class='retname'>length = </span>GetBoneChainLength(<span class='argname'>handle, begname, endname</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Animator handle<br/>
<span class='argname'>begname</span> <span class='argtype'>(string)</span> &ndash; Name of the start-bone of the chain<br/>
<span class='argname'>endname</span> <span class='argtype'>(string)</span> &ndash; Name of the end-bone of the chain<br/>
<p>Return value<br/>
<span class='retname'>length</span> <span class='argtype'>(number)</span> &ndash; Length of the bone chain between "start-bone" and "end-bone"<br/>
<p>This will calculate the length of the bone-chain between the endpoints.
If the skeleton have a chain like this (shoulder_l -> upper_arm_l -> lower_arm_l -> hand_l) it will return the length of the upper_arm_l+lower_arm_l
<p>
</p>
<pre class='example'>
local length = GetBoneChainLength(animator, "shoulder_l", "hand_l")

</pre>
<hr/>
<a name='FindAnimator'></a><h3 class='function'>FindAnimator</h3>
<pre class='funcdef'><span class='retname'>handle = </span>FindAnimator(<span class='argname'>[tag], [global]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>tag</span> <span class='argtype'>(string, optional)</span> &ndash; Tag name<br/>
<span class='argname'>global</span> <span class='argtype'>(boolean, optional)</span> &ndash; Search in entire scene<br/>
<p>Return value<br/>
<span class='retname'>handle</span> <span class='argtype'>(number)</span> &ndash; Handle to first animator with specified tag or zero if not found<br/>
<p><p>
</p>
<pre class='example'>
--Search for the first animator in script scope
local animator = FindAnimator()

--Search for an animator tagged "anim" in script scope
local animator = FindAnimator("anim")

--Search for an animator tagged "anim2" in entire scene
local anim2 = FindAnimator("anim2", true)

</pre>
<hr/>
<a name='FindAnimators'></a><h3 class='function'>FindAnimators</h3>
<pre class='funcdef'><span class='retname'>list = </span>FindAnimators(<span class='argname'>[tag], [global]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>tag</span> <span class='argtype'>(string, optional)</span> &ndash; Tag name<br/>
<span class='argname'>global</span> <span class='argtype'>(boolean, optional)</span> &ndash; Search in entire scene<br/>
<p>Return value<br/>
<span class='retname'>list</span> <span class='argtype'>(table)</span> &ndash; Indexed table with handles to all animators with specified tag<br/>
<p><p>
</p>
<pre class='example'>
--Search for animators tagged "target" in script scope
local targets = FindAnimators("target")
for i=1, #targets do
	local target = targets[i]
	...
end

</pre>
<hr/>
<a name='GetAnimatorTransform'></a><h3 class='function'>GetAnimatorTransform</h3>
<pre class='funcdef'><span class='retname'>transform = </span>GetAnimatorTransform(<span class='argname'>handle</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Animator handle<br/>
<p>Return value<br/>
<span class='retname'>transform</span> <span class='argtype'>(TTransform)</span> &ndash; World space transform of the animator<br/>
<p><p>
</p>
<pre class='example'>
local pos = GetAnimatorTransform(animator).pos

</pre>
<hr/>
<a name='GetAnimatorAdjustTransformIK'></a><h3 class='function'>GetAnimatorAdjustTransformIK</h3>
<pre class='funcdef'><span class='retname'>transform = </span>GetAnimatorAdjustTransformIK(<span class='argname'>handle, name</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Animator handle<br/>
<span class='argname'>name</span> <span class='argtype'>(string)</span> &ndash; Name of the location node<br/>
<p>Return value<br/>
<span class='retname'>transform</span> <span class='argtype'>(TTransform)</span> &ndash; World space transform of the animator<br/>
<p>When using IK for a character you can use ik-helpers to define where the
<p>
</p>
<pre class='example'>
--This will adjust the target transform so that the grip defined by a location node in editor called "ik_hand_l" will reach the target
local target = Transform(Vec(10, 0, 0), QuatEuler(0, 90, 0))
local adj = GetAnimatorAdjustTransformIK(animator, "ik_hand_l")
if adj ~= nil then
    target = TransformToParentTransform(target, adj)
end
SetAnimatorTransformIK(animator, "shoulder_l", "hand_l", target, 1.0, 0.9)

</pre>
<hr/>
<a name='SetAnimatorTransform'></a><h3 class='function'>SetAnimatorTransform</h3>
<pre class='funcdef'><span class='retname'></span>SetAnimatorTransform(<span class='argname'>handle, transform</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Animator handle<br/>
<span class='argname'>transform</span> <span class='argtype'>(TTransform)</span> &ndash; Desired transform<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p><p>
</p>
<pre class='example'>
local t = Transform(Vec(10, 0, 0), QuatEuler(0, 90, 0))
SetAnimatorTransform(animator, t)

</pre>
<hr/>
<a name='MakeRagdoll'></a><h3 class='function'>MakeRagdoll</h3>
<pre class='funcdef'><span class='retname'></span>MakeRagdoll(<span class='argname'>handle</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Animator handle<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Make all prefab bodies physical and leave control to physics system
<p>
</p>
<pre class='example'>
MakeRagdoll(animator)

</pre>
<hr/>
<a name='UnRagdoll'></a><h3 class='function'>UnRagdoll</h3>
<pre class='funcdef'><span class='retname'></span>UnRagdoll(<span class='argname'>handle, [time]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Animator handle<br/>
<span class='argname'>time</span> <span class='argtype'>(number, optional)</span> &ndash; Transition time<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Take control if the prefab bodies and do an optional blend between the current ragdoll state and current animation state
<p>
</p>
<pre class='example'>
--Take control of bodies and do a blend during one sec between the animation state and last physics state
UnRagdoll(animator, 1.0)

</pre>
<hr/>
<a name='PlayAnimation'></a><h3 class='function'>PlayAnimation</h3>
<pre class='funcdef'><span class='retname'>handle = </span>PlayAnimation(<span class='argname'>handle, name, [weight], [filter]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Animator handle<br/>
<span class='argname'>name</span> <span class='argtype'>(string)</span> &ndash; Animation name<br/>
<span class='argname'>weight</span> <span class='argtype'>(number, optional)</span> &ndash; Weight [0,1] of this animation, default is 1.0<br/>
<span class='argname'>filter</span> <span class='argtype'>(string, optional)</span> &ndash; Name of the bone and its subtree that will be affected<br/>
<p>Return value<br/>
<span class='retname'>handle</span> <span class='argtype'>(number)</span> &ndash; Handle to the instance that can be used with PlayAnimationInstance, zero if clip reached its end<br/>
<p>Single animations, one-shot, will be processed after looping animations.
<p>
</p>
<pre class='example'>
--This will play a single animation "Shooting" with a 80% influence but only on the skeleton starting at bone "Spine"
PlayAnimation(animator, "Shooting", 0.8, "Spine")

</pre>
<hr/>
<a name='PlayAnimationLoop'></a><h3 class='function'>PlayAnimationLoop</h3>
<pre class='funcdef'><span class='retname'></span>PlayAnimationLoop(<span class='argname'>handle, name, [weight], [filter]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Animator handle<br/>
<span class='argname'>name</span> <span class='argtype'>(string)</span> &ndash; Animation name<br/>
<span class='argname'>weight</span> <span class='argtype'>(number, optional)</span> &ndash; Weight [0,1] of this animation, default is 1.0<br/>
<span class='argname'>filter</span> <span class='argtype'>(string, optional)</span> &ndash; Name of the bone and its subtree that will be affected<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p><p>
</p>
<pre class='example'>
--This will play an animation loop "Walking" with a 100% influence on the whole skeleton
PlayAnimationLoop(animator, "Walking")

</pre>
<hr/>
<a name='PlayAnimationInstance'></a><h3 class='function'>PlayAnimationInstance</h3>
<pre class='funcdef'><span class='retname'>handle = </span>PlayAnimationInstance(<span class='argname'>handle, instance, [weight], [speed]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Animator handle<br/>
<span class='argname'>instance</span> <span class='argtype'>(number)</span> &ndash; Instance handle<br/>
<span class='argname'>weight</span> <span class='argtype'>(number, optional)</span> &ndash; Weight [0,1] of this animation, default is 1.0<br/>
<span class='argname'>speed</span> <span class='argtype'>(number, optional)</span> &ndash; Weight [0,1] of this animation, default is 1.0<br/>
<p>Return value<br/>
<span class='retname'>handle</span> <span class='argtype'>(number)</span> &ndash; Handle to the instance that can be used with PlayAnimationInstance, zero if clip reached its end<br/>
<p>Single animations, one-shot, will be processed after looping animations.
<p>
</p>
<pre class='example'>
--This will play a single animation "Shooting" with a 80% influence but only on the skeleton starting at bone "Spine"
PlayAnimation(animator, "Shooting", 0.8, "Spine")

</pre>
<hr/>
<a name='StopAnimationInstance'></a><h3 class='function'>StopAnimationInstance</h3>
<pre class='funcdef'><span class='retname'></span>StopAnimationInstance(<span class='argname'>handle, instance</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Animator handle<br/>
<span class='argname'>instance</span> <span class='argtype'>(number)</span> &ndash; Instance handle<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>This will stop the playing anim-instance
<p>
</p>
<hr/>
<a name='PlayAnimationFrame'></a><h3 class='function'>PlayAnimationFrame</h3>
<pre class='funcdef'><span class='retname'></span>PlayAnimationFrame(<span class='argname'>handle, name, time, [weight], [filter]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Animator handle<br/>
<span class='argname'>name</span> <span class='argtype'>()</span> &ndash; Animation name<br/>
<span class='argname'>time</span> <span class='argtype'>()</span> &ndash; Time in the animation<br/>
<span class='argname'>weight</span> <span class='argtype'>(number, optional)</span> &ndash; Weight [0,1] of this animation, default is 1.0<br/>
<span class='argname'>filter</span> <span class='argtype'>(string, optional)</span> &ndash; Name of the bone and its subtree that will be affected<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p><p>
</p>
<pre class='example'>
--This will play an animation "Walking" at a specific time of 1.5s with a 80% influence on the whole skeleton
PlayAnimationFrame(animator, "Walking", 1.5, 0.8)

</pre>
<hr/>
<a name='BeginAnimationGroup'></a><h3 class='function'>BeginAnimationGroup</h3>
<pre class='funcdef'><span class='retname'></span>BeginAnimationGroup(<span class='argname'>handle, [weight], [filter]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Animator handle<br/>
<span class='argname'>weight</span> <span class='argtype'>(number, optional)</span> &ndash; Weight [0,1] of this group, default is 1.0<br/>
<span class='argname'>filter</span> <span class='argtype'>(string, optional)</span> &ndash; Name of the bone and its subtree that will be affected<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>You can group looping animations together and use the result of those to blend to target.
PlayAnimation will not work here since they are processed last separately from blendgroups.
<p>
</p>
<pre class='example'>
--This will blend an entire group with 50% influence
BeginAnimationGroup(animator, 0.5)
	PlayAnimationLoop(...)
	PlayAnimationLoop(...)
EndAnimationGroup(animator)

--You can also create a tree of groups, blending is performed in a depth-first order
BeginAnimationGroup(animator, 0.5)
	PlayAnimationLoop(animator, "anim_a", 1.0)
	PlayAnimationLoop(animator, "anim_b", 0.2)
	BeginAnimationGroup(animator, 0.75)
		PlayAnimationLoop(animator, "anim_c", 1.0)
		PlayAnimationLoop(animator, "anim_d", 0.25)
	EndAnimationGroup(animator)
EndAnimationGroup(animator)

</pre>
<hr/>
<a name='EndAnimationGroup'></a><h3 class='function'>EndAnimationGroup</h3>
<pre class='funcdef'><span class='retname'></span>EndAnimationGroup(<span class='argname'>handle</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Animator handle<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Ends the group created by BeginAnimationGroup
<p>
</p>
<hr/>
<a name='PlayAnimationInstances'></a><h3 class='function'>PlayAnimationInstances</h3>
<pre class='funcdef'><span class='retname'></span>PlayAnimationInstances(<span class='argname'>handle</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Animator handle<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Single animations, one-shot, will be processed after looping animations.
By calling PlayAnimationInstances you can force it to be processed earlier and be able to "overwrite" the result of it if you want
<p>
</p>
<pre class='example'>
--First we play a single jump animation affecting the whole skeleton
--Then we play an aiming animation on the upper-body, filter="Spine1", keeping the lower-body unaffected
--Then we force the single-animations to be processed, this will force the "jump" to be processed.
--Then we overwrite just the spine-bone with a mouse controlled rotation("rot")
--Result will be a jump animation with the upperbody playing an aiming animation but the pitch of the spine controlled by the mouse("rot")

if InputPressed("jump") then
	PlayAnimation(animator, "Jump")
end
PlayAnimationLoop(animator, "Pistol Idle", aimWeight, "Spine1")
PlayAnimationInstances(animator)
SetBoneRotation(animator, "Spine1", rot, 1)

</pre>
<hr/>
<a name='GetAnimationClipNames'></a><h3 class='function'>GetAnimationClipNames</h3>
<pre class='funcdef'><span class='retname'>list = </span>GetAnimationClipNames(<span class='argname'>handle</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Animator handle<br/>
<p>Return value<br/>
<span class='retname'>list</span> <span class='argtype'>(table)</span> &ndash; Indexed table with animation names<br/>
<p><p>
</p>
<pre class='example'>
local list = GetAnimationClipNames(animator)
for i=1, #list do
	local name = list[i]
	..
end

</pre>
<hr/>
<a name='GetAnimationClipDuration'></a><h3 class='function'>GetAnimationClipDuration</h3>
<pre class='funcdef'><span class='retname'>time = </span>GetAnimationClipDuration(<span class='argname'>handle, name</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Animator handle<br/>
<span class='argname'>name</span> <span class='argtype'>()</span> &ndash; Animation name<br/>
<p>Return value<br/>
<span class='retname'>time</span> <span class='argtype'>()</span> &ndash; Total duration of the animation<br/>
<p><p>
</p>
<hr/>
<a name='SetAnimationClipFade'></a><h3 class='function'>SetAnimationClipFade</h3>
<pre class='funcdef'><span class='retname'></span>SetAnimationClipFade(<span class='argname'>handle, name, fadein, fadeout</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>()</span> &ndash; Animator handle<br/>
<span class='argname'>name</span> <span class='argtype'>()</span> &ndash; Animation name<br/>
<span class='argname'>fadein</span> <span class='argtype'>()</span> &ndash; Fadein time of the animation<br/>
<span class='argname'>fadeout</span> <span class='argtype'>(number)</span> &ndash; Fadeout time of the animation<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p><p>
</p>
<pre class='example'>
SetAnimationClipFade(animator, "fire", 0.5, 0.5)

</pre>
<hr/>
<a name='SetAnimationClipSpeed'></a><h3 class='function'>SetAnimationClipSpeed</h3>
<pre class='funcdef'><span class='retname'></span>SetAnimationClipSpeed(<span class='argname'>handle, name, speed</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Animator handle<br/>
<span class='argname'>name</span> <span class='argtype'>()</span> &ndash; Animation name<br/>
<span class='argname'>speed</span> <span class='argtype'>()</span> &ndash; Sets the speed factor of the animation<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p><p>
</p>
<pre class='example'>
--This will make the clip run 2x as normal speed
SetAnimationClipSpeed(animator, "walking", 2)

</pre>
<hr/>
<a name='TrimAnimationClip'></a><h3 class='function'>TrimAnimationClip</h3>
<pre class='funcdef'><span class='retname'></span>TrimAnimationClip(<span class='argname'>handle, name, begoffset, [endoffset]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>()</span> &ndash; Animator handle<br/>
<span class='argname'>name</span> <span class='argtype'>()</span> &ndash; Animation name<br/>
<span class='argname'>begoffset</span> <span class='argtype'>(number)</span> &ndash; Time offset from the beginning of the animation<br/>
<span class='argname'>endoffset</span> <span class='argtype'>(number, optional)</span> &ndash; Time offset, positive value means from the beginning and negative value means from the end, zero(default) means at end<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p><p>
</p>
<pre class='example'>
--This will "remove" 1s from the beginning and 2s from the end.
TrimAnimationClip(animator, "walking", 1, -2)

</pre>
<hr/>
<a name='GetAnimationClipLoopPosition'></a><h3 class='function'>GetAnimationClipLoopPosition</h3>
<pre class='funcdef'><span class='retname'>time = </span>GetAnimationClipLoopPosition(<span class='argname'>handle, name</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Animator handle<br/>
<span class='argname'>name</span> <span class='argtype'>()</span> &ndash; Animation name<br/>
<p>Return value<br/>
<span class='retname'>time</span> <span class='argtype'>()</span> &ndash; Time of the current playposition in the animation<br/>
<p><p>
</p>
<hr/>
<a name='GetAnimationInstancePosition'></a><h3 class='function'>GetAnimationInstancePosition</h3>
<pre class='funcdef'><span class='retname'>time = </span>GetAnimationInstancePosition(<span class='argname'>handle, instance</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Animator handle<br/>
<span class='argname'>instance</span> <span class='argtype'>(number)</span> &ndash; Instance handle<br/>
<p>Return value<br/>
<span class='retname'>time</span> <span class='argtype'>()</span> &ndash; Time of the current playposition in the animation<br/>
<p><p>
</p>
<hr/>
<a name='SetAnimationClipLoopPosition'></a><h3 class='function'>SetAnimationClipLoopPosition</h3>
<pre class='funcdef'><span class='retname'></span>SetAnimationClipLoopPosition(<span class='argname'>handle, name, time</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Animator handle<br/>
<span class='argname'>name</span> <span class='argtype'>()</span> &ndash; Animation name<br/>
<span class='argname'>time</span> <span class='argtype'>()</span> &ndash; Time in the animation<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p><p>
</p>
<pre class='example'>
--This will set the current playposition to one second
SetAnimationClipLoopPosition(animator, "walking", 1)

</pre>
<hr/>
<a name='SetBoneRotation'></a><h3 class='function'>SetBoneRotation</h3>
<pre class='funcdef'><span class='retname'></span>SetBoneRotation(<span class='argname'>handle, name, quat, [weight]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Animator handle<br/>
<span class='argname'>name</span> <span class='argtype'>()</span> &ndash; Bone name<br/>
<span class='argname'>quat</span> <span class='argtype'>()</span> &ndash; Orientation of the bone<br/>
<span class='argname'>weight</span> <span class='argtype'>(number, optional)</span> &ndash; Weight [0,1] default is 1.0<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p><p>
</p>
<pre class='example'>
--This will set the existing rotation by QuatEuler(...)
SetBoneRotation(animator, "spine", QuatEuler(0, 180, 0), 1.0)

</pre>
<hr/>
<a name='SetBoneLookAt'></a><h3 class='function'>SetBoneLookAt</h3>
<pre class='funcdef'><span class='retname'></span>SetBoneLookAt(<span class='argname'>handle, name, point, [weight]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Animator handle<br/>
<span class='argname'>name</span> <span class='argtype'>()</span> &ndash; Bone name<br/>
<span class='argname'>point</span> <span class='argtype'>()</span> &ndash; World space point as vector<br/>
<span class='argname'>weight</span> <span class='argtype'>(number, optional)</span> &ndash; Weight [0,1] default is 1.0<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p><p>
</p>
<pre class='example'>
--This will set the existing local-rotation to point to world space point
SetBoneLookAt(animator, "upper_arm_l", Vec(10, 20, 30), 1.0)

</pre>
<hr/>
<a name='RotateBone'></a><h3 class='function'>RotateBone</h3>
<pre class='funcdef'><span class='retname'></span>RotateBone(<span class='argname'>handle, name, quat, [weight]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Animator handle<br/>
<span class='argname'>name</span> <span class='argtype'>()</span> &ndash; Bone name<br/>
<span class='argname'>quat</span> <span class='argtype'>()</span> &ndash; Additive orientation<br/>
<span class='argname'>weight</span> <span class='argtype'>(number, optional)</span> &ndash; Weight [0,1] default is 1.0<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p><p>
</p>
<pre class='example'>
--This will offset the existing rotation by QuatEuler(...)
RotateBone(animator, "spine", QuatEuler(0, 5, 0), 1.0)

</pre>
<hr/>
<a name='GetBoneNames'></a><h3 class='function'>GetBoneNames</h3>
<pre class='funcdef'><span class='retname'>list = </span>GetBoneNames(<span class='argname'>handle</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Animator handle<br/>
<p>Return value<br/>
<span class='retname'>list</span> <span class='argtype'>(table)</span> &ndash; Indexed table with bone-names<br/>
<p><p>
</p>
<pre class='example'>
local list = GetBoneNames(animator)
for i=1, #list do
	local name = list[i]
	..
end

</pre>
<hr/>
<a name='GetBoneBody'></a><h3 class='function'>GetBoneBody</h3>
<pre class='funcdef'><span class='retname'>handle = </span>GetBoneBody(<span class='argname'>handle, name</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Animator handle<br/>
<span class='argname'>name</span> <span class='argtype'>(string)</span> &ndash; Bone name<br/>
<p>Return value<br/>
<span class='retname'>handle</span> <span class='argtype'>(number)</span> &ndash; Handle to the bone's body, or zero if no bone is present.<br/>
<p><p>
</p>
<pre class='example'>
local body = GetBoneBody(animator, "head")
end

</pre>
<hr/>
<a name='GetBoneWorldTransform'></a><h3 class='function'>GetBoneWorldTransform</h3>
<pre class='funcdef'><span class='retname'>transform = </span>GetBoneWorldTransform(<span class='argname'>handle, name</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Animator handle<br/>
<span class='argname'>name</span> <span class='argtype'>(string)</span> &ndash; Bone name<br/>
<p>Return value<br/>
<span class='retname'>transform</span> <span class='argtype'>(TTransform)</span> &ndash; World space transform of the bone<br/>
<p><p>
</p>
<pre class='example'>
    local animator = GetPlayerAnimator()
    local bones = GetBoneNames(animator)
    for i=1, #bones do
        local bone = bones[i]
        local t = GetBoneWorldTransform(animator,bone)
        DebugCross(t.pos)
    end

</pre>
<hr/>
<a name='GetBoneBindPoseTransform'></a><h3 class='function'>GetBoneBindPoseTransform</h3>
<pre class='funcdef'><span class='retname'>transform = </span>GetBoneBindPoseTransform(<span class='argname'>handle, name</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Animator handle<br/>
<span class='argname'>name</span> <span class='argtype'>(string)</span> &ndash; Bone name<br/>
<p>Return value<br/>
<span class='retname'>transform</span> <span class='argtype'>(TTransform)</span> &ndash; Local space transform of the bone in bindpose<br/>
<p><p>
</p>
<pre class='example'>
local lt = getBindPoseTransform(animator, "lefthand")

</pre>
<hr/>
<a name='FindLight'></a><h3 class='function'>FindLight</h3>
<pre class='funcdef'><span class='retname'>handle = </span>FindLight(<span class='argname'>[tag], [global]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>tag</span> <span class='argtype'>(string, optional)</span> &ndash; Tag name<br/>
<span class='argname'>global</span> <span class='argtype'>(boolean, optional)</span> &ndash; Search in entire scene<br/>
<p>Return value<br/>
<span class='retname'>handle</span> <span class='argtype'>(number)</span> &ndash; Handle to first light with specified tag or zero if not found<br/>
<p><p>
</p>
<pre class='example'>
function init()
	local light = FindLight("main")
	DebugPrint(light)
end

</pre>
<hr/>
<a name='FindLights'></a><h3 class='function'>FindLights</h3>
<pre class='funcdef'><span class='retname'>list = </span>FindLights(<span class='argname'>[tag], [global]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>tag</span> <span class='argtype'>(string, optional)</span> &ndash; Tag name<br/>
<span class='argname'>global</span> <span class='argtype'>(boolean, optional)</span> &ndash; Search in entire scene<br/>
<p>Return value<br/>
<span class='retname'>list</span> <span class='argtype'>(table)</span> &ndash; Indexed table with handles to all lights with specified tag<br/>
<p><p>
</p>
<pre class='example'>
function init()
	--Search for lights tagged "main" in script scope
	local lights = FindLights("main")
	for i=1, #lights do
		local light = lights[i]
		DebugPrint(light)
	end
end

</pre>
<hr/>
<a name='SetLightEnabled'></a><h3 class='function'>SetLightEnabled</h3>
<pre class='funcdef'><span class='retname'></span>SetLightEnabled(<span class='argname'>handle, enabled</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Light handle<br/>
<span class='argname'>enabled</span> <span class='argtype'>(boolean)</span> &ndash; Set to true if light should be enabled<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>If light is owned by a shape, the emissive scale of that shape will be set
to 0.0 when light is disabled and 1.0 when light is enabled.
<p>
</p>
<pre class='example'>
function init()
	SetLightEnabled(FindLight("main"), false)
end

</pre>
<hr/>
<a name='SetLightColor'></a><h3 class='function'>SetLightColor</h3>
<pre class='funcdef'><span class='retname'></span>SetLightColor(<span class='argname'>handle, r, g, b</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Light handle<br/>
<span class='argname'>r</span> <span class='argtype'>(number)</span> &ndash; Red value<br/>
<span class='argname'>g</span> <span class='argtype'>(number)</span> &ndash; Green value<br/>
<span class='argname'>b</span> <span class='argtype'>(number)</span> &ndash; Blue value<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>This will only set the color tint of the light. Use SetLightIntensity for brightness.
Setting the light color will not affect the emissive color of a parent shape.
<p>
</p>
<pre class='example'>
function init()
	--Set light color to yellow
	SetLightColor(FindLight("main"), 1, 1, 0)
end

</pre>
<hr/>
<a name='SetLightIntensity'></a><h3 class='function'>SetLightIntensity</h3>
<pre class='funcdef'><span class='retname'></span>SetLightIntensity(<span class='argname'>handle, intensity</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Light handle<br/>
<span class='argname'>intensity</span> <span class='argtype'>(number)</span> &ndash; Desired intensity of the light<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>If the shape is owned by a shape you most likely want to use
SetShapeEmissiveScale instead, which will affect both the emissiveness 
of the shape and the brightness of the light at the same time.
<p>
</p>
<pre class='example'>
function init()
	--Pulsate light
	SetLightIntensity(FindLight("main"), math.sin(GetTime())*0.5 + 1.0)
end

</pre>
<hr/>
<a name='GetLightTransform'></a><h3 class='function'>GetLightTransform</h3>
<pre class='funcdef'><span class='retname'>transform = </span>GetLightTransform(<span class='argname'>handle</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Light handle<br/>
<p>Return value<br/>
<span class='retname'>transform</span> <span class='argtype'>(TTransform)</span> &ndash; World space light transform<br/>
<p>Lights that are owned by a dynamic shape are automatcially moved with that shape
<p>
</p>
<pre class='example'>
local light = 0
function init()
	light = FindLight("main")
	local t = GetLightTransform(light)
	DebugPrint(VecStr(t.pos))
end

</pre>
<hr/>
<a name='GetLightShape'></a><h3 class='function'>GetLightShape</h3>
<pre class='funcdef'><span class='retname'>handle = </span>GetLightShape(<span class='argname'>handle</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Light handle<br/>
<p>Return value<br/>
<span class='retname'>handle</span> <span class='argtype'>(number)</span> &ndash; Shape handle or zero if not attached to shape<br/>
<p><p>
</p>
<pre class='example'>
local light = 0
function init()
	light = FindLight("main")
	local shape = GetLightShape(light)
	DebugPrint(shape)
end

</pre>
<hr/>
<a name='IsLightActive'></a><h3 class='function'>IsLightActive</h3>
<pre class='funcdef'><span class='retname'>active = </span>IsLightActive(<span class='argname'>handle</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Light handle<br/>
<p>Return value<br/>
<span class='retname'>active</span> <span class='argtype'>(boolean)</span> &ndash; True if light is currently emitting light<br/>
<p><p>
</p>
<pre class='example'>
local light = 0
function init()
	light = FindLight("main")
	if IsLightActive(light) then
		DebugPrint("Light is active")
	end
end

</pre>
<hr/>
<a name='IsPointAffectedByLight'></a><h3 class='function'>IsPointAffectedByLight</h3>
<pre class='funcdef'><span class='retname'>affected = </span>IsPointAffectedByLight(<span class='argname'>handle, point</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Light handle<br/>
<span class='argname'>point</span> <span class='argtype'>(TVec)</span> &ndash; World space point as vector<br/>
<p>Return value<br/>
<span class='retname'>affected</span> <span class='argtype'>(boolean)</span> &ndash; Return true if point is in light cone and range<br/>
<p><p>
</p>
<pre class='example'>
local light = 0
function init()
	light = FindLight("main")
	local point = Vec(0, 10, 0)
	local affected = IsPointAffectedByLight(light, point)
	DebugPrint(affected)
end

</pre>
<hr/>
<a name='GetFlashlight'></a><h3 class='function'>GetFlashlight</h3>
<pre class='funcdef'><span class='retname'>handle = </span>GetFlashlight(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>handle</span> <span class='argtype'>(number)</span> &ndash; Handle of the player's flashlight<br/>
<p>Returns the handle of the player's flashlight. You can work with it as with an entity of the Light type.
<p>
</p>
<pre class='example'>
function tick()
	local flashlight = GetFlashlight()
	SetProperty(flashlight, "color", Vec(0.5, 0, 1))
end

</pre>
<hr/>
<a name='SetFlashlight'></a><h3 class='function'>SetFlashlight</h3>
<pre class='funcdef'><span class='retname'></span>SetFlashlight(<span class='argname'>handle</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Handle of the light<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Sets a new entity of the Light type as a flashlight.
<p>
</p>
<pre class='example'>
local oldLight = 0
function tick()
	-- in order not to lose the original flashlight, it is better to save it's handle
	oldLight = GetFlashlight()
	SetFlashlight(FindEntity("mylight", true))
end

</pre>
<hr/>
<a name='FindTrigger'></a><h3 class='function'>FindTrigger</h3>
<pre class='funcdef'><span class='retname'>handle = </span>FindTrigger(<span class='argname'>[tag], [global]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>tag</span> <span class='argtype'>(string, optional)</span> &ndash; Tag name<br/>
<span class='argname'>global</span> <span class='argtype'>(boolean, optional)</span> &ndash; Search in entire scene<br/>
<p>Return value<br/>
<span class='retname'>handle</span> <span class='argtype'>(number)</span> &ndash; Handle to first trigger with specified tag or zero if not found<br/>
<p><p>
</p>
<pre class='example'>
function init()
	local goal = FindTrigger("goal")
end

</pre>
<hr/>
<a name='FindTriggers'></a><h3 class='function'>FindTriggers</h3>
<pre class='funcdef'><span class='retname'>list = </span>FindTriggers(<span class='argname'>[tag], [global]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>tag</span> <span class='argtype'>(string, optional)</span> &ndash; Tag name<br/>
<span class='argname'>global</span> <span class='argtype'>(boolean, optional)</span> &ndash; Search in entire scene<br/>
<p>Return value<br/>
<span class='retname'>list</span> <span class='argtype'>(table)</span> &ndash; Indexed table with handles to all triggers with specified tag<br/>
<p><p>
</p>
<pre class='example'>
function init()
	--Find triggers tagged "toxic" in script scope
	local triggers = FindTriggers("toxic")
	for i=1, #triggers do
		local trigger = triggers[i]
		DebugPrint(trigger)
	end
end

</pre>
<hr/>
<a name='GetTriggerTransform'></a><h3 class='function'>GetTriggerTransform</h3>
<pre class='funcdef'><span class='retname'>transform = </span>GetTriggerTransform(<span class='argname'>handle</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Trigger handle<br/>
<p>Return value<br/>
<span class='retname'>transform</span> <span class='argtype'>(TTransform)</span> &ndash; Current trigger transform in world space<br/>
<p><p>
</p>
<pre class='example'>
function init()
	local trigger = FindTrigger("toxic")
	local t = GetTriggerTransform(trigger)
	DebugPrint(t.pos)
end

</pre>
<hr/>
<a name='SetTriggerTransform'></a><h3 class='function'>SetTriggerTransform</h3>
<pre class='funcdef'><span class='retname'></span>SetTriggerTransform(<span class='argname'>handle, transform</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Trigger handle<br/>
<span class='argname'>transform</span> <span class='argtype'>(TTransform)</span> &ndash; Desired trigger transform in world space<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p><p>
</p>
<pre class='example'>
function init()
	local trigger = FindTrigger("toxic")
	local t = Transform(Vec(0, 1, 0), QuatEuler(0, 90, 0))
	SetTriggerTransform(trigger, t)
end

</pre>
<hr/>
<a name='GetTriggerBounds'></a><h3 class='function'>GetTriggerBounds</h3>
<pre class='funcdef'><span class='retname'>min, max = </span>GetTriggerBounds(<span class='argname'>handle</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Trigger handle<br/>
<p>Return value<br/>
<span class='retname'>min</span> <span class='argtype'>(TVec)</span> &ndash; Lower point of trigger bounds in world space<br/>
<span class='retname'>max</span> <span class='argtype'>(TVec)</span> &ndash; Upper point of trigger bounds in world space<br/>
<p>Return the lower and upper points in world space of the trigger axis aligned bounding box
<p>
</p>
<pre class='example'>
function init()
	local trigger = FindTrigger("toxic")
	local mi, ma = GetTriggerBounds(trigger)
	
	local list = QueryAabbShapes(mi, ma)
	for i = 1, #list do
		DebugPrint(list[i])
	end
end

</pre>
<hr/>
<a name='IsBodyInTrigger'></a><h3 class='function'>IsBodyInTrigger</h3>
<pre class='funcdef'><span class='retname'>inside = </span>IsBodyInTrigger(<span class='argname'>trigger, body</span>)</pre>
<p>Arguments<br/>
<span class='argname'>trigger</span> <span class='argtype'>(number)</span> &ndash; Trigger handle<br/>
<span class='argname'>body</span> <span class='argtype'>(number)</span> &ndash; Body handle<br/>
<p>Return value<br/>
<span class='retname'>inside</span> <span class='argtype'>(boolean)</span> &ndash; True if body is in trigger volume<br/>
<p>This function will only check the center point of the body
<p>
</p>
<pre class='example'>
local trigger = 0
local body = 0
function init()
	trigger = FindTrigger("toxic")
	body = FindBody("body")
end

function tick()
	if IsBodyInTrigger(trigger, body) then
		DebugPrint("In trigger!")
	end
end

</pre>
<hr/>
<a name='IsVehicleInTrigger'></a><h3 class='function'>IsVehicleInTrigger</h3>
<pre class='funcdef'><span class='retname'>inside = </span>IsVehicleInTrigger(<span class='argname'>trigger, vehicle</span>)</pre>
<p>Arguments<br/>
<span class='argname'>trigger</span> <span class='argtype'>(number)</span> &ndash; Trigger handle<br/>
<span class='argname'>vehicle</span> <span class='argtype'>(number)</span> &ndash; Vehicle handle<br/>
<p>Return value<br/>
<span class='retname'>inside</span> <span class='argtype'>(boolean)</span> &ndash; True if vehicle is in trigger volume<br/>
<p>This function will only check origo of vehicle
<p>
</p>
<pre class='example'>
local trigger = 0
local vehicle = 0
function init()
	trigger = FindTrigger("toxic")
	vehicle = FindVehicle("vehicle")
end

function tick()
	if IsVehicleInTrigger(trigger, vehicle) then
		DebugPrint("In trigger!")
	end
end

</pre>
<hr/>
<a name='IsShapeInTrigger'></a><h3 class='function'>IsShapeInTrigger</h3>
<pre class='funcdef'><span class='retname'>inside = </span>IsShapeInTrigger(<span class='argname'>trigger, shape</span>)</pre>
<p>Arguments<br/>
<span class='argname'>trigger</span> <span class='argtype'>(number)</span> &ndash; Trigger handle<br/>
<span class='argname'>shape</span> <span class='argtype'>(number)</span> &ndash; Shape handle<br/>
<p>Return value<br/>
<span class='retname'>inside</span> <span class='argtype'>(boolean)</span> &ndash; True if shape is in trigger volume<br/>
<p>This function will only check the center point of the shape
<p>
</p>
<pre class='example'>
local trigger = 0
local shape = 0
function init()
	trigger = FindTrigger("toxic")
	shape = FindShape("shape")
end

function tick()
	if IsShapeInTrigger(trigger, shape) then
		DebugPrint("In trigger!")
	end
end

</pre>
<hr/>
<a name='IsPointInTrigger'></a><h3 class='function'>IsPointInTrigger</h3>
<pre class='funcdef'><span class='retname'>inside = </span>IsPointInTrigger(<span class='argname'>trigger, point</span>)</pre>
<p>Arguments<br/>
<span class='argname'>trigger</span> <span class='argtype'>(number)</span> &ndash; Trigger handle<br/>
<span class='argname'>point</span> <span class='argtype'>(TVec)</span> &ndash; Word space point as vector<br/>
<p>Return value<br/>
<span class='retname'>inside</span> <span class='argtype'>(boolean)</span> &ndash; True if point is in trigger volume<br/>
<p><p>
</p>
<pre class='example'>
local trigger = 0
local point = {}
function init()
	trigger = FindTrigger("toxic", true)
	point = Vec(0, 0, 0)
end

function tick()
	if IsPointInTrigger(trigger, point) then
		DebugPrint("In trigger!")
	end
end

</pre>
<hr/>
<a name='IsPointInBoundaries'></a><h3 class='function'>IsPointInBoundaries</h3>
<pre class='funcdef'><span class='retname'>value = </span>IsPointInBoundaries(<span class='argname'>point</span>)</pre>
<p>Arguments<br/>
<span class='argname'>point</span> <span class='argtype'>(TVec)</span> &ndash; Point<br/>
<p>Return value<br/>
<span class='retname'>value</span> <span class='argtype'>(boolean)</span> &ndash; True if point is inside scene boundaries<br/>
<p>Checks whether the point is within the scene boundaries.
If there are no boundaries on the scene, the function returns True.
<p>
</p>
<pre class='example'>
function tick()
	local p = Vec(1.5, 3, 2.5)
	DebugWatch("In boundaries", IsPointInBoundaries(p))
end

</pre>
<hr/>
<a name='IsTriggerEmpty'></a><h3 class='function'>IsTriggerEmpty</h3>
<pre class='funcdef'><span class='retname'>empty, maxpoint = </span>IsTriggerEmpty(<span class='argname'>handle, [demolision]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Trigger handle<br/>
<span class='argname'>demolision</span> <span class='argtype'>(boolean, optional)</span> &ndash; If true, small debris and vehicles are ignored<br/>
<p>Return value<br/>
<span class='retname'>empty</span> <span class='argtype'>(boolean)</span> &ndash; True if trigger is empty<br/>
<span class='retname'>maxpoint</span> <span class='argtype'>(TVec)</span> &ndash; World space point of highest point (largest Y coordinate) if not empty<br/>
<p>This function will check if trigger is empty. If trigger contains any part of a body
it will return false and the highest point as second return value.
<p>
</p>
<pre class='example'>
local trigger = 0
function init()
	trigger = FindTrigger("toxic")
end

function tick()
	local empty, highPoint = IsTriggerEmpty(trigger)
	if not empty then
		--highPoint[2] is the tallest point in trigger
		DebugPrint("Is not empty")
	end
end

</pre>
<hr/>
<a name='GetTriggerDistance'></a><h3 class='function'>GetTriggerDistance</h3>
<pre class='funcdef'><span class='retname'>distance = </span>GetTriggerDistance(<span class='argname'>trigger, point</span>)</pre>
<p>Arguments<br/>
<span class='argname'>trigger</span> <span class='argtype'>(number)</span> &ndash; Trigger handle<br/>
<span class='argname'>point</span> <span class='argtype'>(TVec)</span> &ndash; Word space point as vector<br/>
<p>Return value<br/>
<span class='retname'>distance</span> <span class='argtype'>(number)</span> &ndash; Positive if point is outside, negative if inside<br/>
<p>Get distance to the surface of trigger volume. Will return negative distance if inside.
<p>
</p>
<pre class='example'>
local trigger = 0
function init()
	trigger = FindTrigger("toxic")
	local p = Vec(0, 10, 0)
	local dist = GetTriggerDistance(trigger, p)
	DebugPrint(dist)
end

</pre>
<hr/>
<a name='GetTriggerClosestPoint'></a><h3 class='function'>GetTriggerClosestPoint</h3>
<pre class='funcdef'><span class='retname'>closest = </span>GetTriggerClosestPoint(<span class='argname'>trigger, point</span>)</pre>
<p>Arguments<br/>
<span class='argname'>trigger</span> <span class='argtype'>(number)</span> &ndash; Trigger handle<br/>
<span class='argname'>point</span> <span class='argtype'>(TVec)</span> &ndash; Word space point as vector<br/>
<p>Return value<br/>
<span class='retname'>closest</span> <span class='argtype'>(TVec)</span> &ndash; Closest point in trigger as vector<br/>
<p>Return closest point in trigger volume. Will return the input point itself if inside trigger
or closest point on surface of trigger if outside.
<p>
</p>
<pre class='example'>
local trigger = 0
function init()
	trigger = FindTrigger("toxic")
	local p = Vec(0, 10, 0)
	local closest = GetTriggerClosestPoint(trigger, p)
	DebugPrint(closest)
end

</pre>
<hr/>
<a name='FindScreen'></a><h3 class='function'>FindScreen</h3>
<pre class='funcdef'><span class='retname'>handle = </span>FindScreen(<span class='argname'>[tag], [global]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>tag</span> <span class='argtype'>(string, optional)</span> &ndash; Tag name<br/>
<span class='argname'>global</span> <span class='argtype'>(boolean, optional)</span> &ndash; Search in entire scene<br/>
<p>Return value<br/>
<span class='retname'>handle</span> <span class='argtype'>(number)</span> &ndash; Handle to first screen with specified tag or zero if not found<br/>
<p><p>
</p>
<pre class='example'>
function init()
	local screen = FindScreen("tv")
	DebugPrint(screen)
end

</pre>
<hr/>
<a name='FindScreens'></a><h3 class='function'>FindScreens</h3>
<pre class='funcdef'><span class='retname'>list = </span>FindScreens(<span class='argname'>[tag], [global]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>tag</span> <span class='argtype'>(string, optional)</span> &ndash; Tag name<br/>
<span class='argname'>global</span> <span class='argtype'>(boolean, optional)</span> &ndash; Search in entire scene<br/>
<p>Return value<br/>
<span class='retname'>list</span> <span class='argtype'>(table)</span> &ndash; Indexed table with handles to all screens with specified tag<br/>
<p><p>
</p>
<pre class='example'>
function init()
	--Find screens tagged "tv" in script scope
	local screens = FindScreens("tv")
	for i=1, #screens do
		local screen = screens[i]
		DebugPrint(screen)
	end
end

</pre>
<hr/>
<a name='SetScreenEnabled'></a><h3 class='function'>SetScreenEnabled</h3>
<pre class='funcdef'><span class='retname'></span>SetScreenEnabled(<span class='argname'>screen, enabled</span>)</pre>
<p>Arguments<br/>
<span class='argname'>screen</span> <span class='argtype'>(number)</span> &ndash; Screen handle<br/>
<span class='argname'>enabled</span> <span class='argtype'>(boolean)</span> &ndash; True if screen should be enabled<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Enable or disable screen
<p>
</p>
<pre class='example'>
function init()
	SetScreenEnabled(FindScreen("tv"), true)
end

</pre>
<hr/>
<a name='IsScreenEnabled'></a><h3 class='function'>IsScreenEnabled</h3>
<pre class='funcdef'><span class='retname'>enabled = </span>IsScreenEnabled(<span class='argname'>screen</span>)</pre>
<p>Arguments<br/>
<span class='argname'>screen</span> <span class='argtype'>(number)</span> &ndash; Screen handle<br/>
<p>Return value<br/>
<span class='retname'>enabled</span> <span class='argtype'>(boolean)</span> &ndash; True if screen is enabled<br/>
<p><p>
</p>
<pre class='example'>
function init()
	local b = IsScreenEnabled(FindScreen("tv"))
	DebugPrint(b)
end

</pre>
<hr/>
<a name='GetScreenShape'></a><h3 class='function'>GetScreenShape</h3>
<pre class='funcdef'><span class='retname'>shape = </span>GetScreenShape(<span class='argname'>screen</span>)</pre>
<p>Arguments<br/>
<span class='argname'>screen</span> <span class='argtype'>(number)</span> &ndash; Screen handle<br/>
<p>Return value<br/>
<span class='retname'>shape</span> <span class='argtype'>(number)</span> &ndash; Shape handle or zero if none<br/>
<p>Return handle to the parent shape of a screen
<p>
</p>
<pre class='example'>
local screen = 0
function init()
	screen = FindScreen("tv")
	local shape = GetScreenShape(screen)
	DebugPrint(shape)
end

</pre>
<hr/>
<a name='FindVehicle'></a><h3 class='function'>FindVehicle</h3>
<pre class='funcdef'><span class='retname'>handle = </span>FindVehicle(<span class='argname'>[tag], [global]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>tag</span> <span class='argtype'>(string, optional)</span> &ndash; Tag name<br/>
<span class='argname'>global</span> <span class='argtype'>(boolean, optional)</span> &ndash; Search in entire scene<br/>
<p>Return value<br/>
<span class='retname'>handle</span> <span class='argtype'>(number)</span> &ndash; Handle to first vehicle with specified tag or zero if not found<br/>
<p><p>
</p>
<pre class='example'>
function init()
	local vehicle = FindVehicle("mycar")
end

</pre>
<hr/>
<a name='FindVehicles'></a><h3 class='function'>FindVehicles</h3>
<pre class='funcdef'><span class='retname'>list = </span>FindVehicles(<span class='argname'>[tag], [global]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>tag</span> <span class='argtype'>(string, optional)</span> &ndash; Tag name<br/>
<span class='argname'>global</span> <span class='argtype'>(boolean, optional)</span> &ndash; Search in entire scene<br/>
<p>Return value<br/>
<span class='retname'>list</span> <span class='argtype'>(table)</span> &ndash; Indexed table with handles to all vehicles with specified tag<br/>
<p><p>
</p>
<pre class='example'>
function init()
	--Find all vehicles in level tagged "boat"
	local boats = FindVehicles("boat")
	for i=1, #boats do
		local boat = boats[i]
		DebugPrint(boat)
	end
end

</pre>
<hr/>
<a name='GetVehicleTransform'></a><h3 class='function'>GetVehicleTransform</h3>
<pre class='funcdef'><span class='retname'>transform = </span>GetVehicleTransform(<span class='argname'>vehicle</span>)</pre>
<p>Arguments<br/>
<span class='argname'>vehicle</span> <span class='argtype'>(number)</span> &ndash; Vehicle handle<br/>
<p>Return value<br/>
<span class='retname'>transform</span> <span class='argtype'>(TTransform)</span> &ndash; Transform of vehicle<br/>
<p><p>
</p>
<pre class='example'>
function init()
	local vehicle = FindVehicle("vehicle")
	local t = GetVehicleTransform(vehicle)
end

</pre>
<hr/>
<a name='GetVehicleExhaustTransforms'></a><h3 class='function'>GetVehicleExhaustTransforms</h3>
<pre class='funcdef'><span class='retname'>transforms = </span>GetVehicleExhaustTransforms(<span class='argname'>vehicle</span>)</pre>
<p>Arguments<br/>
<span class='argname'>vehicle</span> <span class='argtype'>(number)</span> &ndash; Vehicle handle<br/>
<p>Return value<br/>
<span class='retname'>transforms</span> <span class='argtype'>(table)</span> &ndash; Transforms of vehicle exhausts<br/>
<p>Returns the exhausts transforms in local space of the vehicle.
<p>
</p>
<pre class='example'>
function tick()
	local vehicle = FindVehicle("car", true)
	local t = GetVehicleExhaustTransforms(vehicle)
	for i = 1, #t do
		DebugWatch(tostring(i), t[i])
	end
end

</pre>
<hr/>
<a name='GetVehicleVitalTransforms'></a><h3 class='function'>GetVehicleVitalTransforms</h3>
<pre class='funcdef'><span class='retname'>transforms = </span>GetVehicleVitalTransforms(<span class='argname'>vehicle</span>)</pre>
<p>Arguments<br/>
<span class='argname'>vehicle</span> <span class='argtype'>(number)</span> &ndash; Vehicle handle<br/>
<p>Return value<br/>
<span class='retname'>transforms</span> <span class='argtype'>(table)</span> &ndash; Transforms of vehicle vitals<br/>
<p>Returns the vitals transforms in local space of the vehicle.
<p>
</p>
<pre class='example'>
function tick()
	local vehicle = FindVehicle("car", true)
	local t = GetVehicleVitalTransforms(vehicle)
	for i = 1, #t do
		DebugWatch(tostring(i), t[i])
	end
end

</pre>
<hr/>
<a name='GetVehicleBodies'></a><h3 class='function'>GetVehicleBodies</h3>
<pre class='funcdef'><span class='retname'>transforms = </span>GetVehicleBodies(<span class='argname'>vehicle</span>)</pre>
<p>Arguments<br/>
<span class='argname'>vehicle</span> <span class='argtype'>(number)</span> &ndash; Vehicle handle<br/>
<p>Return value<br/>
<span class='retname'>transforms</span> <span class='argtype'>(table)</span> &ndash; Vehicle bodies handles<br/>
<p><p>
</p>
<pre class='example'>
function tick()
	local vehicle = FindVehicle("car", true)
	local t = GetVehicleBodies(vehicle)
	for i = 1, #t do
		DebugWatch(tostring(i), t[i])
	end
end

</pre>
<hr/>
<a name='GetVehicleBody'></a><h3 class='function'>GetVehicleBody</h3>
<pre class='funcdef'><span class='retname'>body = </span>GetVehicleBody(<span class='argname'>vehicle</span>)</pre>
<p>Arguments<br/>
<span class='argname'>vehicle</span> <span class='argtype'>(number)</span> &ndash; Vehicle handle<br/>
<p>Return value<br/>
<span class='retname'>body</span> <span class='argtype'>(number)</span> &ndash; Main body of vehicle<br/>
<p><p>
</p>
<pre class='example'>
function init()
	local vehicle = FindVehicle("vehicle")
	local body = GetVehicleBody(vehicle)
	if IsBodyBroken(body) then
		DebugPrint("Is broken")
	end
end

</pre>
<hr/>
<a name='GetVehicleHealth'></a><h3 class='function'>GetVehicleHealth</h3>
<pre class='funcdef'><span class='retname'>health = </span>GetVehicleHealth(<span class='argname'>vehicle</span>)</pre>
<p>Arguments<br/>
<span class='argname'>vehicle</span> <span class='argtype'>(number)</span> &ndash; Vehicle handle<br/>
<p>Return value<br/>
<span class='retname'>health</span> <span class='argtype'>(number)</span> &ndash; Vehicle health (zero to one)<br/>
<p><p>
</p>
<pre class='example'>
function init()
	local vehicle = FindVehicle("vehicle")
	local health = GetVehicleHealth(vehicle)
	DebugPrint(health)
end

</pre>
<hr/>
<a name='GetVehicleParams'></a><h3 class='function'>GetVehicleParams</h3>
<pre class='funcdef'><span class='retname'>params = </span>GetVehicleParams(<span class='argname'>vehicle</span>)</pre>
<p>Arguments<br/>
<span class='argname'>vehicle</span> <span class='argtype'>(number)</span> &ndash; Vehicle handle<br/>
<p>Return value<br/>
<span class='retname'>params</span> <span class='argtype'>(table)</span> &ndash; Vehicle params<br/>
<p><p>
</p>
<pre class='example'>
function tick()
	local params = GetVehicleParams(FindVehicle("car", true))
	for key, value in pairs(params) do
		DebugWatch(key, value)
	end
end

</pre>
<hr/>
<a name='SetVehicleParam'></a><h3 class='function'>SetVehicleParam</h3>
<pre class='funcdef'><span class='retname'></span>SetVehicleParam(<span class='argname'>handle, param, value</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Vehicle handler<br/>
<span class='argname'>param</span> <span class='argtype'>(string)</span> &ndash; Param name<br/>
<span class='argname'>value</span> <span class='argtype'>(number)</span> &ndash; Param value<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Available parameters: spring, damping, topspeed, acceleration, strength, antispin, antiroll, difflock, steerassist, friction
<p>
</p>
<pre class='example'>
function init()
	SetVehicleParam(FindVehicle("car", true), "topspeed", 200)
end

</pre>
<hr/>
<a name='GetVehicleDriverPos'></a><h3 class='function'>GetVehicleDriverPos</h3>
<pre class='funcdef'><span class='retname'>pos = </span>GetVehicleDriverPos(<span class='argname'>vehicle</span>)</pre>
<p>Arguments<br/>
<span class='argname'>vehicle</span> <span class='argtype'>(number)</span> &ndash; Vehicle handle<br/>
<p>Return value<br/>
<span class='retname'>pos</span> <span class='argtype'>(TVec)</span> &ndash; Driver position as vector in vehicle space<br/>
<p><p>
</p>
<pre class='example'>
function init()
	local vehicle = FindVehicle("vehicle")
	local driverPos = GetVehicleDriverPos(vehicle)
	local t = GetVehicleTransform(vehicle)
	local worldPos = TransformToParentPoint(t, driverPos)
	DebugPrint(worldPos)
end

</pre>
<hr/>
<a name='GetVehicleSteering'></a><h3 class='function'>GetVehicleSteering</h3>
<pre class='funcdef'><span class='retname'>steering = </span>GetVehicleSteering(<span class='argname'>vehicle</span>)</pre>
<p>Arguments<br/>
<span class='argname'>vehicle</span> <span class='argtype'>(number)</span> &ndash; Vehicle handle<br/>
<p>Return value<br/>
<span class='retname'>steering</span> <span class='argtype'>(number)</span> &ndash; Driver steering value -1 to 1<br/>
<p><p>
</p>
<pre class='example'>
local steering = GetVehicleSteering(vehicle)

</pre>
<hr/>
<a name='GetVehicleDrive'></a><h3 class='function'>GetVehicleDrive</h3>
<pre class='funcdef'><span class='retname'>drive = </span>GetVehicleDrive(<span class='argname'>vehicle</span>)</pre>
<p>Arguments<br/>
<span class='argname'>vehicle</span> <span class='argtype'>(number)</span> &ndash; Vehicle handle<br/>
<p>Return value<br/>
<span class='retname'>drive</span> <span class='argtype'>(number)</span> &ndash; Driver drive value -1 to 1<br/>
<p><p>
</p>
<pre class='example'>
local drive = GetVehicleDrive(vehicle)

</pre>
<hr/>
<a name='DriveVehicle'></a><h3 class='function'>DriveVehicle</h3>
<pre class='funcdef'><span class='retname'></span>DriveVehicle(<span class='argname'>vehicle, drive, steering, handbrake</span>)</pre>
<p>Arguments<br/>
<span class='argname'>vehicle</span> <span class='argtype'>(number)</span> &ndash; Vehicle handle<br/>
<span class='argname'>drive</span> <span class='argtype'>(number)</span> &ndash; Reverse/forward control -1 to 1<br/>
<span class='argname'>steering</span> <span class='argtype'>(number)</span> &ndash; Left/right control -1 to 1<br/>
<span class='argname'>handbrake</span> <span class='argtype'>(boolean)</span> &ndash; Handbrake control<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>This function applies input to vehicles, allowing for autonomous driving. The vehicle
will be turned on automatically and turned off when no longer called. Call this from
the tick function, not update.
<p>
</p>
<pre class='example'>
function tick()
	--Drive mycar forwards
	local v = FindVehicle("mycar")
	DriveVehicle(v, 1, 0, false)
end

</pre>
<hr/>
<a name='GetPlayerPos'></a><h3 class='function'>GetPlayerPos</h3>
<pre class='funcdef'><span class='retname'>position = </span>GetPlayerPos(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>position</span> <span class='argtype'>(TVec)</span> &ndash; Player center position<br/>
<p>Return center point of player. This function is deprecated. 
Use GetPlayerTransform instead.
<p>
</p>
<pre class='example'>
function init()
	local p = GetPlayerPos()
	DebugPrint(p)

	--This is equivalent to
	p = VecAdd(GetPlayerTransform().pos, Vec(0,1,0))
	DebugPrint(p)
end

</pre>
<hr/>
<a name='GetPlayerAimInfo'></a><h3 class='function'>GetPlayerAimInfo</h3>
<pre class='funcdef'><span class='retname'>hit, startpos, endpos, direction, hitnormal, hitdist, hitentity, hitmaterial = </span>GetPlayerAimInfo(<span class='argname'>position, [maxdist]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>position</span> <span class='argtype'>(TVec)</span> &ndash; Start position of the search<br/>
<span class='argname'>maxdist</span> <span class='argtype'>(number, optional)</span> &ndash; Max search distance<br/>
<p>Return value<br/>
<span class='retname'>hit</span> <span class='argtype'>(boolean)</span> &ndash; TRUE if hit, FALSE otherwise.<br/>
<span class='retname'>startpos</span> <span class='argtype'>(TVec)</span> &ndash; Player can modify start position when close to walls etc<br/>
<span class='retname'>endpos</span> <span class='argtype'>(TVec)</span> &ndash; Hit position<br/>
<span class='retname'>direction</span> <span class='argtype'>(TVec)</span> &ndash; Direction from start position to end position<br/>
<span class='retname'>hitnormal</span> <span class='argtype'>(TVec)</span> &ndash; Normal of the hitpoint<br/>
<span class='retname'>hitdist</span> <span class='argtype'>(number)</span> &ndash; Distance of the hit<br/>
<span class='retname'>hitentity</span> <span class='argtype'>(handle)</span> &ndash; Handle of the entitiy being hit<br/>
<span class='retname'>hitmaterial</span> <span class='argtype'>(handle)</span> &ndash; Name of the material being hit<br/>
<p><p>
</p>
<pre class='example'>
local muzzle = GetToolLocationWorldTransform("muzzle")
local _, pos, _, dir = GetPlayerAimInfo(muzzle.pos)
Shoot(pos, dir)

</pre>
<hr/>
<a name='GetPlayerPitch'></a><h3 class='function'>GetPlayerPitch</h3>
<pre class='funcdef'><span class='retname'>pitch = </span>GetPlayerPitch(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>pitch</span> <span class='argtype'>(number)</span> &ndash; Current player pitch angle<br/>
<p>The player pitch angle is applied to the player camera transform. This value can be used to animate tool pitch movement when using SetToolTransformOverride.
<p>
</p>
<pre class='example'>
function init()
	local pitchRotation = Quat(Vec(1,0,0), GetPlayerPitch())
end

</pre>
<hr/>
<a name='GetPlayerYaw'></a><h3 class='function'>GetPlayerYaw</h3>
<pre class='funcdef'><span class='retname'>yaw = </span>GetPlayerYaw(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>yaw</span> <span class='argtype'>(number)</span> &ndash; Current player yaw angle<br/>
<p>The player yaw angle is applied to the player camera transform. It represents the top-down angle of rotation of the player.
<p>
</p>
<pre class='example'>
function init()
	local compassBearing = GetPlayerYaw()
end

</pre>
<hr/>
<a name='SetPlayerPitch'></a><h3 class='function'>SetPlayerPitch</h3>
<pre class='funcdef'><span class='retname'></span>SetPlayerPitch(<span class='argname'>pitch</span>)</pre>
<p>Arguments<br/>
<span class='argname'>pitch</span> <span class='argtype'>(number)</span> &ndash; Pitch.<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Sets the player pitch.
<p>
</p>
<pre class='example'>
function tick()
	-- look straight ahead
	SetPlayerPitch(0.0)
end

</pre>
<hr/>
<a name='GetPlayerCrouch'></a><h3 class='function'>GetPlayerCrouch</h3>
<pre class='funcdef'><span class='retname'>recoil = </span>GetPlayerCrouch(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>recoil</span> <span class='argtype'>(number)</span> &ndash; Current player crouch<br/>
<p><p>
</p>
<pre class='example'>
function tick()
    local crouch = GetPlayerCrouch()
    if crouch > 0.0 then
        ...
    end
end

</pre>
<hr/>
<a name='GetPlayerTransform'></a><h3 class='function'>GetPlayerTransform</h3>
<pre class='funcdef'><span class='retname'>transform = </span>GetPlayerTransform(<span class='argname'>[includePitch]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>includePitch</span> <span class='argtype'>(boolean, optional)</span> &ndash; Include the player pitch (look up/down) in transform<br/>
<p>Return value<br/>
<span class='retname'>transform</span> <span class='argtype'>(TTransform)</span> &ndash; Current player transform<br/>
<p>The player transform is located at the bottom of the player. The player transform
considers heading (looking left and right). Forward is along negative Z axis.
Player pitch (looking up and down) does not affect player transform unless includePitch
is set to true. If you want the transform of the eye, use GetPlayerCameraTransform() instead.
<p>
</p>
<pre class='example'>
function init()
	local t = GetPlayerTransform()
	DebugPrint(TransformStr(t))
end

</pre>
<hr/>
<a name='SetPlayerTransform'></a><h3 class='function'>SetPlayerTransform</h3>
<pre class='funcdef'><span class='retname'></span>SetPlayerTransform(<span class='argname'>transform, [includePitch]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>transform</span> <span class='argtype'>(TTransform)</span> &ndash; Desired player transform<br/>
<span class='argname'>includePitch</span> <span class='argtype'>(boolean, optional)</span> &ndash; Set player pitch (look up/down) as well<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Instantly teleport the player to desired transform. Unless includePitch is
set to true, up/down look angle will be set to zero during this process.
Player velocity will be reset to zero.
<p>
</p>
<pre class='example'>
function tick()
	if InputPressed("jump") then
		local t = Transform(Vec(50, 0, 0), QuatEuler(0, 90, 0))
		SetPlayerTransform(t)
	end
end

</pre>
<hr/>
<a name='ClearPlayerRig'></a><h3 class='function'>ClearPlayerRig</h3>
<pre class='funcdef'><span class='retname'></span>ClearPlayerRig(<span class='argname'>rig-id</span>)</pre>
<p>Arguments<br/>
<span class='argname'>rig-id</span> <span class='argtype'>(number)</span> &ndash; Unique rig-id, -1 means all rigs<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p><p>
</p>
<pre class='example'>
    --Clear specific rig
    ClearPlayerRig(someId)
    
    --Clear all rigs
    ClearPlayerRig(-1)

</pre>
<hr/>
<a name='SetPlayerRigLocationLocalTransform'></a><h3 class='function'>SetPlayerRigLocationLocalTransform</h3>
<pre class='funcdef'><span class='retname'></span>SetPlayerRigLocationLocalTransform(<span class='argname'>rig-id, name, location</span>)</pre>
<p>Arguments<br/>
<span class='argname'>rig-id</span> <span class='argtype'>(number)</span> &ndash; Unique id<br/>
<span class='argname'>name</span> <span class='argtype'>(string)</span> &ndash; Name of location<br/>
<span class='argname'>location</span> <span class='argtype'>(table)</span> &ndash; Rig Local transform of the location<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p><p>
</p>
<pre class='example'>
    local someBody = FindBody("bodyname")
    SetPlayerRigLocationLocalTransform(someBody, "ik_foot_l", TransformToLocalTransform(GetBodyTransform(someBody), GetLocationTransform(FindLocation("ik_foot_l"))))

</pre>
<hr/>
<a name='SetPlayerRigTransform'></a><h3 class='function'>SetPlayerRigTransform</h3>
<pre class='funcdef'><span class='retname'></span>SetPlayerRigTransform(<span class='argname'>rig-id, location</span>)</pre>
<p>Arguments<br/>
<span class='argname'>rig-id</span> <span class='argtype'>(number)</span> &ndash; Unique id<br/>
<span class='argname'>location</span> <span class='argtype'>(table)</span> &ndash; New world transform<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>This will both update the rig identified by the 'id' and make it active
<p>
</p>
<pre class='example'>
    local someBody = FindBody("bodyname")
    SetPlayerRigTransform(someBody, GetBodyTransform(someBody))

</pre>
<hr/>
<a name='GetPlayerRigTransform'></a><h3 class='function'>GetPlayerRigTransform</h3>
<pre class='funcdef'><span class='retname'>location = </span>GetPlayerRigTransform(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>location</span> <span class='argtype'>(table)</span> &ndash; Transform of the current active player-rig, nil otherwise<br/>
<p><p>
</p>
<hr/>
<a name='GetPlayerRigLocationWorldTransform'></a><h3 class='function'>GetPlayerRigLocationWorldTransform</h3>
<pre class='funcdef'><span class='retname'>location = </span>GetPlayerRigLocationWorldTransform(<span class='argname'>name</span>)</pre>
<p>Arguments<br/>
<span class='argname'>name</span> <span class='argtype'>(string)</span> &ndash; Name of location<br/>
<p>Return value<br/>
<span class='retname'>location</span> <span class='argtype'>(table)</span> &ndash; Transform of a location in world space<br/>
<p><p>
</p>
<pre class='example'>
local t = GetPlayerRigLocationWorldTransform("ik_hand_l")

</pre>
<hr/>
<a name='SetPlayerRigTags'></a><h3 class='function'>SetPlayerRigTags</h3>
<pre class='funcdef'><span class='retname'></span>SetPlayerRigTags(<span class='argname'>tag, [value]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>tag</span> <span class='argtype'>(string)</span> &ndash; Tag name<br/>
<span class='argname'>value</span> <span class='argtype'>(string, optional)</span> &ndash; Tag value<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p><p>
</p>
<hr/>
<a name='GetPlayerRigHasTag'></a><h3 class='function'>GetPlayerRigHasTag</h3>
<pre class='funcdef'><span class='retname'>exists = </span>GetPlayerRigHasTag(<span class='argname'>tag</span>)</pre>
<p>Arguments<br/>
<span class='argname'>tag</span> <span class='argtype'>(string)</span> &ndash; Tag name<br/>
<p>Return value<br/>
<span class='retname'>exists</span> <span class='argtype'>(boolean)</span> &ndash; Returns true if entity has tag<br/>
<p><p>
</p>
<hr/>
<a name='GetPlayerRigTagValue'></a><h3 class='function'>GetPlayerRigTagValue</h3>
<pre class='funcdef'><span class='retname'>value = </span>GetPlayerRigTagValue(<span class='argname'>tag</span>)</pre>
<p>Arguments<br/>
<span class='argname'>tag</span> <span class='argtype'>(string)</span> &ndash; Tag name<br/>
<p>Return value<br/>
<span class='retname'>value</span> <span class='argtype'>(string)</span> &ndash; Returns the tag value, if any. Empty string otherwise.<br/>
<p><p>
</p>
<hr/>
<a name='SetPlayerGroundVelocity'></a><h3 class='function'>SetPlayerGroundVelocity</h3>
<pre class='funcdef'><span class='retname'></span>SetPlayerGroundVelocity(<span class='argname'>vel</span>)</pre>
<p>Arguments<br/>
<span class='argname'>vel</span> <span class='argtype'>(TVec)</span> &ndash; Desired ground velocity<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Make the ground act as a conveyor belt, pushing the player even if ground shape is static.
<p>
</p>
<pre class='example'>
function tick()
	SetPlayerGroundVelocity(Vec(2,0,0))
end

</pre>
<hr/>
<a name='GetPlayerEyeTransform'></a><h3 class='function'>GetPlayerEyeTransform</h3>
<pre class='funcdef'><span class='retname'>transform = </span>GetPlayerEyeTransform(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>transform</span> <span class='argtype'>(TTransform)</span> &ndash; Current player eye transform<br/>
<p>The player eye transform is the same as what you get from GetCameraTransform when playing in first-person,
but if you have set a camera transform manually with SetCameraTransform or playing in third-person, you can retrieve
the player eye transform with this function.
<p>
</p>
<pre class='example'>
function init()
	local t = GetPlayerEyeTransform()
	DebugPrint(TransformStr(t))
end

</pre>
<hr/>
<a name='GetPlayerCameraTransform'></a><h3 class='function'>GetPlayerCameraTransform</h3>
<pre class='funcdef'><span class='retname'>transform = </span>GetPlayerCameraTransform(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>transform</span> <span class='argtype'>(TTransform)</span> &ndash; Current player camera transform<br/>
<p>The player camera transform is usually the same as what you get from GetCameraTransform,
but if you have set a camera transform manually with SetCameraTransform, you can retrieve
the standard player camera transform with this function.
<p>
</p>
<pre class='example'>
function init()
	local t = GetPlayerCameraTransform()
	DebugPrint(TransformStr(t))
end

</pre>
<hr/>
<a name='SetPlayerCameraOffsetTransform'></a><h3 class='function'>SetPlayerCameraOffsetTransform</h3>
<pre class='funcdef'><span class='retname'></span>SetPlayerCameraOffsetTransform(<span class='argname'>transform, [stackable]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>transform</span> <span class='argtype'>(TTransform)</span> &ndash; Desired player camera offset transform<br/>
<span class='argname'>stackable</span> <span class='argtype'>(boolean, optional)</span> &ndash; True if eye offset should summ up with multiple calls per tick<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Call this function continously to apply a camera offset. Can be used for camera effects 
such as shake and wobble.
<p>
</p>
<pre class='example'>
function tick()
	local t = Transform(Vec(), QuatAxisAngle(Vec(1, 0, 0), math.sin(GetTime()*3.0) * 3.0))
	SetPlayerCameraOffsetTransform(t)
end

</pre>
<hr/>
<a name='SetPlayerSpawnTransform'></a><h3 class='function'>SetPlayerSpawnTransform</h3>
<pre class='funcdef'><span class='retname'></span>SetPlayerSpawnTransform(<span class='argname'>transform</span>)</pre>
<p>Arguments<br/>
<span class='argname'>transform</span> <span class='argtype'>(TTransform)</span> &ndash; Desired player spawn transform<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Call this function during init to alter the player spawn transform.
<p>
</p>
<pre class='example'>
function init()
	local t = Transform(Vec(10, 0, 0), QuatEuler(0, 90, 0))
	SetPlayerSpawnTransform(t)
end

</pre>
<hr/>
<a name='SetPlayerSpawnHealth'></a><h3 class='function'>SetPlayerSpawnHealth</h3>
<pre class='funcdef'><span class='retname'></span>SetPlayerSpawnHealth(<span class='argname'>health</span>)</pre>
<p>Arguments<br/>
<span class='argname'>health</span> <span class='argtype'>(number)</span> &ndash; Desired player spawn health (between zero and one)<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Call this function during init to alter the player spawn health amount.
<p>
</p>
<pre class='example'>
function init()
	SetPlayerSpawnHealth(0.5)
end

</pre>
<hr/>
<a name='SetPlayerSpawnTool'></a><h3 class='function'>SetPlayerSpawnTool</h3>
<pre class='funcdef'><span class='retname'></span>SetPlayerSpawnTool(<span class='argname'>id</span>)</pre>
<p>Arguments<br/>
<span class='argname'>id</span> <span class='argtype'>(string)</span> &ndash; Tool unique identifier<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Call this function during init to alter the player spawn active tool.
<p>
</p>
<pre class='example'>
function init()
	SetPlayerSpawnTool("pistol")
end

</pre>
<hr/>
<a name='GetPlayerVelocity'></a><h3 class='function'>GetPlayerVelocity</h3>
<pre class='funcdef'><span class='retname'>velocity = </span>GetPlayerVelocity(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>velocity</span> <span class='argtype'>(TVec)</span> &ndash; Player velocity in world space as vector<br/>
<p><p>
</p>
<pre class='example'>
function tick()
	local vel = GetPlayerVelocity()
	DebugPrint(VecStr(vel))
end

</pre>
<hr/>
<a name='SetPlayerVehicle'></a><h3 class='function'>SetPlayerVehicle</h3>
<pre class='funcdef'><span class='retname'></span>SetPlayerVehicle(<span class='argname'>vehicle</span>)</pre>
<p>Arguments<br/>
<span class='argname'>vehicle</span> <span class='argtype'>(number)</span> &ndash; Handle to vehicle or zero to not drive.<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Drive specified vehicle.
<p>
</p>
<pre class='example'>
function tick()
	if InputPressed("interact") then
		local car = FindVehicle("mycar")
		SetPlayerVehicle(car)
	end
end

</pre>
<hr/>
<a name='SetPlayerAnimator'></a><h3 class='function'>SetPlayerAnimator</h3>
<pre class='funcdef'><span class='retname'></span>SetPlayerAnimator(<span class='argname'>animator</span>)</pre>
<p>Arguments<br/>
<span class='argname'>animator</span> <span class='argtype'>(number)</span> &ndash; Handle to animator or zero for no animator<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p><p>
</p>
<hr/>
<a name='GetPlayerAnimator'></a><h3 class='function'>GetPlayerAnimator</h3>
<pre class='funcdef'><span class='retname'>animator = </span>GetPlayerAnimator(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>animator</span> <span class='argtype'>(number)</span> &ndash; Handle to animator or zero for no animator<br/>
<p><p>
</p>
<hr/>
<a name='SetPlayerVelocity'></a><h3 class='function'>SetPlayerVelocity</h3>
<pre class='funcdef'><span class='retname'></span>SetPlayerVelocity(<span class='argname'>velocity</span>)</pre>
<p>Arguments<br/>
<span class='argname'>velocity</span> <span class='argtype'>(TVec)</span> &ndash; Player velocity in world space as vector<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p><p>
</p>
<pre class='example'>
function tick()
	if InputPressed("jump") then
		SetPlayerVelocity(Vec(0, 5, 0)) 
	end
end

</pre>
<hr/>
<a name='GetPlayerVehicle'></a><h3 class='function'>GetPlayerVehicle</h3>
<pre class='funcdef'><span class='retname'>handle = </span>GetPlayerVehicle(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>handle</span> <span class='argtype'>(number)</span> &ndash; Current vehicle handle, or zero if not in vehicle<br/>
<p><p>
</p>
<pre class='example'>
function tick()
	local vehicle = GetPlayerVehicle()
	if vehicle ~= 0 then
		DebugPrint("Player drives the vehicle")
	end
end

</pre>
<hr/>
<a name='IsPlayerGrounded'></a><h3 class='function'>IsPlayerGrounded</h3>
<pre class='funcdef'><span class='retname'>isGrounded = </span>IsPlayerGrounded(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>isGrounded</span> <span class='argtype'>(boolean)</span> &ndash; Whether the player is grounded<br/>
<p><p>
</p>
<pre class='example'>
local isGrounded = IsPlayerGrounded()

</pre>
<hr/>
<a name='GetPlayerGroundContact'></a><h3 class='function'>GetPlayerGroundContact</h3>
<pre class='funcdef'><span class='retname'>contact, shape, point, normal = </span>GetPlayerGroundContact(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>contact</span> <span class='argtype'>(boolean)</span> &ndash; Whether the player is grounded<br/>
<span class='retname'>shape</span> <span class='argtype'>(number)</span> &ndash; Handle to shape<br/>
<span class='retname'>point</span> <span class='argtype'>(Vec)</span> &ndash; Point of contact<br/>
<span class='retname'>normal</span> <span class='argtype'>(Vec)</span> &ndash; Normal of contact<br/>
<p><p>
Get information about player ground contact. If the output boolean (contact) is false then
the rest of the output is invalid.
<p>
<p>
</p>
<pre class='example'>
function tick()
	hasGroundContact, shape, point, normal = GetPlayerGroundContact()

	if hasGroundContact then
		-- print ground contact data
		DebugPrint(VecStr(point).." : "..VecStr(normal))
	end
end

</pre>
<hr/>
<a name='GetPlayerGrabShape'></a><h3 class='function'>GetPlayerGrabShape</h3>
<pre class='funcdef'><span class='retname'>handle = </span>GetPlayerGrabShape(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>handle</span> <span class='argtype'>(number)</span> &ndash; Handle to grabbed shape or zero if not grabbing.<br/>
<p><p>
</p>
<pre class='example'>
function tick()
	local shape = GetPlayerGrabShape()
	if shape ~= 0 then
		DebugPrint("Player is grabbing a shape")
	end
end

</pre>
<hr/>
<a name='GetPlayerGrabBody'></a><h3 class='function'>GetPlayerGrabBody</h3>
<pre class='funcdef'><span class='retname'>handle = </span>GetPlayerGrabBody(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>handle</span> <span class='argtype'>(number)</span> &ndash; Handle to grabbed body or zero if not grabbing.<br/>
<p><p>
</p>
<pre class='example'>
function tick()
	local body = GetPlayerGrabBody()
	if body ~= 0 then
		DebugPrint("Player is grabbing a body")
	end
end

</pre>
<hr/>
<a name='ReleasePlayerGrab'></a><h3 class='function'>ReleasePlayerGrab</h3>
<pre class='funcdef'><span class='retname'></span>ReleasePlayerGrab(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Release what the player is currently holding
<p>
</p>
<pre class='example'>
function tick()
	if InputPressed("jump") then
		ReleasePlayerGrab()
	end
end

</pre>
<hr/>
<a name='GetPlayerGrabPoint'></a><h3 class='function'>GetPlayerGrabPoint</h3>
<pre class='funcdef'><span class='retname'>pos = </span>GetPlayerGrabPoint(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>pos</span> <span class='argtype'>(TVec)</span> &ndash; The world space grab point.<br/>
<p><p>
</p>
<pre class='example'>
local body = GetPlayerGrabBody()
if body ~= 0 then
	local pos = GetPlayerGrabPoint()
end

</pre>
<hr/>
<a name='GetPlayerPickShape'></a><h3 class='function'>GetPlayerPickShape</h3>
<pre class='funcdef'><span class='retname'>handle = </span>GetPlayerPickShape(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>handle</span> <span class='argtype'>(number)</span> &ndash; Handle to picked shape or zero if nothing is picked<br/>
<p><p>
</p>
<pre class='example'>
function tick()
	local shape = GetPlayerPickShape()
	if shape ~= 0 then
		DebugPrint("Picked shape " .. shape)
	end
end

</pre>
<hr/>
<a name='GetPlayerPickBody'></a><h3 class='function'>GetPlayerPickBody</h3>
<pre class='funcdef'><span class='retname'>handle = </span>GetPlayerPickBody(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>handle</span> <span class='argtype'>(number)</span> &ndash; Handle to picked body or zero if nothing is picked<br/>
<p><p>
</p>
<pre class='example'>
function tick()
	local body = GetPlayerPickBody()
	if body ~= 0 then
		DebugWatch("Pick body ", body)
	end
end

</pre>
<hr/>
<a name='GetPlayerInteractShape'></a><h3 class='function'>GetPlayerInteractShape</h3>
<pre class='funcdef'><span class='retname'>handle = </span>GetPlayerInteractShape(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>handle</span> <span class='argtype'>(number)</span> &ndash; Handle to interactable shape or zero<br/>
<p>Interactable shapes has to be tagged with "interact". The engine
determines which interactable shape is currently interactable.
<p>
</p>
<pre class='example'>
function tick()
	local shape = GetPlayerInteractShape()
	if shape ~= 0 then
		DebugPrint("Interact shape " .. shape)
	end
end

</pre>
<hr/>
<a name='GetPlayerInteractBody'></a><h3 class='function'>GetPlayerInteractBody</h3>
<pre class='funcdef'><span class='retname'>handle = </span>GetPlayerInteractBody(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>handle</span> <span class='argtype'>(number)</span> &ndash; Handle to interactable body or zero<br/>
<p>Interactable shapes has to be tagged with "interact". The engine
determines which interactable body is currently interactable.
<p>
</p>
<pre class='example'>
function tick()
	local body = GetPlayerInteractBody()
	if body ~= 0 then
		DebugPrint("Interact body " .. body)
	end
end

</pre>
<hr/>
<a name='SetPlayerScreen'></a><h3 class='function'>SetPlayerScreen</h3>
<pre class='funcdef'><span class='retname'></span>SetPlayerScreen(<span class='argname'>handle</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Handle to screen or zero for no screen<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Set the screen the player should interact with. For the screen
to feature a mouse pointer and receieve input, the screen also
needs to have interactive property.
<p>
</p>
<pre class='example'>
function tick()
	if InputPressed("interact") then
		if GetPlayerScreen() ~= 0 then
			SetPlayerScreen(0)
		else
			SetPlayerScreen(screen)
		end

	end
end

</pre>
<hr/>
<a name='GetPlayerScreen'></a><h3 class='function'>GetPlayerScreen</h3>
<pre class='funcdef'><span class='retname'>handle = </span>GetPlayerScreen(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>handle</span> <span class='argtype'>(number)</span> &ndash; Handle to interacted screen or zero if none<br/>
<p><p>
</p>
<pre class='example'>
function tick()
	if InputPressed("interact") then
		if GetPlayerScreen() ~= 0 then
			SetPlayerScreen(0)
		else
			SetPlayerScreen(screen)
		end

	end
end

</pre>
<hr/>
<a name='SetPlayerHealth'></a><h3 class='function'>SetPlayerHealth</h3>
<pre class='funcdef'><span class='retname'></span>SetPlayerHealth(<span class='argname'>health</span>)</pre>
<p>Arguments<br/>
<span class='argname'>health</span> <span class='argtype'>(number)</span> &ndash; Set player health (between zero and one)<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p><p>
</p>
<pre class='example'>
function tick()
	if InputPressed("interact") then
		if GetPlayerHealth() < 0.75 then
			SetPlayerHealth(1.0)
		else
			SetPlayerHealth(0.5)
		end
	end
end

</pre>
<hr/>
<a name='GetPlayerHealth'></a><h3 class='function'>GetPlayerHealth</h3>
<pre class='funcdef'><span class='retname'>health = </span>GetPlayerHealth(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>health</span> <span class='argtype'>(number)</span> &ndash; Current player health<br/>
<p><p>
</p>
<pre class='example'>
function tick()
	if InputPressed("interact") then
		if GetPlayerHealth() < 0.75 then
			SetPlayerHealth(1.0)
		else
			SetPlayerHealth(0.5)
		end
	end
end

</pre>
<hr/>
<a name='SetPlayerRegenerationState'></a><h3 class='function'>SetPlayerRegenerationState</h3>
<pre class='funcdef'><span class='retname'></span>SetPlayerRegenerationState(<span class='argname'>state</span>)</pre>
<p>Arguments<br/>
<span class='argname'>state</span> <span class='argtype'>(boolean)</span> &ndash; State of player regeneration<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Enable or disable regeneration for player
<p>
</p>
<pre class='example'>
function init()
	-- disable regeneration for player
	SetPlayerRegenerationState(false)
end

</pre>
<hr/>
<a name='RespawnPlayer'></a><h3 class='function'>RespawnPlayer</h3>
<pre class='funcdef'><span class='retname'></span>RespawnPlayer(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Respawn player at spawn position without modifying the scene
<p>
</p>
<pre class='example'>
function tick()
	if InputPressed("interact") then
		RespawnPlayer()
	end
end

</pre>
<hr/>
<a name='GetPlayerWalkingSpeed'></a><h3 class='function'>GetPlayerWalkingSpeed</h3>
<pre class='funcdef'><span class='retname'>speed = </span>GetPlayerWalkingSpeed(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>speed</span> <span class='argtype'>(number)</span> &ndash; Current player base walking speed<br/>
<p>This function gets base speed, but real player speed depends on many
factors such as health, crouch, water, grabbing objects.
<p>
</p>
<pre class='example'>
function tick()
	DebugPrint(GetPlayerWalkingSpeed())
end

</pre>
<hr/>
<a name='SetPlayerWalkingSpeed'></a><h3 class='function'>SetPlayerWalkingSpeed</h3>
<pre class='funcdef'><span class='retname'></span>SetPlayerWalkingSpeed(<span class='argname'>speed</span>)</pre>
<p>Arguments<br/>
<span class='argname'>speed</span> <span class='argtype'>(number)</span> &ndash; Set player base walking speed<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>This function sets base speed, but real player speed depends on many
factors such as health, crouch, water, grabbing objects. 
<p>
</p>
<pre class='example'>
function tick()
	if InputDown("shift") then
		SetPlayerWalkingSpeed(15.0)
	else
		SetPlayerWalkingSpeed(7.0)
	end
end

</pre>
<hr/>
<a name='GetPlayerParam'></a><h3 class='function'>GetPlayerParam</h3>
<pre class='funcdef'><span class='retname'>value = </span>GetPlayerParam(<span class='argname'>parameter</span>)</pre>
<p>Arguments<br/>
<span class='argname'>parameter</span> <span class='argtype'>(string)</span> &ndash; Parameter name<br/>
<p>Return value<br/>
<span class='retname'>value</span> <span class='argtype'>(any)</span> &ndash; Parameter value<br/>
<p><table border=0><tr><td class='header'>&nbsp;Param&nbsp;name	</td><td class='header'>&nbsp;Type				</td><td class='header'>&nbsp;Description</td></tr>
<tr><td class='first' valign='top'>health					</td><td valign='top'> float			</td><td valign='top'> Current value of the player's health.</td></tr><tr><td class='first' valign='top'>healthRegeneration&nbsp;&nbsp;	</td><td valign='top'> boolean &nbsp	</td><td valign='top'> Is the player's health regeneration enabled.</td></tr><tr><td class='first' valign='top'>walkingSpeed			</td><td valign='top'> float			</td><td valign='top'> The player's walking speed.</td></tr><tr><td class='first' valign='top'>jumpSpeed				</td><td valign='top'> float			</td><td valign='top'> The player's jump speed.</td></tr><tr><td class='first' valign='top'>godMode					</td><td valign='top'> boolean &nbsp	</td><td valign='top'> If the value is True, the player does not lose health</td></tr><tr><td class='first' valign='top'>friction				</td><td valign='top'> float			</td><td valign='top'> Player body friction</td></tr><tr><td class='first' valign='top'>frictionMode			</td><td valign='top'> string			</td><td valign='top'> Player friction combine mode</td></tr><tr><td class='first' valign='top'>flyMode					</td><td valign='top'> boolean &nbsp	</td><td valign='top'> If the value is True, the player will fly</td></tr><table/>
<p>
</p>
<pre class='example'>
function tick()
	-- The parameter names are case-insensitive, so any of the specified writing styles will be correct:
	-- "GodMode", "godmode", "godMode"
	local paramName = "GodMode"
	local param = GetPlayerParam(paramName)
	DebugWatch(paramName, param)

	if InputPressed("g") then
		SetPlayerParam(paramName, not param)
	end
end

</pre>
<hr/>
<a name='SetPlayerParam'></a><h3 class='function'>SetPlayerParam</h3>
<pre class='funcdef'><span class='retname'></span>SetPlayerParam(<span class='argname'>parameter, value</span>)</pre>
<p>Arguments<br/>
<span class='argname'>parameter</span> <span class='argtype'>(string)</span> &ndash; Parameter name<br/>
<span class='argname'>value</span> <span class='argtype'>(any)</span> &ndash; Parameter value<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p><table border=0><tr><td class='header'>&nbsp;Param&nbsp;name	</td><td class='header'>&nbsp;Type				</td><td class='header'>&nbsp;Description</td></tr>
<tr><td class='first' valign='top'>health					</td><td valign='top'> float			</td><td valign='top'> Current value of the player's health.</td></tr><tr><td class='first' valign='top'>healthRegeneration&nbsp;&nbsp;	</td><td valign='top'> boolean &nbsp	</td><td valign='top'> Is the player's health regeneration enabled.</td></tr><tr><td class='first' valign='top'>walkingSpeed			</td><td valign='top'> float			</td><td valign='top'> The player's walking speed. <b> This value is applied for 1 frame! </b></td></tr><tr><td class='first' valign='top'>jumpSpeed				</td><td valign='top'> float			</td><td valign='top'> The player's jump speed. The height of the jump depends non-linearly on the jump speed. <b> This value is applied for 1 frame! </b></td></tr><tr><td class='first' valign='top'>godMode					</td><td valign='top'> boolean &nbsp	</td><td valign='top'> If the value is True, the player does not lose health</td></tr><tr><td class='first' valign='top'>friction				</td><td valign='top'> float			</td><td valign='top'> Player body friction. Default is 0.8</td></tr><tr><td class='first' valign='top'>frictionMode			</td><td valign='top'> string			</td><td valign='top'> Player friction combine mode. Can be (average|minimum|multiply|maximum)</td></tr><tr><td class='first' valign='top'>flyMode					</td><td valign='top'> boolean &nbsp	</td><td valign='top'> If the value is True, the player will fly</td></tr><table/>
<p>
</p>
<pre class='example'>
function tick()
	-- The parameter names are case-insensitive, so any of the specified writing styles will be correct:
	-- "JumpSpeed", "jumpspeed", "jumpSpeed"
	local paramName = "JumpSpeed"
	local param = GetPlayerParam(paramName)
	DebugWatch(paramName, param)

	if InputDown("shift") then
		-- JumpSpeed sets for 1 frame
		SetPlayerParam(paramName, 10)
	end
end

</pre>
<hr/>
<a name='SetPlayerHidden'></a><h3 class='function'>SetPlayerHidden</h3>
<pre class='funcdef'><span class='retname'></span>SetPlayerHidden(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>none</span>
<p><p>
Use this function to hide the player character.
<p>
<p>
</p>
<pre class='example'>

function tick()
	...
	SetCameraTransform(t)
	SetPlayerHidden()
end

</pre>
<hr/>
<a name='RegisterTool'></a><h3 class='function'>RegisterTool</h3>
<pre class='funcdef'><span class='retname'></span>RegisterTool(<span class='argname'>id, name, file, [group]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>id</span> <span class='argtype'>(string)</span> &ndash; Tool unique identifier<br/>
<span class='argname'>name</span> <span class='argtype'>(string)</span> &ndash; Tool name to show in hud<br/>
<span class='argname'>file</span> <span class='argtype'>(string)</span> &ndash; Path to vox file or prefab xml<br/>
<span class='argname'>group</span> <span class='argtype'>(number, optional)</span> &ndash; Tool group for this tool (1-6) Default is 6.<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Register a custom tool that will show up in the player inventory and 
can be selected with scroll wheel. Do this only once per tool.
You also need to enable the tool in the registry before it can be used. 
<p>
</p>
<pre class='example'>
function init()
	RegisterTool("lasergun", "Laser Gun", "MOD/vox/lasergun.vox")
	SetBool("game.tool.lasergun.enabled", true)
end

function tick()
	if GetString("game.player.tool") == "lasergun" then
		--Tool is selected. Tool logic goes here.
	end
end

</pre>
<hr/>
<a name='GetToolBody'></a><h3 class='function'>GetToolBody</h3>
<pre class='funcdef'><span class='retname'>handle = </span>GetToolBody(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>handle</span> <span class='argtype'>(number)</span> &ndash; Handle to currently visible tool body or zero if none<br/>
<p>Return body handle of the visible tool. You can use this to retrieve tool shapes
and animate them, change emissiveness, etc. Do not attempt to set the tool body
transform, since it is controlled by the engine. Use SetToolTranform for that.
<p>
</p>
<pre class='example'>
function tick()
	local toolBody = GetToolBody()
	if toolBody~=0 then
		DebugPrint("Tool body: " .. toolBody)
	end
end

</pre>
<hr/>
<a name='GetToolHandPoseLocalTransform'></a><h3 class='function'>GetToolHandPoseLocalTransform</h3>
<pre class='funcdef'><span class='retname'>right, left = </span>GetToolHandPoseLocalTransform(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>right</span> <span class='argtype'>(TTransform)</span> &ndash; Transform of right hand relative to the tool body origin, or nil if the right hand is not used<br/>
<span class='retname'>left</span> <span class='argtype'>(TTransform)</span> &ndash; Transform of left hand, or nil if left hand is not used<br/>
<p><p>
</p>
<pre class='example'>
local right, left = GetToolHandPoseLocalTransform()

</pre>
<hr/>
<a name='GetToolHandPoseWorldTransform'></a><h3 class='function'>GetToolHandPoseWorldTransform</h3>
<pre class='funcdef'><span class='retname'>right, left = </span>GetToolHandPoseWorldTransform(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>right</span> <span class='argtype'>(TTransform)</span> &ndash; Transform of right hand in world space, or nil if the right hand is not used<br/>
<span class='retname'>left</span> <span class='argtype'>(TTransform)</span> &ndash; Transform of left hand, or nil if left hand is not used<br/>
<p><p>
</p>
<pre class='example'>
local right, left = GetToolHandPoseWorldTransform()

</pre>
<hr/>
<a name='SetToolHandPoseLocalTransform'></a><h3 class='function'>SetToolHandPoseLocalTransform</h3>
<pre class='funcdef'><span class='retname'></span>SetToolHandPoseLocalTransform(<span class='argname'>right, left</span>)</pre>
<p>Arguments<br/>
<span class='argname'>right</span> <span class='argtype'>(TTransform)</span> &ndash; Transform of right hand relative to the tool body origin, or nil if right hand is not used<br/>
<span class='argname'>left</span> <span class='argtype'>(TTransform)</span> &ndash; Transform of left hand, or nil if left hand is not used<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Use this function to position the character's hands on the currently equipped tool. This function must be called every frame from the tick function. 
In third-person view, failing to call this function can lead to different outcomes depending on how the tool is animated:
<ul>
<li>If the tool's transform is not explicitly set or is set using SetToolTransform, not calling this function will trigger a fallback solution where the right hand is automatically positioned.</li>
<li>If the tool is animated using the SetToolTransformOverride function, not calling this function will result in the character's animation taking control of the hand movement</li>
</ul>
<p>
<p>
</p>
<pre class='example'>
if GetBool("game.thirdperson") then
	if aiming then
		SetToolHandPoseLocalTransform(Transform(Vec(0.2,0.0,0.0), QuatAxisAngle(Vec(0,1,0), 90.0)), Transform(Vec(-0.1, 0.0, -0.4)))
	else
		SetToolHandPoseLocalTransform(Transform(Vec(0.2,0.0,0.0), QuatAxisAngle(Vec(0,1,0), 90.0)), nil)
	end
end

</pre>
<hr/>
<a name='GetToolLocationLocalTransform'></a><h3 class='function'>GetToolLocationLocalTransform</h3>
<pre class='funcdef'><span class='retname'>location = </span>GetToolLocationLocalTransform(<span class='argname'>name</span>)</pre>
<p>Arguments<br/>
<span class='argname'>name</span> <span class='argtype'>(string)</span> &ndash; Name of location<br/>
<p>Return value<br/>
<span class='retname'>location</span> <span class='argtype'>(TTransform)</span> &ndash; Transform of a tool location in tool space or nil if location is not found.<br/>
<p>Return transform of a tool location in tool space. Locations can be defined using the tool prefab editor.
<p>
</p>
<pre class='example'>
local right  = GetToolLocationLocalTransform("righthand")
SetToolHandPoseLocalTransform(right, nil)

</pre>
<hr/>
<a name='GetToolLocationWorldTransform'></a><h3 class='function'>GetToolLocationWorldTransform</h3>
<pre class='funcdef'><span class='retname'>location = </span>GetToolLocationWorldTransform(<span class='argname'>name</span>)</pre>
<p>Arguments<br/>
<span class='argname'>name</span> <span class='argtype'>(string)</span> &ndash; Name of location<br/>
<p>Return value<br/>
<span class='retname'>location</span> <span class='argtype'>(TTransform)</span> &ndash; Transform of a tool location in world space or nil if the location is not found or if there is no visible tool body.<br/>
<p>Return transform of a tool location in world space. Locations can be defined using the tool prefab editor. A tool location is defined in tool space and to get the world space transform a tool body is required. 
If a tool body does not exist this function will return nil.
<p>
</p>
<pre class='example'>
local muzzle = GetToolLocationWorldTransform("muzzle")
Shoot(muzzle, direction)

</pre>
<hr/>
<a name='SetToolTransform'></a><h3 class='function'>SetToolTransform</h3>
<pre class='funcdef'><span class='retname'></span>SetToolTransform(<span class='argname'>transform, [sway]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>transform</span> <span class='argtype'>(TTransform)</span> &ndash; Tool body transform<br/>
<span class='argname'>sway</span> <span class='argtype'>(number, optional)</span> &ndash; Tool sway amount. Default is 1.0.<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Apply an additional transform on the visible tool body. This can be used to
create tool animations. You need to set this every frame from the tick function.
The optional sway parameter control the amount of tool swaying when walking.
Set to zero to disable completely.
<p>
</p>
<pre class='example'>
function init()
	--Offset the tool half a meter to the right
	local offset = Transform(Vec(0.5, 0, 0))
	SetToolTransform(offset)
end

</pre>
<hr/>
<a name='SetToolAllowedZoom'></a><h3 class='function'>SetToolAllowedZoom</h3>
<pre class='funcdef'><span class='retname'></span>SetToolAllowedZoom(<span class='argname'>zoom, [zoom]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>zoom</span> <span class='argtype'>(number)</span> &ndash; Zoom factor<br/>
<span class='argname'>zoom</span> <span class='argtype'>(sensitivity], optional)</span> &ndash; Input sensitivity when zoomed in. Default is 1.0.<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Set the allowed zoom for a registered tool. The zoom sensitivity will be factored
with the user options for sensitivity.
<p>
</p>
<pre class='example'>
function tick()
	-- allow our scoped tool to zoom by factor 4.
	SetToolAllowedZoom(4.0, 0.5)
end

</pre>
<hr/>
<a name='SetToolTransformOverride'></a><h3 class='function'>SetToolTransformOverride</h3>
<pre class='funcdef'><span class='retname'></span>SetToolTransformOverride(<span class='argname'>transform</span>)</pre>
<p>Arguments<br/>
<span class='argname'>transform</span> <span class='argtype'>(TTransform)</span> &ndash; Tool body transform<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>This function serves as an alternative to SetToolTransform, providing full control over tool animation by disabling all internal tool animations. 
When using this function, you must manually include pitch, sway, and crouch movements in the transform. To maintain this control, call the function every frame from the tick function.
<p>
<p>
</p>
<pre class='example'>
function init()

	if GetBool("game.thirdperson") then
		local toolTransform = Transform(Vec(0.3, -0.3, -0.2), Quat(0.0, 0.0, 15.0))

		-- Rotate around point
		local pivotPoint = Vec(-0.01, -0.2, 0.04)
		toolTransform.pos = VecSub(toolTransform.pos, pivotPoint)
		local rotation = Transform(Vec(), QuatAxisAngle(Vec(0,0,1), GetPlayerPitch()))
		toolTransform = TransformToParentTransform(rotation, toolTransform)
		toolTransform.pos = VecAdd(toolTransform.pos, pivotPoint)

		SetToolTransformOverride(toolTransform)
	else
		local toolTransform = Transform(Vec(0.3, -0.3, -0.2), Quat(0.0, 0.0, 15.0))
		SetToolTransform(toolTransform)
	end
end

</pre>
<hr/>
<a name='SetToolOffset'></a><h3 class='function'>SetToolOffset</h3>
<pre class='funcdef'><span class='retname'></span>SetToolOffset(<span class='argname'>offset</span>)</pre>
<p>Arguments<br/>
<span class='argname'>offset</span> <span class='argtype'>(TVec)</span> &ndash; Tool body offset<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Apply an additional offset on the visible tool body. This can be used to
tweak tool placement for different characters. You need to set this every frame from the tick function.
<p>
</p>
<pre class='example'>
function tick()
	--Offset the tool depending on character height
	local defaultEyeY = 1.7
	local offsetY = characterHeight - defaultEyeY
	local offset = Vec(0, offsetY, 0)
	SetToolOffset(offset)
end

</pre>
<hr/>
<a name='LoadSound'></a><h3 class='function'>LoadSound</h3>
<pre class='funcdef'><span class='retname'>handle = </span>LoadSound(<span class='argname'>path, [nominalDistance]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>path</span> <span class='argtype'>(string)</span> &ndash; Path to ogg sound file<br/>
<span class='argname'>nominalDistance</span> <span class='argtype'>(number, optional)</span> &ndash; The distance in meters this sound is recorded at. Affects attenuation, default is 10.0<br/>
<p>Return value<br/>
<span class='retname'>handle</span> <span class='argtype'>(number)</span> &ndash; Sound handle<br/>
<p><p>
</p>
<pre class='example'>
function init()
	local snd = LoadSound("warning-beep.ogg")
end

</pre>
<hr/>
<a name='UnloadSound'></a><h3 class='function'>UnloadSound</h3>
<pre class='funcdef'><span class='retname'></span>UnloadSound(<span class='argname'>handle</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Sound handle<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p><p>
</p>
<pre class='example'>
function init()
	local snd = LoadSound("warning-beep.ogg")
	UnloadSound(snd)
end

</pre>
<hr/>
<a name='LoadLoop'></a><h3 class='function'>LoadLoop</h3>
<pre class='funcdef'><span class='retname'>handle = </span>LoadLoop(<span class='argname'>path, [nominalDistance]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>path</span> <span class='argtype'>(string)</span> &ndash; Path to ogg sound file<br/>
<span class='argname'>nominalDistance</span> <span class='argtype'>(number, optional)</span> &ndash; The distance in meters this sound is recorded at. Affects attenuation, default is 10.0<br/>
<p>Return value<br/>
<span class='retname'>handle</span> <span class='argtype'>(number)</span> &ndash; Loop handle<br/>
<p><p>
</p>
<pre class='example'>
local loop
function init()
	loop = LoadLoop("radio/jazz.ogg")
end

function tick()
	local pos = Vec(0, 0, 0)
	PlayLoop(loop, pos, 1.0)
end

</pre>
<hr/>
<a name='UnloadLoop'></a><h3 class='function'>UnloadLoop</h3>
<pre class='funcdef'><span class='retname'></span>UnloadLoop(<span class='argname'>handle</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Loop handle<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p><p>
</p>
<pre class='example'>
local loop = -1
function init()
	loop = LoadLoop("radio/jazz.ogg")
end

function tick()
	if loop ~= -1 then
		local pos = Vec(0, 0, 0)
		PlayLoop(loop, pos, 1.0)
	end
		
	if InputPressed("space") then
		UnloadLoop(loop)
		loop = -1
	end
end

</pre>
<hr/>
<a name='SetSoundLoopUser'></a><h3 class='function'>SetSoundLoopUser</h3>
<pre class='funcdef'><span class='retname'>flag = </span>SetSoundLoopUser(<span class='argname'>handle, nominalDistance</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Loop handle<br/>
<span class='argname'>nominalDistance</span> <span class='argtype'>(number)</span> &ndash; User index<br/>
<p>Return value<br/>
<span class='retname'>flag</span> <span class='argtype'>(boolean)</span> &ndash; TRUE if sound applied to gamepad speaker, FALSE otherwise.<br/>
<p><p>
</p>
<pre class='example'>
function init()
	local loop = LoadLoop("radio/jazz.ogg")
	SetSoundLoopUser(loop, 0)
end
--This function will move (if possible) sound to gamepad of appropriate user

</pre>
<hr/>
<a name='PlaySound'></a><h3 class='function'>PlaySound</h3>
<pre class='funcdef'><span class='retname'>handle = </span>PlaySound(<span class='argname'>handle, [pos], [volume], [registerVolume], [pitch]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Sound handle<br/>
<span class='argname'>pos</span> <span class='argtype'>(TVec, optional)</span> &ndash; World position as vector. Default is player position.<br/>
<span class='argname'>volume</span> <span class='argtype'>(number, optional)</span> &ndash; Playback volume. Default is 1.0<br/>
<span class='argname'>registerVolume</span> <span class='argtype'>(boolean, optional)</span> &ndash; Register position and volume of this sound for GetLastSound. Default is true<br/>
<span class='argname'>pitch</span> <span class='argtype'>(number, optional)</span> &ndash; Playback pitch. Default 1.0<br/>
<p>Return value<br/>
<span class='retname'>handle</span> <span class='argtype'>(number)</span> &ndash; Sound play handle<br/>
<p><p>
</p>
<pre class='example'>
local snd
function init()
	snd = LoadSound("warning-beep.ogg")
end

function tick()
	if InputPressed("interact") then
		local pos = Vec(0, 0, 0)
		PlaySound(snd, pos, 0.5)
	end
end

-- If you have a list of sound files and you add a sequence number, starting from zero, at the end of each filename like below,
-- then each time you call PlaySound it will pick a random sound from that list and play that sound.

-- "example-sound0.ogg"
-- "example-sound1.ogg"
-- "example-sound2.ogg"
-- "example-sound3.ogg"
-- ...
--[[
	local snd
	function init()
		snd = LoadSound("example-sound0.ogg")
	end

	-- Plays a random sound from the loaded sound series
	function tick()
		if trigSound then
			local pos = Vec(100, 0, 0)
			PlaySound(snd, pos, 0.5)
		end
	end
]]

</pre>
<hr/>
<a name='PlaySoundForUser'></a><h3 class='function'>PlaySoundForUser</h3>
<pre class='funcdef'><span class='retname'>handle = </span>PlaySoundForUser(<span class='argname'>handle, user, [pos], [volume], [registerVolume], [pitch]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Sound handle<br/>
<span class='argname'>user</span> <span class='argtype'>(number)</span> &ndash; Index of user to play.<br/>
<span class='argname'>pos</span> <span class='argtype'>(TVec, optional)</span> &ndash; World position as vector. Default is player position.<br/>
<span class='argname'>volume</span> <span class='argtype'>(number, optional)</span> &ndash; Playback volume. Default is 1.0<br/>
<span class='argname'>registerVolume</span> <span class='argtype'>(boolean, optional)</span> &ndash; Register position and volume of this sound for GetLastSound. Default is true<br/>
<span class='argname'>pitch</span> <span class='argtype'>(number, optional)</span> &ndash; Playback pitch. Default 1.0<br/>
<p>Return value<br/>
<span class='retname'>handle</span> <span class='argtype'>(number)</span> &ndash; Sound play handle<br/>
<p><p>
</p>
<pre class='example'>
local snd
function init()
	snd = LoadSound("warning-beep.ogg")
end

function tick()
	if InputPressed("interact") then
		PlaySoundForUser(snd, 0)
	end
end

-- If you have a list of sound files and you add a sequence number, starting from zero, at the end of each filename like below,
-- then each time you call PlaySoundForUser it will pick a random sound from that list and play that sound.

-- "example-sound0.ogg"
-- "example-sound1.ogg"
-- "example-sound2.ogg"
-- "example-sound3.ogg"
-- ...

--[[
	local snd
	function init()
		snd = LoadSound("example-sound0.ogg")
	end

	-- Plays a random sound from the loaded sound series
	function tick()
		if trigSound then
			local pos = Vec(100, 0, 0)
			PlaySoundForUser(snd, 0, pos, 0.5)
		end
	end
]]

</pre>
<hr/>
<a name='StopSound'></a><h3 class='function'>StopSound</h3>
<pre class='funcdef'><span class='retname'></span>StopSound(<span class='argname'>handle</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Sound play handle<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p><p>
</p>
<pre class='example'>
local snd
function init()
	snd = LoadSound("radio/jazz.ogg")
end

local sndPlay
function tick()
	if InputPressed("interact") then
		if not IsSoundPlaying(sndPlay) then
			local pos = Vec(0, 0, 0)
			sndPlay = PlaySound(snd, pos, 0.5)
		else
			StopSound(sndPlay)
		end
	end
end

</pre>
<hr/>
<a name='IsSoundPlaying'></a><h3 class='function'>IsSoundPlaying</h3>
<pre class='funcdef'><span class='retname'>playing = </span>IsSoundPlaying(<span class='argname'>handle</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Sound play handle<br/>
<p>Return value<br/>
<span class='retname'>playing</span> <span class='argtype'>(boolean)</span> &ndash; True if sound is playing, false otherwise.<br/>
<p><p>
</p>
<pre class='example'>
local snd
function init()
	snd = LoadSound("radio/jazz.ogg")
end

local sndPlay
function tick()
	if InputPressed("interact") then
		if not IsSoundPlaying(sndPlay) then
			local pos = Vec(0, 0, 0)
			sndPlay = PlaySound(snd, pos, 0.5)
		else
			StopSound(sndPlay)
		end
	end
end

</pre>
<hr/>
<a name='GetSoundProgress'></a><h3 class='function'>GetSoundProgress</h3>
<pre class='funcdef'><span class='retname'>progress = </span>GetSoundProgress(<span class='argname'>handle</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Sound play handle<br/>
<p>Return value<br/>
<span class='retname'>progress</span> <span class='argtype'>(number)</span> &ndash; Current sound progress in seconds.<br/>
<p><p>
</p>
<pre class='example'>
local snd
function init()
	snd = LoadSound("radio/jazz.ogg")
end

local sndPlay
function tick()
	if InputPressed("interact") then
		if not IsSoundPlaying(sndPlay) then
			local pos = Vec(0, 0, 0)
			sndPlay = PlaySound(snd, pos, 0.5)
		else
			SetSoundProgress(sndPlay, GetSoundProgress(sndPlay) - 1.0)
		end
	end
end

</pre>
<hr/>
<a name='SetSoundProgress'></a><h3 class='function'>SetSoundProgress</h3>
<pre class='funcdef'><span class='retname'></span>SetSoundProgress(<span class='argname'>handle, progress</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Sound play handle<br/>
<span class='argname'>progress</span> <span class='argtype'>(number)</span> &ndash; Progress in seconds<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p><p>
</p>
<pre class='example'>
local snd
function init()
	snd = LoadSound("radio/jazz.ogg")
end

local sndPlay
function tick()
	if InputPressed("interact") then
		if not IsSoundPlaying(sndPlay) then
			local pos = Vec(0, 0, 0)
			sndPlay = PlaySound(snd, pos, 0.5)
		else
			SetSoundProgress(sndPlay, GetSoundProgress(sndPlay) - 1.0)
		end
	end
end

</pre>
<hr/>
<a name='PlayLoop'></a><h3 class='function'>PlayLoop</h3>
<pre class='funcdef'><span class='retname'></span>PlayLoop(<span class='argname'>handle, [pos], [volume], [registerVolume], [pitch]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Loop handle<br/>
<span class='argname'>pos</span> <span class='argtype'>(TVec, optional)</span> &ndash; World position as vector. Default is player position.<br/>
<span class='argname'>volume</span> <span class='argtype'>(number, optional)</span> &ndash; Playback volume. Default is 1.0<br/>
<span class='argname'>registerVolume</span> <span class='argtype'>(boolean, optional)</span> &ndash; Register position and volume of this sound for GetLastSound. Default is true<br/>
<span class='argname'>pitch</span> <span class='argtype'>(number, optional)</span> &ndash; Playback pitch. Default 1.0<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Call this function continuously to play loop
<p>
</p>
<pre class='example'>
local loop
function init()
	loop = LoadLoop("radio/jazz.ogg")
end

function tick()
	local pos = Vec(0, 0, 0)
	PlayLoop(loop, pos, 1.0)
end

</pre>
<hr/>
<a name='GetSoundLoopProgress'></a><h3 class='function'>GetSoundLoopProgress</h3>
<pre class='funcdef'><span class='retname'>progress = </span>GetSoundLoopProgress(<span class='argname'>handle</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Loop handle<br/>
<p>Return value<br/>
<span class='retname'>progress</span> <span class='argtype'>(number)</span> &ndash; Current music progress in seconds.<br/>
<p><p>
</p>
<pre class='example'>
function init()
	loop = LoadLoop("radio/jazz.ogg")
end

function tick()
	local pos = Vec(0, 0, 0)
	PlayLoop(loop, pos, 1.0)
	if InputPressed("interact") then
		SetSoundLoopProgress(loop, GetSoundLoopProgress(loop) - 1.0)
	end
end

</pre>
<hr/>
<a name='SetSoundLoopProgress'></a><h3 class='function'>SetSoundLoopProgress</h3>
<pre class='funcdef'><span class='retname'></span>SetSoundLoopProgress(<span class='argname'>handle, [progress]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Loop handle<br/>
<span class='argname'>progress</span> <span class='argtype'>(number, optional)</span> &ndash; Progress in seconds. Default 0.0.<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p><p>
</p>
<pre class='example'>
function init()
	loop = LoadLoop("radio/jazz.ogg")
end

function tick()
	local pos = Vec(0, 0, 0)
	PlayLoop(loop, pos, 1.0)
	if InputPressed("interact") then
		SetSoundLoopProgress(loop, GetSoundLoopProgress(loop) - 1.0)
	end
end

</pre>
<hr/>
<a name='PlayMusic'></a><h3 class='function'>PlayMusic</h3>
<pre class='funcdef'><span class='retname'></span>PlayMusic(<span class='argname'>path</span>)</pre>
<p>Arguments<br/>
<span class='argname'>path</span> <span class='argtype'>(string)</span> &ndash; Music path<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p><p>
</p>
<pre class='example'>
function init()
	PlayMusic("about.ogg")
end

</pre>
<hr/>
<a name='StopMusic'></a><h3 class='function'>StopMusic</h3>
<pre class='funcdef'><span class='retname'></span>StopMusic(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>none</span>
<p><p>
</p>
<pre class='example'>
function init()
	PlayMusic("about.ogg")
end

function tick()
	if InputDown("interact") then
		StopMusic()
	end
end

</pre>
<hr/>
<a name='IsMusicPlaying'></a><h3 class='function'>IsMusicPlaying</h3>
<pre class='funcdef'><span class='retname'>playing = </span>IsMusicPlaying(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>playing</span> <span class='argtype'>(boolean)</span> &ndash; True if music is playing, false otherwise.<br/>
<p><p>
</p>
<pre class='example'>
function init()
	PlayMusic("about.ogg")
end

function tick()
	if InputPressed("interact") and IsMusicPlaying() then
		DebugPrint("music is playing")
	end
end

</pre>
<hr/>
<a name='SetMusicPaused'></a><h3 class='function'>SetMusicPaused</h3>
<pre class='funcdef'><span class='retname'></span>SetMusicPaused(<span class='argname'>paused</span>)</pre>
<p>Arguments<br/>
<span class='argname'>paused</span> <span class='argtype'>(boolean)</span> &ndash; True to pause, false to resume.<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p><p>
</p>
<pre class='example'>
function init()
	PlayMusic("about.ogg")
end

function tick()
	if InputPressed("interact") then
		SetMusicPaused(IsMusicPlaying())
	end
end

</pre>
<hr/>
<a name='GetMusicProgress'></a><h3 class='function'>GetMusicProgress</h3>
<pre class='funcdef'><span class='retname'>progress = </span>GetMusicProgress(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>progress</span> <span class='argtype'>(number)</span> &ndash; Current music progress in seconds.<br/>
<p><p>
</p>
<pre class='example'>
function init()
	PlayMusic("about.ogg")
end

function tick()
	if InputPressed("interact") then
		DebugPrint(GetMusicProgress())
	end
end

</pre>
<hr/>
<a name='SetMusicProgress'></a><h3 class='function'>SetMusicProgress</h3>
<pre class='funcdef'><span class='retname'></span>SetMusicProgress(<span class='argname'>[progress]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>progress</span> <span class='argtype'>(number, optional)</span> &ndash; Progress in seconds. Default 0.0.<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p><p>
</p>
<pre class='example'>
function init()
	PlayMusic("about.ogg")
end

function tick()
	if InputPressed("interact") then
 		SetMusicProgress(GetMusicProgress() - 1.0)
	end
end

</pre>
<hr/>
<a name='SetMusicVolume'></a><h3 class='function'>SetMusicVolume</h3>
<pre class='funcdef'><span class='retname'></span>SetMusicVolume(<span class='argname'>volume</span>)</pre>
<p>Arguments<br/>
<span class='argname'>volume</span> <span class='argtype'>(number)</span> &ndash; Music volume.<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Override current music volume for this frame. Call continuously to keep overriding.
<p>
</p>
<pre class='example'>
function init()
	PlayMusic("about.ogg")
end

function tick()
	if InputDown("interact") then
 		SetMusicVolume(0.3)
	end
end

</pre>
<hr/>
<a name='SetMusicLowPass'></a><h3 class='function'>SetMusicLowPass</h3>
<pre class='funcdef'><span class='retname'></span>SetMusicLowPass(<span class='argname'>wet</span>)</pre>
<p>Arguments<br/>
<span class='argname'>wet</span> <span class='argtype'>(number)</span> &ndash; Music low pass filter 0.0 - 1.0.<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Override current music low pass filter for this frame. Call continuously to keep overriding.
<p>
</p>
<pre class='example'>
function init()
	PlayMusic("about.ogg")
end

function tick()
	if InputDown("interact") then
 		SetMusicLowPass(0.6)
	end
end

</pre>
<hr/>
<a name='LoadSprite'></a><h3 class='function'>LoadSprite</h3>
<pre class='funcdef'><span class='retname'>handle = </span>LoadSprite(<span class='argname'>path</span>)</pre>
<p>Arguments<br/>
<span class='argname'>path</span> <span class='argtype'>(string)</span> &ndash; Path to sprite. Must be PNG or JPG format.<br/>
<p>Return value<br/>
<span class='retname'>handle</span> <span class='argtype'>(number)</span> &ndash; Sprite handle<br/>
<p><p>
</p>
<pre class='example'>
function init()
	arrow = LoadSprite("gfx/arrowdown.png")
end

</pre>
<hr/>
<a name='DrawSprite'></a><h3 class='function'>DrawSprite</h3>
<pre class='funcdef'><span class='retname'></span>DrawSprite(<span class='argname'>handle, transform, width, height, [r], [g], [b], [a], [depthTest], [additive], [fogAffected]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Sprite handle<br/>
<span class='argname'>transform</span> <span class='argtype'>(TTransform)</span> &ndash; Transform<br/>
<span class='argname'>width</span> <span class='argtype'>(number)</span> &ndash; Width in meters<br/>
<span class='argname'>height</span> <span class='argtype'>(number)</span> &ndash; Height in meters<br/>
<span class='argname'>r</span> <span class='argtype'>(number, optional)</span> &ndash; Red color. Default 1.0.<br/>
<span class='argname'>g</span> <span class='argtype'>(number, optional)</span> &ndash; Green color. Default 1.0.<br/>
<span class='argname'>b</span> <span class='argtype'>(number, optional)</span> &ndash; Blue color. Default 1.0.<br/>
<span class='argname'>a</span> <span class='argtype'>(number, optional)</span> &ndash; Alpha. Default 1.0.<br/>
<span class='argname'>depthTest</span> <span class='argtype'>(boolean, optional)</span> &ndash; Depth test enabled. Default false.<br/>
<span class='argname'>additive</span> <span class='argtype'>(boolean, optional)</span> &ndash; Additive blending enabled. Default false.<br/>
<span class='argname'>fogAffected</span> <span class='argtype'>(boolean, optional)</span> &ndash; Enable distance fog effect. Default false.<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Draw sprite in world at next frame. Call this function from the tick callback.
<p>
</p>
<pre class='example'>
function init()
	arrow = LoadSprite("gfx/arrowdown.png")
end

function tick()
	--Draw sprite using transform
	--Size is two meters in width and height
	--Color is white, fully opaue
	local t = Transform(Vec(0, 10, 0), QuatEuler(0, GetTime(), 0))
	DrawSprite(arrow, t, 2, 2, 1, 1, 1, 1)
end

</pre>
<hr/>
<a name='QueryRequire'></a><h3 class='function'>QueryRequire</h3>
<pre class='funcdef'><span class='retname'></span>QueryRequire(<span class='argname'>layers</span>)</pre>
<p>Arguments<br/>
<span class='argname'>layers</span> <span class='argtype'>(string)</span> &ndash; Space separate list of layers<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Set required layers for next query. Available layers are: 
<table border=0><tr><td class='header'>&nbsp;Layer&nbsp;</td><td class='header'>&nbsp;Description</td></tr>
<tr><td class='first' valign='top'>physical	</td><td valign='top'> have a physical representation</td></tr><tr><td class='first' valign='top'>dynamic		</td><td valign='top'> part of a dynamic body</td></tr><tr><td class='first' valign='top'>static		</td><td valign='top'> part of a static body</td></tr><tr><td class='first' valign='top'>large		</td><td valign='top'> above debris threshold</td></tr><tr><td class='first' valign='top'>small		</td><td valign='top'> below debris threshold</td></tr><tr><td class='first' valign='top'>visible		</td><td valign='top'> only hit visible shapes</td></tr><tr><td class='first' valign='top'>animator&nbsp;&nbsp;&nbsp;&nbsp;</td><td valign='top'> part of an animator hierachy</td></tr><tr><td class='first' valign='top'>player&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td><td valign='top'> part of an player animator hierachy</td></tr><tr><td class='first' valign='top'>tool&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td><td valign='top'> part of a tool</td></tr><table/>
<p>
</p>
<pre class='example'>
--Raycast dynamic, physical objects above debris threshold, but not specific vehicle
function tick()
	local vehicle = FindVehicle("vehicle")
	QueryRequire("physical dynamic large")
	QueryRejectVehicle(vehicle)
	local hit, dist = QueryRaycast(Vec(0, 0, 0), Vec(1, 0, 0), 10)
	if hit then
		DebugPrint(dist)
	end
end

</pre>
<hr/>
<a name='QueryInclude'></a><h3 class='function'>QueryInclude</h3>
<pre class='funcdef'><span class='retname'></span>QueryInclude(<span class='argname'>layers</span>)</pre>
<p>Arguments<br/>
<span class='argname'>layers</span> <span class='argtype'>(string)</span> &ndash; Space separate list of layers<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Set included layers for next query. Queries include all layers except tool and player per default. Available layers are:
<table border=0><tr><td class='header'>&nbsp;Layer&nbsp;</td><td class='header'>&nbsp;Description</td></tr>
<tr><td class='first' valign='top'>physical	</td><td valign='top'> have a physical representation</td></tr><tr><td class='first' valign='top'>dynamic		</td><td valign='top'> part of a dynamic body</td></tr><tr><td class='first' valign='top'>static		</td><td valign='top'> part of a static body</td></tr><tr><td class='first' valign='top'>large		</td><td valign='top'> above debris threshold</td></tr><tr><td class='first' valign='top'>small		</td><td valign='top'> below debris threshold</td></tr><tr><td class='first' valign='top'>visible		</td><td valign='top'> only hit visible shapes</td></tr><tr><td class='first' valign='top'>animator&nbsp;&nbsp;&nbsp;&nbsp;</td><td valign='top'> part of an animator hierachy</td></tr><tr><td class='first' valign='top'>player&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td><td valign='top'> part of an player</td></tr><tr><td class='first' valign='top'>tool&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td><td valign='top'> part of a tool</td></tr><table/>
<p>
</p>
<pre class='example'>
--Raycast all the default layers and include the player layer.
function tick()
	QueryInclude("player")
	local hit, dist = QueryRaycast(Vec(0, 0, 0), Vec(1, 0, 0), 10)
	if hit then
		DebugPrint(dist)
	end
end

</pre>
<hr/>
<a name='QueryRejectAnimator'></a><h3 class='function'>QueryRejectAnimator</h3>
<pre class='funcdef'><span class='retname'></span>QueryRejectAnimator(<span class='argname'>handle</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Animator handle<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Exclude animator from the next query
<p>
</p>
<hr/>
<a name='QueryRejectVehicle'></a><h3 class='function'>QueryRejectVehicle</h3>
<pre class='funcdef'><span class='retname'></span>QueryRejectVehicle(<span class='argname'>vehicle</span>)</pre>
<p>Arguments<br/>
<span class='argname'>vehicle</span> <span class='argtype'>(number)</span> &ndash; Vehicle handle<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Exclude vehicle from the next query
<p>
</p>
<pre class='example'>
function tick()
	local vehicle = FindVehicle("vehicle")
	QueryRequire("physical dynamic large")
	--Do not include vehicle in next raycast
	QueryRejectVehicle(vehicle)
	local hit, dist = QueryRaycast(Vec(0, 0, 0), Vec(1, 0, 0), 10)
	if hit then
		DebugPrint(dist)
	end
end



</pre>
<hr/>
<a name='QueryRejectBody'></a><h3 class='function'>QueryRejectBody</h3>
<pre class='funcdef'><span class='retname'></span>QueryRejectBody(<span class='argname'>body</span>)</pre>
<p>Arguments<br/>
<span class='argname'>body</span> <span class='argtype'>(number)</span> &ndash; Body handle<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Exclude body from the next query
<p>
</p>
<pre class='example'>
function tick()
	local body = FindBody("body")
	QueryRequire("physical dynamic large")
	--Do not include body in next raycast
	QueryRejectBody(body)
	local hit, dist = QueryRaycast(Vec(0, 0, 0), Vec(1, 0, 0), 10)
	if hit then
		DebugPrint(dist)
	end
end

</pre>
<hr/>
<a name='QueryRejectBodies'></a><h3 class='function'>QueryRejectBodies</h3>
<pre class='funcdef'><span class='retname'></span>QueryRejectBodies(<span class='argname'>bodies</span>)</pre>
<p>Arguments<br/>
<span class='argname'>bodies</span> <span class='argtype'>(table)</span> &ndash; Array with bodies handles<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Exclude bodies from the next query
<p>
</p>
<pre class='example'>
function tick()
	local body = FindBody("body")
	QueryRequire("physical dynamic large")
	local bodies = {body}
	--Do not include body in next raycast
	QueryRejectBodies(bodies)
	local hit, dist = QueryRaycast(Vec(0, 0, 0), Vec(1, 0, 0), 10)
	if hit then
		DebugPrint(dist)
	end
end

</pre>
<hr/>
<a name='QueryRejectShape'></a><h3 class='function'>QueryRejectShape</h3>
<pre class='funcdef'><span class='retname'></span>QueryRejectShape(<span class='argname'>shape</span>)</pre>
<p>Arguments<br/>
<span class='argname'>shape</span> <span class='argtype'>(number)</span> &ndash; Shape handle<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Exclude shape from the next query
<p>
</p>
<pre class='example'>
function tick()
	local shape = FindShape("shape")
	QueryRequire("physical dynamic large")
	--Do not include shape in next raycast
	QueryRejectShape(shape)
	local hit, dist = QueryRaycast(Vec(0, 0, 0), Vec(1, 0, 0), 10)
	if hit then
		DebugPrint(dist)
	end
end

</pre>
<hr/>
<a name='QueryRejectShapes'></a><h3 class='function'>QueryRejectShapes</h3>
<pre class='funcdef'><span class='retname'></span>QueryRejectShapes(<span class='argname'>shapes</span>)</pre>
<p>Arguments<br/>
<span class='argname'>shapes</span> <span class='argtype'>(table)</span> &ndash; Array with shapes handles<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Exclude shapes from the next query
<p>
</p>
<pre class='example'>
function tick()
	local shape = FindShape("shape")
	QueryRequire("physical dynamic large")
	local shapes = {shape}
	--Do not include shape in next raycast
	QueryRejectShapes(shapes)
	local hit, dist = QueryRaycast(Vec(0, 0, 0), Vec(1, 0, 0), 10)
	if hit then
		DebugPrint(dist)
	end
end

</pre>
<hr/>
<a name='QueryRaycast'></a><h3 class='function'>QueryRaycast</h3>
<pre class='funcdef'><span class='retname'>hit, dist, normal, shape = </span>QueryRaycast(<span class='argname'>origin, direction, maxDist, [radius], [rejectTransparent]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>origin</span> <span class='argtype'>(TVec)</span> &ndash; Raycast origin as world space vector<br/>
<span class='argname'>direction</span> <span class='argtype'>(TVec)</span> &ndash; Unit length raycast direction as world space vector<br/>
<span class='argname'>maxDist</span> <span class='argtype'>(number)</span> &ndash; Raycast maximum distance. Keep this as low as possible for good performance.<br/>
<span class='argname'>radius</span> <span class='argtype'>(number, optional)</span> &ndash; Raycast thickness. Default zero.<br/>
<span class='argname'>rejectTransparent</span> <span class='argtype'>(boolean, optional)</span> &ndash; Raycast through transparent materials. Default false.<br/>
<p>Return value<br/>
<span class='retname'>hit</span> <span class='argtype'>(boolean)</span> &ndash; True if raycast hit something<br/>
<span class='retname'>dist</span> <span class='argtype'>(number)</span> &ndash; Hit distance from origin<br/>
<span class='retname'>normal</span> <span class='argtype'>(TVec)</span> &ndash; World space normal at hit point<br/>
<span class='retname'>shape</span> <span class='argtype'>(number)</span> &ndash; Handle to hit shape<br/>
<p>This will perform a raycast or spherecast (if radius is more than zero) query.
If you want to set up a filter for the query you need to do so before every call
to this function.
<p>
</p>
<pre class='example'>
function init()
	local vehicle = FindVehicle("vehicle")
	QueryRejectVehicle(vehicle)
	--Raycast from a high point straight downwards, excluding a specific vehicle
	local hit, d = QueryRaycast(Vec(0, 100, 0), Vec(0, -1, 0), 100)
	if hit then
		DebugPrint(d)
	end
end

</pre>
<hr/>
<a name='QueryRaycastRope'></a><h3 class='function'>QueryRaycastRope</h3>
<pre class='funcdef'><span class='retname'>hit, dist, joint = </span>QueryRaycastRope(<span class='argname'>origin, direction, maxDist, [radius]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>origin</span> <span class='argtype'>(TVec)</span> &ndash; Raycast origin as world space vector<br/>
<span class='argname'>direction</span> <span class='argtype'>(TVec)</span> &ndash; Unit length raycast direction as world space vector<br/>
<span class='argname'>maxDist</span> <span class='argtype'>(number)</span> &ndash; Raycast maximum distance. Keep this as low as possible for good performance.<br/>
<span class='argname'>radius</span> <span class='argtype'>(number, optional)</span> &ndash; Raycast thickness. Default zero.<br/>
<p>Return value<br/>
<span class='retname'>hit</span> <span class='argtype'>(boolean)</span> &ndash; True if raycast hit something<br/>
<span class='retname'>dist</span> <span class='argtype'>(number)</span> &ndash; Hit distance from origin<br/>
<span class='retname'>joint</span> <span class='argtype'>(number)</span> &ndash; Handle to hit joint of rope type<br/>
<p>This will perform a raycast query that returns the handle of the joint of rope type when if collides with it.
There are no filters for this type of raycast.
<p>
</p>
<pre class='example'>
function tick()
	local playerCameraTransform = GetPlayerCameraTransform()
	local dir = TransformToParentVec(playerCameraTransform, Vec(0, 0, -1))

	local hit, dist, joint = QueryRaycastRope(playerCameraTransform.pos, dir, 10)
	if hit then
		DebugWatch("distance", dist)
		DebugWatch("joint", joint)
	end
end

</pre>
<hr/>
<a name='QueryClosestPoint'></a><h3 class='function'>QueryClosestPoint</h3>
<pre class='funcdef'><span class='retname'>hit, point, normal, shape = </span>QueryClosestPoint(<span class='argname'>origin, maxDist</span>)</pre>
<p>Arguments<br/>
<span class='argname'>origin</span> <span class='argtype'>(TVec)</span> &ndash; World space point<br/>
<span class='argname'>maxDist</span> <span class='argtype'>(number)</span> &ndash; Maximum distance. Keep this as low as possible for good performance.<br/>
<p>Return value<br/>
<span class='retname'>hit</span> <span class='argtype'>(boolean)</span> &ndash; True if a point was found<br/>
<span class='retname'>point</span> <span class='argtype'>(TVec)</span> &ndash; World space closest point<br/>
<span class='retname'>normal</span> <span class='argtype'>(TVec)</span> &ndash; World space normal at closest point<br/>
<span class='retname'>shape</span> <span class='argtype'>(number)</span> &ndash; Handle to closest shape<br/>
<p>This will query the closest point to all shapes in the world. If you 
want to set up a filter for the query you need to do so before every call
to this function.
<p>
</p>
<pre class='example'>
function tick()
	local vehicle = FindVehicle("vehicle")
	--Find closest point within 10 meters of {0, 5, 0}, excluding any point on myVehicle
	QueryRejectVehicle(vehicle)
	local hit, p, n, s = QueryClosestPoint(Vec(0, 5, 0), 10)
	if hit then
		DebugPrint(p)
	end
end

</pre>
<hr/>
<a name='QueryAabbShapes'></a><h3 class='function'>QueryAabbShapes</h3>
<pre class='funcdef'><span class='retname'>list = </span>QueryAabbShapes(<span class='argname'>min, max</span>)</pre>
<p>Arguments<br/>
<span class='argname'>min</span> <span class='argtype'>(TVec)</span> &ndash; Aabb minimum point<br/>
<span class='argname'>max</span> <span class='argtype'>(TVec)</span> &ndash; Aabb maximum point<br/>
<p>Return value<br/>
<span class='retname'>list</span> <span class='argtype'>(table)</span> &ndash; Indexed table with handles to all shapes in the aabb<br/>
<p>Return all shapes within the provided world space, axis-aligned bounding box
<p>
</p>
<pre class='example'>
function tick()
	local list = QueryAabbShapes(Vec(0, 0, 0), Vec(10, 10, 10))
	for i=1, #list do
		local shape = list[i]
		DebugPrint(shape)
	end
end

</pre>
<hr/>
<a name='QueryAabbBodies'></a><h3 class='function'>QueryAabbBodies</h3>
<pre class='funcdef'><span class='retname'>list = </span>QueryAabbBodies(<span class='argname'>min, max</span>)</pre>
<p>Arguments<br/>
<span class='argname'>min</span> <span class='argtype'>(TVec)</span> &ndash; Aabb minimum point<br/>
<span class='argname'>max</span> <span class='argtype'>(TVec)</span> &ndash; Aabb maximum point<br/>
<p>Return value<br/>
<span class='retname'>list</span> <span class='argtype'>(table)</span> &ndash; Indexed table with handles to all bodies in the aabb<br/>
<p>Return all bodies within the provided world space, axis-aligned bounding box
<p>
</p>
<pre class='example'>
function tick()
	local list = QueryAabbBodies(Vec(0, 0, 0), Vec(10, 10, 10))
	for i=1, #list do
		local body = list[i]
		DebugPrint(body)
	end
end

</pre>
<hr/>
<a name='QueryPath'></a><h3 class='function'>QueryPath</h3>
<pre class='funcdef'><span class='retname'></span>QueryPath(<span class='argname'>start, end, [maxDist], [targetRadius], [type]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>start</span> <span class='argtype'>(TVec)</span> &ndash; World space start point<br/>
<span class='argname'>end</span> <span class='argtype'>(TVec)</span> &ndash; World space target point<br/>
<span class='argname'>maxDist</span> <span class='argtype'>(number, optional)</span> &ndash; Maximum path length before giving up. Default is infinite.<br/>
<span class='argname'>targetRadius</span> <span class='argtype'>(number, optional)</span> &ndash; Maximum allowed distance to target in meters. Default is 2.0<br/>
<span class='argname'>type</span> <span class='argtype'>(string, optional)</span> &ndash; Type of path. Can be "low", "standart", "water", "flying". Default is "standart"<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Initiate path planning query. The result will run asynchronously as long as GetPathState
returns "busy". An ongoing path query can be aborted with AbortPath. The path planning query
will use the currently set up query filter, just like the other query functions.
Using the 'water' type allows you to build a path within the water.
The 'flying' type builds a path in the entire three-dimensional space.
<p>
</p>
<pre class='example'>
function init()
	QueryPath(Vec(-10, 0, 0), Vec(10, 0, 0))
end

</pre>
<hr/>
<a name='CreatePathPlanner'></a><h3 class='function'>CreatePathPlanner</h3>
<pre class='funcdef'><span class='retname'>id = </span>CreatePathPlanner(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>id</span> <span class='argtype'>(number)</span> &ndash; Path planner id<br/>
<p>Creates a new path planner that can be used to calculate multiple paths in parallel.
It is supposed to be used together with PathPlannerQuery.
Returns created path planner id/handler.
It is recommended to reuse previously created path planners, because they exist throughout the lifetime of the script.
<p>
</p>
<pre class='example'>
local paths = {}

function init()
	paths[1] = {
		id = CreatePathPlanner(),
		location = GetProperty(FindEntity("loc1", true), "transform").pos,
	}

	paths[2] = {
		id = CreatePathPlanner(),
		location = GetProperty(FindEntity("loc2", true), "transform").pos,
	}

	for i = 1, #paths do
		PathPlannerQuery(paths[i].id, GetPlayerTransform().pos, paths[i].location)
	end
end

</pre>
<hr/>
<a name='DeletePathPlanner'></a><h3 class='function'>DeletePathPlanner</h3>
<pre class='funcdef'><span class='retname'></span>DeletePathPlanner(<span class='argname'>id</span>)</pre>
<p>Arguments<br/>
<span class='argname'>id</span> <span class='argtype'>(number)</span> &ndash; Path planner id<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Deletes the path planner with the specified id which can be used to save some memory.
Calling CreatePathPlanner again can initialize a new path planner with the id previously deleted.
<p>
</p>
<pre class='example'>
local paths = {}

function init()
	local id = CreatePathPlanner()
	DeletePathPlanner(id)
	-- now calling PathPlannerQuery for 'id' will result in an error
end

</pre>
<hr/>
<a name='PathPlannerQuery'></a><h3 class='function'>PathPlannerQuery</h3>
<pre class='funcdef'><span class='retname'></span>PathPlannerQuery(<span class='argname'>id, start, end, [maxDist], [targetRadius], [type]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>id</span> <span class='argtype'>(number)</span> &ndash; Path planner id<br/>
<span class='argname'>start</span> <span class='argtype'>(TVec)</span> &ndash; World space start point<br/>
<span class='argname'>end</span> <span class='argtype'>(TVec)</span> &ndash; World space target point<br/>
<span class='argname'>maxDist</span> <span class='argtype'>(number, optional)</span> &ndash; Maximum path length before giving up. Default is infinite.<br/>
<span class='argname'>targetRadius</span> <span class='argtype'>(number, optional)</span> &ndash; Maximum allowed distance to target in meters. Default is 2.0<br/>
<span class='argname'>type</span> <span class='argtype'>(string, optional)</span> &ndash; Type of path. Can be "low", "standart", "water", "flying". Default is "standart"<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>It works similarly to QueryPath but several paths can be built simultaneously within the same script.
The QueryPath automatically creates a path planner with an index of 0 and only works with it.
<p>
</p>
<pre class='example'>
local paths = {}

function init()
	paths[1] = {
		id = CreatePathPlanner(),
		location = GetProperty(FindEntity("loc1", true), "transform").pos,
	}

	paths[2] = {
		id = CreatePathPlanner(),
		location = GetProperty(FindEntity("loc2", true), "transform").pos,
	}

	for i = 1, #paths do
		PathPlannerQuery(paths[i].id, GetPlayerTransform().pos, paths[i].location)
	end
end

</pre>
<hr/>
<a name='AbortPath'></a><h3 class='function'>AbortPath</h3>
<pre class='funcdef'><span class='retname'></span>AbortPath(<span class='argname'>[id]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>id</span> <span class='argtype'>(number, optional)</span> &ndash; Path planner id. Default value is 0.<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Abort current path query, regardless of what state it is currently in. This is a way to
save computing resources if the result of the current query is no longer of interest.
<p>
</p>
<pre class='example'>
function init()
	QueryPath(Vec(-10, 0, 0), Vec(10, 0, 0))
	AbortPath()
end

</pre>
<hr/>
<a name='GetPathState'></a><h3 class='function'>GetPathState</h3>
<pre class='funcdef'><span class='retname'>state = </span>GetPathState(<span class='argname'>[id]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>id</span> <span class='argtype'>(number, optional)</span> &ndash; Path planner id. Default value is 0.<br/>
<p>Return value<br/>
<span class='retname'>state</span> <span class='argtype'>(string)</span> &ndash; Current path planning state<br/>
<p>Return the current state of the last path planning query.
<table border=0><tr><td class='header'>&nbsp;State&nbsp;</td><td class='header'>&nbsp;Description</td></tr>
<tr><td class='first' valign='top'>idle	</td><td valign='top'> No recent query</td></tr><tr><td class='first' valign='top'>busy	</td><td valign='top'> Busy computing. No path found yet.</td></tr><tr><td class='first' valign='top'>fail	</td><td valign='top'> Failed to find path. You can still get the resulting path (even though it won't reach the target).</td></tr><tr><td class='first' valign='top'>done	</td><td valign='top'> Path planning completed and a path was found. Get it with GetPathLength and GetPathPoint)</td></tr><table/>
<p>
</p>
<pre class='example'>
function init()
	QueryPath(Vec(-10, 0, 0), Vec(10, 0, 0))
end

function tick()
	local s = GetPathState()
	if s == "done" then
		DebugPrint("done")
	end
end

</pre>
<hr/>
<a name='GetPathLength'></a><h3 class='function'>GetPathLength</h3>
<pre class='funcdef'><span class='retname'>length = </span>GetPathLength(<span class='argname'>[id]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>id</span> <span class='argtype'>(number, optional)</span> &ndash; Path planner id. Default value is 0.<br/>
<p>Return value<br/>
<span class='retname'>length</span> <span class='argtype'>(number)</span> &ndash; Length of last path planning result (in meters)<br/>
<p>Return the path length of the most recently computed path query. Note that the result can often be retrieved even
if the path query failed. If the target point couldn't be reached, the path endpoint will be the point closest
to the target.
<p>
</p>
<pre class='example'>
function init()
	QueryPath(Vec(-10, 0, 0), Vec(10, 0, 0))
end

function tick()
	local s = GetPathState()
	if s == "done" then
		DebugPrint("done " .. GetPathLength())
	end
end

</pre>
<hr/>
<a name='GetPathPoint'></a><h3 class='function'>GetPathPoint</h3>
<pre class='funcdef'><span class='retname'>point = </span>GetPathPoint(<span class='argname'>dist, [id]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>dist</span> <span class='argtype'>(number)</span> &ndash; The distance along path. Should be between zero and result from GetPathLength()<br/>
<span class='argname'>id</span> <span class='argtype'>(number, optional)</span> &ndash; Path planner id. Default value is 0.<br/>
<p>Return value<br/>
<span class='retname'>point</span> <span class='argtype'>(TVec)</span> &ndash; The path point dist meters along the path<br/>
<p>Return a point along the path for the most recently computed path query. Note that the result can often be retrieved even
if the path query failed. If the target point couldn't be reached, the path endpoint will be the point closest
to the target.
<p>
</p>
<pre class='example'>
function init()
	QueryPath(Vec(-10, 0, 0), Vec(10, 0, 0))
end

function tick()
	local d = 0
	local l = GetPathLength()
	while d < l do
		DebugCross(GetPathPoint(d))
		d = d + 0.5
	end
end

</pre>
<hr/>
<a name='GetLastSound'></a><h3 class='function'>GetLastSound</h3>
<pre class='funcdef'><span class='retname'>volume, position = </span>GetLastSound(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>volume</span> <span class='argtype'>(number)</span> &ndash; Volume of loudest sound played last frame<br/>
<span class='retname'>position</span> <span class='argtype'>(TVec)</span> &ndash; World position of loudest sound played last frame<br/>
<p><p>
</p>
<pre class='example'>
function tick()
	local vol, pos = GetLastSound()
	if vol > 0 then
		DebugPrint(vol .. " " .. VecStr(pos)) 
	end
end

</pre>
<hr/>
<a name='IsPointInWater'></a><h3 class='function'>IsPointInWater</h3>
<pre class='funcdef'><span class='retname'>inWater, depth = </span>IsPointInWater(<span class='argname'>point</span>)</pre>
<p>Arguments<br/>
<span class='argname'>point</span> <span class='argtype'>(TVec)</span> &ndash; World point as vector<br/>
<p>Return value<br/>
<span class='retname'>inWater</span> <span class='argtype'>(boolean)</span> &ndash; True if point is in water<br/>
<span class='retname'>depth</span> <span class='argtype'>(number)</span> &ndash; Depth of point into water, or zero if not in water<br/>
<p><p>
</p>
<pre class='example'>
function tick()
	local wet, d = IsPointInWater(Vec(10, 0, 0))
	if wet then
		DebugPrint("point" .. d .. " meters into water")
	end
end

</pre>
<hr/>
<a name='GetWindVelocity'></a><h3 class='function'>GetWindVelocity</h3>
<pre class='funcdef'><span class='retname'>vel = </span>GetWindVelocity(<span class='argname'>point</span>)</pre>
<p>Arguments<br/>
<span class='argname'>point</span> <span class='argtype'>(TVec)</span> &ndash; World point as vector<br/>
<p>Return value<br/>
<span class='retname'>vel</span> <span class='argtype'>(TVec)</span> &ndash; Wind at provided position<br/>
<p>Get the wind velocity at provided point. The wind will be determined by wind property of
the environment, but it varies with position procedurally.
<p>
</p>
<pre class='example'>
function tick()
	local v = GetWindVelocity(Vec(0, 10, 0))
	DebugPrint(VecStr(v))
end

</pre>
<hr/>
<a name='ParticleReset'></a><h3 class='function'>ParticleReset</h3>
<pre class='funcdef'><span class='retname'></span>ParticleReset(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Reset to default particle state, which is a plain, white particle of radius 0.5.
Collision is enabled and it alpha animates from 1 to 0.
<p>
</p>
<pre class='example'>
function init()
	ParticleReset()
end

</pre>
<hr/>
<a name='ParticleType'></a><h3 class='function'>ParticleType</h3>
<pre class='funcdef'><span class='retname'></span>ParticleType(<span class='argname'>type</span>)</pre>
<p>Arguments<br/>
<span class='argname'>type</span> <span class='argtype'>(string)</span> &ndash; Type of particle. Can be "smoke" or "plain".<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Set type of particle
<p>
</p>
<pre class='example'>
function init()
	ParticleType("smoke")
end

</pre>
<hr/>
<a name='ParticleTile'></a><h3 class='function'>ParticleTile</h3>
<pre class='funcdef'><span class='retname'></span>ParticleTile(<span class='argname'>type</span>)</pre>
<p>Arguments<br/>
<span class='argname'>type</span> <span class='argtype'>(number)</span> &ndash; Tile in the particle texture atlas (0-15)<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p><p>
</p>
<pre class='example'>
function init()
	--Smoke particle
	ParticleTile(0)
	
	--Fire particle
	ParticleTile(5)
end

</pre>
<hr/>
<a name='ParticleColor'></a><h3 class='function'>ParticleColor</h3>
<pre class='funcdef'><span class='retname'></span>ParticleColor(<span class='argname'>r0, g0, b0, [r1], [g1], [b1]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>r0</span> <span class='argtype'>(number)</span> &ndash; Red value<br/>
<span class='argname'>g0</span> <span class='argtype'>(number)</span> &ndash; Green value<br/>
<span class='argname'>b0</span> <span class='argtype'>(number)</span> &ndash; Blue value<br/>
<span class='argname'>r1</span> <span class='argtype'>(number, optional)</span> &ndash; Red value at end<br/>
<span class='argname'>g1</span> <span class='argtype'>(number, optional)</span> &ndash; Green value at end<br/>
<span class='argname'>b1</span> <span class='argtype'>(number, optional)</span> &ndash; Blue value at end<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Set particle color to either constant (three arguments) or linear interpolation (six arguments)
<p>
</p>
<pre class='example'>
function init()
	--Constant red
	ParticleColor(1,0,0)

	--Animating from yellow to red
	ParticleColor(1,1,0, 1,0,0)
end

</pre>
<hr/>
<a name='ParticleRadius'></a><h3 class='function'>ParticleRadius</h3>
<pre class='funcdef'><span class='retname'></span>ParticleRadius(<span class='argname'>r0, [r1], [interpolation], [fadein], [fadeout]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>r0</span> <span class='argtype'>(number)</span> &ndash; Radius<br/>
<span class='argname'>r1</span> <span class='argtype'>(number, optional)</span> &ndash; End radius<br/>
<span class='argname'>interpolation</span> <span class='argtype'>(string, optional)</span> &ndash; Interpolation method: linear, smooth, easein, easeout or constant. Default is linear.<br/>
<span class='argname'>fadein</span> <span class='argtype'>(number, optional)</span> &ndash; Fade in between t=0 and t=fadein. Default is zero.<br/>
<span class='argname'>fadeout</span> <span class='argtype'>(number, optional)</span> &ndash; Fade out between t=fadeout and t=1. Default is one.<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Set the particle radius. Max radius for smoke particles is 1.0.
<p>
</p>
<pre class='example'>
function init()
	--Constant radius 0.4 meters
	ParticleRadius(0.4)

	--Interpolate from small to large
	ParticleRadius(0.1, 0.7)
end

</pre>
<hr/>
<a name='ParticleAlpha'></a><h3 class='function'>ParticleAlpha</h3>
<pre class='funcdef'><span class='retname'></span>ParticleAlpha(<span class='argname'>a0, [a1], [interpolation], [fadein], [fadeout]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>a0</span> <span class='argtype'>(number)</span> &ndash; Alpha (0.0 - 1.0)<br/>
<span class='argname'>a1</span> <span class='argtype'>(number, optional)</span> &ndash; End alpha (0.0 - 1.0)<br/>
<span class='argname'>interpolation</span> <span class='argtype'>(string, optional)</span> &ndash; Interpolation method: linear, smooth, easein, easeout or constant. Default is linear.<br/>
<span class='argname'>fadein</span> <span class='argtype'>(number, optional)</span> &ndash; Fade in between t=0 and t=fadein. Default is zero.<br/>
<span class='argname'>fadeout</span> <span class='argtype'>(number, optional)</span> &ndash; Fade out between t=fadeout and t=1. Default is one.<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Set the particle alpha (opacity).
<p>
</p>
<pre class='example'>
function init()
	--Interpolate from opaque to transparent
	ParticleAlpha(1.0, 0.0)
end

</pre>
<hr/>
<a name='ParticleGravity'></a><h3 class='function'>ParticleGravity</h3>
<pre class='funcdef'><span class='retname'></span>ParticleGravity(<span class='argname'>g0, [g1], [interpolation], [fadein], [fadeout]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>g0</span> <span class='argtype'>(number)</span> &ndash; Gravity<br/>
<span class='argname'>g1</span> <span class='argtype'>(number, optional)</span> &ndash; End gravity<br/>
<span class='argname'>interpolation</span> <span class='argtype'>(string, optional)</span> &ndash; Interpolation method: linear, smooth, easein, easeout or constant. Default is linear.<br/>
<span class='argname'>fadein</span> <span class='argtype'>(number, optional)</span> &ndash; Fade in between t=0 and t=fadein. Default is zero.<br/>
<span class='argname'>fadeout</span> <span class='argtype'>(number, optional)</span> &ndash; Fade out between t=fadeout and t=1. Default is one.<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Set particle gravity. It will be applied along the world Y axis. A negative value will move the particle downwards.
<p>
</p>
<pre class='example'>
function init()
	--Move particles slowly upwards
	ParticleGravity(2)
end

</pre>
<hr/>
<a name='ParticleDrag'></a><h3 class='function'>ParticleDrag</h3>
<pre class='funcdef'><span class='retname'></span>ParticleDrag(<span class='argname'>d0, [d1], [interpolation], [fadein], [fadeout]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>d0</span> <span class='argtype'>(number)</span> &ndash; Drag<br/>
<span class='argname'>d1</span> <span class='argtype'>(number, optional)</span> &ndash; End drag<br/>
<span class='argname'>interpolation</span> <span class='argtype'>(string, optional)</span> &ndash; Interpolation method: linear, smooth, easein, easeout or constant. Default is linear.<br/>
<span class='argname'>fadein</span> <span class='argtype'>(number, optional)</span> &ndash; Fade in between t=0 and t=fadein. Default is zero.<br/>
<span class='argname'>fadeout</span> <span class='argtype'>(number, optional)</span> &ndash; Fade out between t=fadeout and t=1. Default is one.<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Particle drag will slow down fast moving particles. It's implemented slightly different for
smoke and plain particles. Drag must be positive, and usually look good between zero and one.
<p>
</p>
<pre class='example'>
function init()
	--Slow down fast moving particles
	ParticleDrag(0.5)
end

</pre>
<hr/>
<a name='ParticleEmissive'></a><h3 class='function'>ParticleEmissive</h3>
<pre class='funcdef'><span class='retname'></span>ParticleEmissive(<span class='argname'>d0, [d1], [interpolation], [fadein], [fadeout]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>d0</span> <span class='argtype'>(number)</span> &ndash; Emissive<br/>
<span class='argname'>d1</span> <span class='argtype'>(number, optional)</span> &ndash; End emissive<br/>
<span class='argname'>interpolation</span> <span class='argtype'>(string, optional)</span> &ndash; Interpolation method: linear, smooth, easein, easeout or constant. Default is linear.<br/>
<span class='argname'>fadein</span> <span class='argtype'>(number, optional)</span> &ndash; Fade in between t=0 and t=fadein. Default is zero.<br/>
<span class='argname'>fadeout</span> <span class='argtype'>(number, optional)</span> &ndash; Fade out between t=fadeout and t=1. Default is one.<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Draw particle as emissive (glow in the dark). This is useful for fire and embers.
<p>
</p>
<pre class='example'>
function init()
	--Highly emissive at start, not emissive at end
	ParticleEmissive(5, 0)
end

</pre>
<hr/>
<a name='ParticleRotation'></a><h3 class='function'>ParticleRotation</h3>
<pre class='funcdef'><span class='retname'></span>ParticleRotation(<span class='argname'>r0, [r1], [interpolation], [fadein], [fadeout]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>r0</span> <span class='argtype'>(number)</span> &ndash; Rotation speed in radians per second.<br/>
<span class='argname'>r1</span> <span class='argtype'>(number, optional)</span> &ndash; End rotation speed in radians per second.<br/>
<span class='argname'>interpolation</span> <span class='argtype'>(string, optional)</span> &ndash; Interpolation method: linear, smooth, easein, easeout or constant. Default is linear.<br/>
<span class='argname'>fadein</span> <span class='argtype'>(number, optional)</span> &ndash; Fade in between t=0 and t=fadein. Default is zero.<br/>
<span class='argname'>fadeout</span> <span class='argtype'>(number, optional)</span> &ndash; Fade out between t=fadeout and t=1. Default is one.<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Makes the particle rotate. Positive values is counter-clockwise rotation.
<p>
</p>
<pre class='example'>
function init()
	--Rotate fast at start and slow at end
	ParticleRotation(10, 1)
end

</pre>
<hr/>
<a name='ParticleStretch'></a><h3 class='function'>ParticleStretch</h3>
<pre class='funcdef'><span class='retname'></span>ParticleStretch(<span class='argname'>s0, [s1], [interpolation], [fadein], [fadeout]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>s0</span> <span class='argtype'>(number)</span> &ndash; Stretch<br/>
<span class='argname'>s1</span> <span class='argtype'>(number, optional)</span> &ndash; End stretch<br/>
<span class='argname'>interpolation</span> <span class='argtype'>(string, optional)</span> &ndash; Interpolation method: linear, smooth, easein, easeout or constant. Default is linear.<br/>
<span class='argname'>fadein</span> <span class='argtype'>(number, optional)</span> &ndash; Fade in between t=0 and t=fadein. Default is zero.<br/>
<span class='argname'>fadeout</span> <span class='argtype'>(number, optional)</span> &ndash; Fade out between t=fadeout and t=1. Default is one.<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Stretch particle along with velocity. 0.0 means no stretching. 1.0 stretches with the particle motion over
one frame. Larger values stretches the particle even more.
<p>
</p>
<pre class='example'>
function init()
	--Stretch particle along direction of motion
	ParticleStretch(1.0)
end

</pre>
<hr/>
<a name='ParticleSticky'></a><h3 class='function'>ParticleSticky</h3>
<pre class='funcdef'><span class='retname'></span>ParticleSticky(<span class='argname'>s0, [s1], [interpolation], [fadein], [fadeout]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>s0</span> <span class='argtype'>(number)</span> &ndash; Sticky (0.0 - 1.0)<br/>
<span class='argname'>s1</span> <span class='argtype'>(number, optional)</span> &ndash; End sticky (0.0 - 1.0)<br/>
<span class='argname'>interpolation</span> <span class='argtype'>(string, optional)</span> &ndash; Interpolation method: linear, smooth, easein, easeout or constant. Default is linear.<br/>
<span class='argname'>fadein</span> <span class='argtype'>(number, optional)</span> &ndash; Fade in between t=0 and t=fadein. Default is zero.<br/>
<span class='argname'>fadeout</span> <span class='argtype'>(number, optional)</span> &ndash; Fade out between t=fadeout and t=1. Default is one.<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Make particle stick when in contact with objects. This can be used for friction.
<p>
</p>
<pre class='example'>
function init()
	--Make particles stick to objects
	ParticleSticky(0.5)
end

</pre>
<hr/>
<a name='ParticleCollide'></a><h3 class='function'>ParticleCollide</h3>
<pre class='funcdef'><span class='retname'></span>ParticleCollide(<span class='argname'>c0, [c1], [interpolation], [fadein], [fadeout]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>c0</span> <span class='argtype'>(number)</span> &ndash; Collide (0.0 - 1.0)<br/>
<span class='argname'>c1</span> <span class='argtype'>(number, optional)</span> &ndash; End collide (0.0 - 1.0)<br/>
<span class='argname'>interpolation</span> <span class='argtype'>(string, optional)</span> &ndash; Interpolation method: linear, smooth, easein, easeout or constant. Default is linear.<br/>
<span class='argname'>fadein</span> <span class='argtype'>(number, optional)</span> &ndash; Fade in between t=0 and t=fadein. Default is zero.<br/>
<span class='argname'>fadeout</span> <span class='argtype'>(number, optional)</span> &ndash; Fade out between t=fadeout and t=1. Default is one.<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Control particle collisions. A value of zero means that collisions are ignored. One means full collision.
It is sometimes useful to animate this value from zero to one in order to not collide with objects around
the emitter.
<p>
</p>
<pre class='example'>
function init()
	--Disable collisions
	ParticleCollide(0)

	--Enable collisions over time
	ParticleCollide(0, 1)

	--Ramp up collisions very quickly, only skipping the first 5% of lifetime
	ParticleCollide(1, 1, "constant", 0.05)
end

</pre>
<hr/>
<a name='ParticleFlags'></a><h3 class='function'>ParticleFlags</h3>
<pre class='funcdef'><span class='retname'></span>ParticleFlags(<span class='argname'>bitmask</span>)</pre>
<p>Arguments<br/>
<span class='argname'>bitmask</span> <span class='argtype'>(number)</span> &ndash; Particle flags (bitmask 0-65535)<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Set particle bitmask. The value 256 means fire extinguishing particles and is currently the only 
flag in use. There might be support for custom flags and queries in the future.
<p>
</p>
<pre class='example'>
function tick()
	--Fire extinguishing particle
	ParticleFlags(256)
	SpawnParticle(Vec(0, 10, 0), -0.1, math.random() + 1)
end

</pre>
<hr/>
<a name='SpawnParticle'></a><h3 class='function'>SpawnParticle</h3>
<pre class='funcdef'><span class='retname'></span>SpawnParticle(<span class='argname'>pos, velocity, lifetime</span>)</pre>
<p>Arguments<br/>
<span class='argname'>pos</span> <span class='argtype'>(TVec)</span> &ndash; World space point as vector<br/>
<span class='argname'>velocity</span> <span class='argtype'>(TVec)</span> &ndash; World space velocity as vector<br/>
<span class='argname'>lifetime</span> <span class='argtype'>(number)</span> &ndash; Particle lifetime in seconds<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Spawn particle using the previously set up particle state. You can call this multiple times
using the same particle state, but with different position, velocity and lifetime. You can
also modify individual properties in the particle state in between calls to to this function.
<p>
</p>
<pre class='example'>
function tick()
	ParticleReset()
	ParticleType("smoke")
	ParticleColor(0.7, 0.6, 0.5)
	--Spawn particle at world origo with upwards velocity and a lifetime of ten seconds
	SpawnParticle(Vec(0, 5, 0), Vec(0, 1, 0), 10.0)
end

</pre>
<hr/>
<a name='Spawn'></a><h3 class='function'>Spawn</h3>
<pre class='funcdef'><span class='retname'>entities = </span>Spawn(<span class='argname'>xml, transform, [allowStatic], [jointExisting]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>xml</span> <span class='argtype'>(string)</span> &ndash; File name or xml string<br/>
<span class='argname'>transform</span> <span class='argtype'>(TTransform)</span> &ndash; Spawn transform<br/>
<span class='argname'>allowStatic</span> <span class='argtype'>(boolean, optional)</span> &ndash; Allow spawning static shapes and bodies (default false)<br/>
<span class='argname'>jointExisting</span> <span class='argtype'>(boolean, optional)</span> &ndash; Allow joints to connect to existing scene geometry (default false)<br/>
<p>Return value<br/>
<span class='retname'>entities</span> <span class='argtype'>(table)</span> &ndash; Indexed table with handles to all spawned entities<br/>
<p>The first argument can be either a prefab XML file in your mod folder or a string with XML content. It is also 
possible to spawn prefabs from other mods, by using the mod id followed by colon, followed by the prefab path.
Spawning prefabs from other mods should be used with causion since the referenced mod might not be installed.
<p>
</p>
<pre class='example'>
function init()
	Spawn("MOD/prefab/mycar.xml", Transform(Vec(0, 5, 0)))
	Spawn("&lt;voxbox size='10 10 10' prop='true' material='wood'/&gt;", Transform(Vec(0, 10, 0)))
end

</pre>
<hr/>
<a name='SpawnLayer'></a><h3 class='function'>SpawnLayer</h3>
<pre class='funcdef'><span class='retname'>entities = </span>SpawnLayer(<span class='argname'>xml, layer, transform, [allowStatic], [jointExisting]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>xml</span> <span class='argtype'>(string)</span> &ndash; File name or xml string<br/>
<span class='argname'>layer</span> <span class='argtype'>(string)</span> &ndash; Vox layer name<br/>
<span class='argname'>transform</span> <span class='argtype'>(TTransform)</span> &ndash; Spawn transform<br/>
<span class='argname'>allowStatic</span> <span class='argtype'>(boolean, optional)</span> &ndash; Allow spawning static shapes and bodies (default false)<br/>
<span class='argname'>jointExisting</span> <span class='argtype'>(boolean, optional)</span> &ndash; Allow joints to connect to existing scene geometry (default false)<br/>
<p>Return value<br/>
<span class='retname'>entities</span> <span class='argtype'>(table)</span> &ndash; Indexed table with handles to all spawned entities<br/>
<p>Same functionality as Spawn(), except using a specific layer in the vox-file
<p>
</p>
<pre class='example'>
function init()
	Spawn("MOD/prefab/mycar.xml", "some_vox_layer", Transform(Vec(0, 5, 0)))
	Spawn("&lt;voxbox size='10 10 10' prop='true' material='wood'/&gt;", "some_vox_layer", Transform(Vec(0, 10, 0)))
end

</pre>
<hr/>
<a name='Shoot'></a><h3 class='function'>Shoot</h3>
<pre class='funcdef'><span class='retname'></span>Shoot(<span class='argname'>origin, direction, [type], [strength], [maxDist]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>origin</span> <span class='argtype'>(TVec)</span> &ndash; Origin in world space as vector<br/>
<span class='argname'>direction</span> <span class='argtype'>(TVec)</span> &ndash; Unit length direction as world space vector<br/>
<span class='argname'>type</span> <span class='argtype'>(string, optional)</span> &ndash; Shot type, see description, default is "bullet"<br/>
<span class='argname'>strength</span> <span class='argtype'>(number, optional)</span> &ndash; Strength scaling, default is 1.0<br/>
<span class='argname'>maxDist</span> <span class='argtype'>(number, optional)</span> &ndash; Maximum distance, default is 100.0<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Fire projectile. Type can be one of "bullet", "rocket", "gun" or "shotgun".
For backwards compatilbility, type also accept a number, where 1 is same as "rocket" and anything else "bullet"
Note that this function will only spawn the projectile, not make any sound
Also note that "bullet" and "rocket" are the only projectiles that can hurt the player.
<p>
</p>
<pre class='example'>
function tick()
	Shoot(Vec(0, 10, 0), Vec(0, -1, 0), "shotgun")
end

</pre>
<hr/>
<a name='Paint'></a><h3 class='function'>Paint</h3>
<pre class='funcdef'><span class='retname'></span>Paint(<span class='argname'>origin, radius, [type], [probability]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>origin</span> <span class='argtype'>(TVec)</span> &ndash; Origin in world space as vector<br/>
<span class='argname'>radius</span> <span class='argtype'>(number)</span> &ndash; Affected radius, in range 0.0 to 5.0<br/>
<span class='argname'>type</span> <span class='argtype'>(string, optional)</span> &ndash; Paint type. Can be "explosion" or "spraycan". Default is spraycan.<br/>
<span class='argname'>probability</span> <span class='argtype'>(number, optional)</span> &ndash; Dithering probability between zero and one, default is 1.0<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Tint the color of objects within radius to either black or yellow.
<p>
</p>
<pre class='example'>
function tick()
	Paint(Vec(0, 2, 0), 5.0, "spraycan")
end

</pre>
<hr/>
<a name='PaintRGBA'></a><h3 class='function'>PaintRGBA</h3>
<pre class='funcdef'><span class='retname'></span>PaintRGBA(<span class='argname'>origin, radius, red, green, blue, [alpha], [probability]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>origin</span> <span class='argtype'>(TVec)</span> &ndash; Origin in world space as vector<br/>
<span class='argname'>radius</span> <span class='argtype'>(number)</span> &ndash; Affected radius, in range 0.0 to 5.0<br/>
<span class='argname'>red</span> <span class='argtype'>(number)</span> &ndash; red color value, in range 0.0 to 1.0<br/>
<span class='argname'>green</span> <span class='argtype'>(number)</span> &ndash; green color value, in range 0.0 to 1.0<br/>
<span class='argname'>blue</span> <span class='argtype'>(number)</span> &ndash; blue color value, in range 0.0 to 1.0<br/>
<span class='argname'>alpha</span> <span class='argtype'>(number, optional)</span> &ndash; alpha channel value, in range 0.0 to 1.0<br/>
<span class='argname'>probability</span> <span class='argtype'>(number, optional)</span> &ndash; Dithering probability between zero and one, default is 1.0<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Tint the color of objects within radius to custom RGBA color.
<p>
</p>
<pre class='example'>
function tick()
	PaintRGBA(Vec(0, 5, 0), 5.5, 1.0, 0.0, 0.0)
end

</pre>
<hr/>
<a name='MakeHole'></a><h3 class='function'>MakeHole</h3>
<pre class='funcdef'><span class='retname'>count = </span>MakeHole(<span class='argname'>position, r0, [r1], [r2], [silent]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>position</span> <span class='argtype'>(TVec)</span> &ndash; Hole center point<br/>
<span class='argname'>r0</span> <span class='argtype'>(number)</span> &ndash; Hole radius for soft materials<br/>
<span class='argname'>r1</span> <span class='argtype'>(number, optional)</span> &ndash; Hole radius for medium materials. May not be bigger than r0. Default zero.<br/>
<span class='argname'>r2</span> <span class='argtype'>(number, optional)</span> &ndash; Hole radius for hard materials. May not be bigger than r1. Default zero.<br/>
<span class='argname'>silent</span> <span class='argtype'>(boolean, optional)</span> &ndash; Make hole without playing any break sounds.<br/>
<p>Return value<br/>
<span class='retname'>count</span> <span class='argtype'>(number)</span> &ndash; Number of voxels that was cut out. This will be zero if there were no changes to any shape.<br/>
<p>Make a hole in the environment. Radius is given in meters. 
Soft materials: glass, foliage, dirt, wood, plaster and plastic. 
Medium materials: concrete, brick and weak metal. 
Hard materials: hard metal and hard masonry.
<p>
</p>
<pre class='example'>
function init()
	MakeHole(Vec(0, 0, 0), 5.0, 1.0)
end

</pre>
<hr/>
<a name='Explosion'></a><h3 class='function'>Explosion</h3>
<pre class='funcdef'><span class='retname'></span>Explosion(<span class='argname'>pos, size</span>)</pre>
<p>Arguments<br/>
<span class='argname'>pos</span> <span class='argtype'>(TVec)</span> &ndash; Position in world space as vector<br/>
<span class='argname'>size</span> <span class='argtype'>(number)</span> &ndash; Explosion size from 0.5 to 4.0<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p><p>
</p>
<pre class='example'>
function init()
	Explosion(Vec(0, 5, 0), 1)
end

</pre>
<hr/>
<a name='SpawnFire'></a><h3 class='function'>SpawnFire</h3>
<pre class='funcdef'><span class='retname'></span>SpawnFire(<span class='argname'>pos</span>)</pre>
<p>Arguments<br/>
<span class='argname'>pos</span> <span class='argtype'>(TVec)</span> &ndash; Position in world space as vector<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p><p>
</p>
<pre class='example'>
function tick()
	SpawnFire(Vec(0, 2, 0))
end

</pre>
<hr/>
<a name='GetFireCount'></a><h3 class='function'>GetFireCount</h3>
<pre class='funcdef'><span class='retname'>count = </span>GetFireCount(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>count</span> <span class='argtype'>(number)</span> &ndash; Number of active fires in level<br/>
<p><p>
</p>
<pre class='example'>
function tick()
	local c = GetFireCount()
	DebugPrint("Fire count " .. c)
end

</pre>
<hr/>
<a name='QueryClosestFire'></a><h3 class='function'>QueryClosestFire</h3>
<pre class='funcdef'><span class='retname'>hit, pos = </span>QueryClosestFire(<span class='argname'>origin, maxDist</span>)</pre>
<p>Arguments<br/>
<span class='argname'>origin</span> <span class='argtype'>(TVec)</span> &ndash; World space position as vector<br/>
<span class='argname'>maxDist</span> <span class='argtype'>(number)</span> &ndash; Maximum search distance<br/>
<p>Return value<br/>
<span class='retname'>hit</span> <span class='argtype'>(boolean)</span> &ndash; A fire was found within search distance<br/>
<span class='retname'>pos</span> <span class='argtype'>(TVec)</span> &ndash; Position of closest fire<br/>
<p><p>
</p>
<pre class='example'>
function tick()
	local hit, pos = QueryClosestFire(GetPlayerTransform().pos, 5.0)
	if hit then
		--There is a fire within 5 meters to the player. Mark it with a debug cross.
		DebugCross(pos)
	end
end

</pre>
<hr/>
<a name='QueryAabbFireCount'></a><h3 class='function'>QueryAabbFireCount</h3>
<pre class='funcdef'><span class='retname'>count = </span>QueryAabbFireCount(<span class='argname'>min, max</span>)</pre>
<p>Arguments<br/>
<span class='argname'>min</span> <span class='argtype'>(TVec)</span> &ndash; Aabb minimum point<br/>
<span class='argname'>max</span> <span class='argtype'>(TVec)</span> &ndash; Aabb maximum point<br/>
<p>Return value<br/>
<span class='retname'>count</span> <span class='argtype'>(number)</span> &ndash; Number of active fires in bounding box<br/>
<p><p>
</p>
<pre class='example'>
function tick()
	local count = QueryAabbFireCount(Vec(0,0,0), Vec(10,10,10))
	DebugPrint(count)
end

</pre>
<hr/>
<a name='RemoveAabbFires'></a><h3 class='function'>RemoveAabbFires</h3>
<pre class='funcdef'><span class='retname'>count = </span>RemoveAabbFires(<span class='argname'>min, max</span>)</pre>
<p>Arguments<br/>
<span class='argname'>min</span> <span class='argtype'>(TVec)</span> &ndash; Aabb minimum point<br/>
<span class='argname'>max</span> <span class='argtype'>(TVec)</span> &ndash; Aabb maximum point<br/>
<p>Return value<br/>
<span class='retname'>count</span> <span class='argtype'>(number)</span> &ndash; Number of fires removed<br/>
<p><p>
</p>
<pre class='example'>
function tick()
	local removedCount= RemoveAabbFires(Vec(0,0,0), Vec(10,10,10))
	DebugPrint(removedCount)
end

</pre>
<hr/>
<a name='GetCameraTransform'></a><h3 class='function'>GetCameraTransform</h3>
<pre class='funcdef'><span class='retname'>transform = </span>GetCameraTransform(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>transform</span> <span class='argtype'>(TTransform)</span> &ndash; Current camera transform<br/>
<p><p>
</p>
<pre class='example'>
function tick()
	local t = GetCameraTransform()
	DebugPrint(TransformStr(t))
end

</pre>
<hr/>
<a name='SetCameraTransform'></a><h3 class='function'>SetCameraTransform</h3>
<pre class='funcdef'><span class='retname'></span>SetCameraTransform(<span class='argname'>transform, [fov]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>transform</span> <span class='argtype'>(TTransform)</span> &ndash; Desired camera transform<br/>
<span class='argname'>fov</span> <span class='argtype'>(number, optional)</span> &ndash; Optional horizontal field of view in degrees (default: 90)<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Override current camera transform for this frame. Call continuously to keep overriding.
When transform of some shape or body used to calculate camera transform, consider use of AttachCameraTo,
because you might be using transform from previous physics update
(that was on previous frame or even earlier depending on fps and timescale).
<p>
</p>
<pre class='example'>
function tick()
	SetCameraTransform(Transform(Vec(0, 10, 0), QuatEuler(0, 90, 0)))
end

</pre>
<hr/>
<a name='RequestFirstPerson'></a><h3 class='function'>RequestFirstPerson</h3>
<pre class='funcdef'><span class='retname'></span>RequestFirstPerson(<span class='argname'>transition</span>)</pre>
<p>Arguments<br/>
<span class='argname'>transition</span> <span class='argtype'>(boolean)</span> &ndash; Use transition<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Use this function to switch to first-person view, overriding the player's selected third-person view. 
This is particularly useful for scenarios like looking through a camera viewfinder or a rifle scope. 
Call the function continuously to maintain the override.
<p>
</p>
<pre class='example'>
function tick()
	if useViewFinder then
		RequestFirstPerson(true)
	end
end

function draw()
	if useViewFinder and !GetBool("game.thirdperson") then
		-- Draw view finder overlay
	end
end

</pre>
<hr/>
<a name='RequestThirdPerson'></a><h3 class='function'>RequestThirdPerson</h3>
<pre class='funcdef'><span class='retname'></span>RequestThirdPerson(<span class='argname'>transition</span>)</pre>
<p>Arguments<br/>
<span class='argname'>transition</span> <span class='argtype'>(boolean)</span> &ndash; Use transition<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Use this function to switch to third-person view, overriding the player's selected first-person view. 
Call the function continuously to maintain the override.
<p>
</p>
<pre class='example'>
function tick()
	if useThirdPerson then
		RequestThirdPerson(true)
	end
end

</pre>
<hr/>
<a name='SetCameraOffsetTransform'></a><h3 class='function'>SetCameraOffsetTransform</h3>
<pre class='funcdef'><span class='retname'></span>SetCameraOffsetTransform(<span class='argname'>transform, [stackable]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>transform</span> <span class='argtype'>(TTransform)</span> &ndash; Desired camera offset transform<br/>
<span class='argname'>stackable</span> <span class='argtype'>(boolean, optional)</span> &ndash; True if camera offset should summ up with multiple calls per tick<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Call this function continously to apply a camera offset. Can be used for camera effects
such as shake and wobble.
<p>
</p>
<pre class='example'>
function tick()
	local tPosX = Transform(Vec(math.sin(GetTime()*3.0) * 0.2, 0, 0))
	local tPosY = Transform(Vec(0, math.cos(GetTime()*3.0) * 0.2, 0), QuatAxisAngle(Vec(0, 0, 0)))

	SetCameraOffsetTransform(tPosX, true)
	SetCameraOffsetTransform(tPosY, true)
end

</pre>
<hr/>
<a name='AttachCameraTo'></a><h3 class='function'>AttachCameraTo</h3>
<pre class='funcdef'><span class='retname'></span>AttachCameraTo(<span class='argname'>handle, [ignoreRotation]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(number)</span> &ndash; Body or shape handle<br/>
<span class='argname'>ignoreRotation</span> <span class='argtype'>(boolean, optional)</span> &ndash; True to ignore rotation and use position only, false to use full transform<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Attach current camera transform for this frame to body or shape. Call continuously to keep overriding.
In tick function we have coordinates of bodies and shapes that are not yet updated by physics,
that's why camera can not be in sync with it using SetCameraTransform,
instead use this function and SetCameraOffsetTransform to place camera around any body or shape without lag.
<p>
</p>
<pre class='example'>
function tick()
	local vehicle = GetPlayerVehicle()
	if vehicle ~= 0 then
		AttachCameraTo(GetVehicleBody(vehicle))
		SetCameraOffsetTransform(Transform(Vec(1, 2, 3)))
	end
end

</pre>
<hr/>
<a name='SetPivotClipBody'></a><h3 class='function'>SetPivotClipBody</h3>
<pre class='funcdef'><span class='retname'></span>SetPivotClipBody(<span class='argname'>bodyHandle, mainShapeIdx</span>)</pre>
<p>Arguments<br/>
<span class='argname'>bodyHandle</span> <span class='argtype'>(number)</span> &ndash; Handle of a body, shapes of which should be<br/>
<span class='argname'>mainShapeIdx</span> <span class='argtype'>(number)</span> &ndash; Optional index of a shape among the given<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>treated as pivots when clipping
body's shapes which is used to calculate clipping parameters
(default: -1)
Enforce camera clipping for this frame and mark the given body as a
pivot for clipping. Call continuously to keep overriding.
<p>
</p>
<pre class='example'>
local body_1 = 0
local body_2 = 0
function init()
	body_1 = FindBody("body_1")
	body_2 = FindBody("body_2")
end

function tick()
	SetPivotClipBody(body_1, 0) -- this overload should be called once and
	-- only once per frame to take effect
	SetPivotClipBody(body_2)
end

</pre>
<hr/>
<a name='ShakeCamera'></a><h3 class='function'>ShakeCamera</h3>
<pre class='funcdef'><span class='retname'></span>ShakeCamera(<span class='argname'>strength</span>)</pre>
<p>Arguments<br/>
<span class='argname'>strength</span> <span class='argtype'>(number)</span> &ndash; Normalized strength of shaking<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Shakes the player camera
<p>
</p>
<pre class='example'>
function tick()
	ShakeCamera(0.5)
end

</pre>
<hr/>
<a name='SetCameraFov'></a><h3 class='function'>SetCameraFov</h3>
<pre class='funcdef'><span class='retname'></span>SetCameraFov(<span class='argname'>degrees</span>)</pre>
<p>Arguments<br/>
<span class='argname'>degrees</span> <span class='argtype'>(number)</span> &ndash; Horizontal field of view in degrees (10-170)<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Override field of view for the next frame for all camera modes, except when explicitly set in SetCameraTransform
<p>
</p>
<pre class='example'>
function tick()
	SetCameraFov(60)
end

</pre>
<hr/>
<a name='SetCameraDof'></a><h3 class='function'>SetCameraDof</h3>
<pre class='funcdef'><span class='retname'></span>SetCameraDof(<span class='argname'>distance, [amount]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>distance</span> <span class='argtype'>(number)</span> &ndash; Depth of field distance<br/>
<span class='argname'>amount</span> <span class='argtype'>(number, optional)</span> &ndash; Optional amount of blur (default 1.0)<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Override depth of field for the next frame for all camera modes. Depth of field will be used even if turned off in options.
<p>
</p>
<pre class='example'>
function tick()
	--Set depth of field to 10 meters
	SetCameraDof(10)
end

</pre>
<hr/>
<a name='PointLight'></a><h3 class='function'>PointLight</h3>
<pre class='funcdef'><span class='retname'></span>PointLight(<span class='argname'>pos, r, g, b, [intensity]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>pos</span> <span class='argtype'>(TVec)</span> &ndash; World space light position<br/>
<span class='argname'>r</span> <span class='argtype'>(number)</span> &ndash; Red<br/>
<span class='argname'>g</span> <span class='argtype'>(number)</span> &ndash; Green<br/>
<span class='argname'>b</span> <span class='argtype'>(number)</span> &ndash; Blue<br/>
<span class='argname'>intensity</span> <span class='argtype'>(number, optional)</span> &ndash; Intensity. Default is 1.0.<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Add a temporary point light to the world for this frame. Call continuously
for a steady light.
<p>
</p>
<pre class='example'>
function tick()
	--Pulsating, yellow light above world origo
	local intensity = 3 + math.sin(GetTime())
	PointLight(Vec(0, 5, 0), 1, 1, 0, intensity)
end

</pre>
<hr/>
<a name='SetTimeScale'></a><h3 class='function'>SetTimeScale</h3>
<pre class='funcdef'><span class='retname'></span>SetTimeScale(<span class='argname'>scale</span>)</pre>
<p>Arguments<br/>
<span class='argname'>scale</span> <span class='argtype'>(number)</span> &ndash; Time scale 0.0 to 2.0<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Experimental. Scale time in order to make a slow-motion or acceleration effect. Audio will also be affected.
(v1.4 and below: this function will affect physics behavior and is not intended for gameplay purposes.)
Starting from v1.5 this function does not affect physics behavior and rely on rendering interpolation.
Scaling time up may decrease performance, and is not recommended for gameplay purposes.
Calling this function will change time scale for the next frame only.
Call every frame from tick function to get steady slow-motion.
<p>
</p>
<pre class='example'>
function tick()
	--Slow down time when holding down a key
	if InputDown('t') then
		SetTimeScale(0.2)
	end
end

</pre>
<hr/>
<a name='SetEnvironmentDefault'></a><h3 class='function'>SetEnvironmentDefault</h3>
<pre class='funcdef'><span class='retname'></span>SetEnvironmentDefault(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Reset the environment properties to default. This is often useful before 
setting up a custom environment.
<p>
</p>
<pre class='example'>
function init()
	SetEnvironmentDefault()
end

</pre>
<hr/>
<a name='SetEnvironmentProperty'></a><h3 class='function'>SetEnvironmentProperty</h3>
<pre class='funcdef'><span class='retname'></span>SetEnvironmentProperty(<span class='argname'>name, value0, [value1], [value2], [value3]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>name</span> <span class='argtype'>(string)</span> &ndash; Property name<br/>
<span class='argname'>value0</span> <span class='argtype'>(any)</span> &ndash; Property value (type depends on property)<br/>
<span class='argname'>value1</span> <span class='argtype'>(any, optional)</span> &ndash; Extra property value (only some properties)<br/>
<span class='argname'>value2</span> <span class='argtype'>(any, optional)</span> &ndash; Extra property value (only some properties)<br/>
<span class='argname'>value3</span> <span class='argtype'>(any, optional)</span> &ndash; Extra property value (only some properties)<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>This function is used for manipulating the environment properties. The available properties are 
exactly the same as in the editor, except for "snowonground" which is not currently supported.
<p>
</p>
<pre class='example'>
function init()
	SetEnvironmentDefault()
	SetEnvironmentProperty("skybox", "cloudy.dds")
	SetEnvironmentProperty("rain", 0.7)
	SetEnvironmentProperty("fogcolor", 0.5, 0.5, 0.8)
	SetEnvironmentProperty("nightlight", false)
end

</pre>
<hr/>
<a name='GetEnvironmentProperty'></a><h3 class='function'>GetEnvironmentProperty</h3>
<pre class='funcdef'><span class='retname'>value0, value1, value2, value3, value4 = </span>GetEnvironmentProperty(<span class='argname'>name</span>)</pre>
<p>Arguments<br/>
<span class='argname'>name</span> <span class='argtype'>(string)</span> &ndash; Property name<br/>
<p>Return value<br/>
<span class='retname'>value0</span> <span class='argtype'>(any)</span> &ndash; Property value (type depends on property)<br/>
<span class='retname'>value1</span> <span class='argtype'>(any)</span> &ndash; Property value (only some properties)<br/>
<span class='retname'>value2</span> <span class='argtype'>(any)</span> &ndash; Property value (only some properties)<br/>
<span class='retname'>value3</span> <span class='argtype'>(any)</span> &ndash; Property value (only some properties)<br/>
<span class='retname'>value4</span> <span class='argtype'>(any)</span> &ndash; Property value (only some properties)<br/>
<p>This function is used for querying the current environment properties. The available properties are
exactly the same as in the editor.
<p>
</p>
<pre class='example'>
function init()
	local skyboxPath = GetEnvironmentProperty("skybox")
	local rainValue = GetEnvironmentProperty("rain")
	local r,g,b = GetEnvironmentProperty("fogcolor")
	local enabled = GetEnvironmentProperty("nightlight")
	DebugPrint(skyboxPath)
	DebugPrint(rainValue)
	DebugPrint(r .. " " .. g .. " " .. b)
	DebugPrint(enabled)
end

</pre>
<hr/>
<a name='SetPostProcessingDefault'></a><h3 class='function'>SetPostProcessingDefault</h3>
<pre class='funcdef'><span class='retname'></span>SetPostProcessingDefault(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Reset the post processing properties to default.
<p>
</p>
<pre class='example'>
function tick()
	SetPostProcessingProperty("saturation", 0.4)
	SetPostProcessingProperty("colorbalance", 1.3, 1.0, 0.7)
	SetPostProcessingDefault()
end

</pre>
<hr/>
<a name='SetPostProcessingProperty'></a><h3 class='function'>SetPostProcessingProperty</h3>
<pre class='funcdef'><span class='retname'></span>SetPostProcessingProperty(<span class='argname'>name, value0, [value1], [value2]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>name</span> <span class='argtype'>(string)</span> &ndash; Property name<br/>
<span class='argname'>value0</span> <span class='argtype'>(number)</span> &ndash; Property value<br/>
<span class='argname'>value1</span> <span class='argtype'>(number, optional)</span> &ndash; Extra property value (only some properties)<br/>
<span class='argname'>value2</span> <span class='argtype'>(number, optional)</span> &ndash; Extra property value (only some properties)<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>This function is used for manipulating the post processing properties. The available properties are
exactly the same as in the editor.
<p>
</p>
<pre class='example'>
--Sepia post processing
function tick()
	SetPostProcessingProperty("saturation", 0.4)
	SetPostProcessingProperty("colorbalance", 1.3, 1.0, 0.7)
end

</pre>
<hr/>
<a name='GetPostProcessingProperty'></a><h3 class='function'>GetPostProcessingProperty</h3>
<pre class='funcdef'><span class='retname'>value0, value1, value2 = </span>GetPostProcessingProperty(<span class='argname'>name</span>)</pre>
<p>Arguments<br/>
<span class='argname'>name</span> <span class='argtype'>(string)</span> &ndash; Property name<br/>
<p>Return value<br/>
<span class='retname'>value0</span> <span class='argtype'>(number)</span> &ndash; Property value<br/>
<span class='retname'>value1</span> <span class='argtype'>(number)</span> &ndash; Property value (only some properties)<br/>
<span class='retname'>value2</span> <span class='argtype'>(number)</span> &ndash; Property value (only some properties)<br/>
<p>This function is used for querying the current post processing properties. 
The available properties are exactly the same as in the editor.
<p>
</p>
<pre class='example'>
function tick()
	SetPostProcessingProperty("saturation", 0.4)
	SetPostProcessingProperty("colorbalance", 1.3, 1.0, 0.7)
	local saturation = GetPostProcessingProperty("saturation")
	local r,g,b = GetPostProcessingProperty("colorbalance")
	DebugPrint("saturation " .. saturation)
	DebugPrint("colorbalance " .. r .. " " .. g .. " " .. b)
end

</pre>
<hr/>
<a name='DrawLine'></a><h3 class='function'>DrawLine</h3>
<pre class='funcdef'><span class='retname'></span>DrawLine(<span class='argname'>p0, p1, [r], [g], [b], [a]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>p0</span> <span class='argtype'>(TVec)</span> &ndash; World space point as vector<br/>
<span class='argname'>p1</span> <span class='argtype'>(TVec)</span> &ndash; World space point as vector<br/>
<span class='argname'>r</span> <span class='argtype'>(number, optional)</span> &ndash; Red<br/>
<span class='argname'>g</span> <span class='argtype'>(number, optional)</span> &ndash; Green<br/>
<span class='argname'>b</span> <span class='argtype'>(number, optional)</span> &ndash; Blue<br/>
<span class='argname'>a</span> <span class='argtype'>(number, optional)</span> &ndash; Alpha<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Draw a 3D line. In contrast to DebugLine, it will not show behind objects. Default color is white.
<p>
</p>
<pre class='example'>
function tick()
	--Draw white debug line
	DrawLine(Vec(0, 0, 0), Vec(-10, 5, -10))

	--Draw red debug line
	DrawLine(Vec(0, 0, 0), Vec(10, 5, 10), 1, 0, 0)
end

</pre>
<hr/>
<a name='DebugLine'></a><h3 class='function'>DebugLine</h3>
<pre class='funcdef'><span class='retname'></span>DebugLine(<span class='argname'>p0, p1, [r], [g], [b], [a]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>p0</span> <span class='argtype'>(TVec)</span> &ndash; World space point as vector<br/>
<span class='argname'>p1</span> <span class='argtype'>(TVec)</span> &ndash; World space point as vector<br/>
<span class='argname'>r</span> <span class='argtype'>(number, optional)</span> &ndash; Red<br/>
<span class='argname'>g</span> <span class='argtype'>(number, optional)</span> &ndash; Green<br/>
<span class='argname'>b</span> <span class='argtype'>(number, optional)</span> &ndash; Blue<br/>
<span class='argname'>a</span> <span class='argtype'>(number, optional)</span> &ndash; Alpha<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Draw a 3D debug overlay line in the world. Default color is white.
<p>
</p>
<pre class='example'>
function tick()
	--Draw white debug line
	DebugLine(Vec(0, 0, 0), Vec(-10, 5, -10))

	--Draw red debug line
	DebugLine(Vec(0, 0, 0), Vec(10, 5, 10), 1, 0, 0)
end

</pre>
<hr/>
<a name='DebugCross'></a><h3 class='function'>DebugCross</h3>
<pre class='funcdef'><span class='retname'></span>DebugCross(<span class='argname'>p0, [r], [g], [b], [a]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>p0</span> <span class='argtype'>(TVec)</span> &ndash; World space point as vector<br/>
<span class='argname'>r</span> <span class='argtype'>(number, optional)</span> &ndash; Red<br/>
<span class='argname'>g</span> <span class='argtype'>(number, optional)</span> &ndash; Green<br/>
<span class='argname'>b</span> <span class='argtype'>(number, optional)</span> &ndash; Blue<br/>
<span class='argname'>a</span> <span class='argtype'>(number, optional)</span> &ndash; Alpha<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Draw a debug cross in the world to highlight a location. Default color is white.
<p>
</p>
<pre class='example'>
function tick()
	DebugCross(Vec(10, 5, 5))
end

</pre>
<hr/>
<a name='DebugTransform'></a><h3 class='function'>DebugTransform</h3>
<pre class='funcdef'><span class='retname'></span>DebugTransform(<span class='argname'>transform, [scale]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>transform</span> <span class='argtype'>(TTransform)</span> &ndash; The transform<br/>
<span class='argname'>scale</span> <span class='argtype'>(number, optional)</span> &ndash; Length of the axis<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Draw the axis of the transform
<p>
</p>
<pre class='example'>
function tick()
	DebugTransform(GetPlayerCameraTransform(), 0.5)
end

</pre>
<hr/>
<a name='DebugWatch'></a><h3 class='function'>DebugWatch</h3>
<pre class='funcdef'><span class='retname'></span>DebugWatch(<span class='argname'>name, value, [lineWrapping]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>name</span> <span class='argtype'>(string)</span> &ndash; Name<br/>
<span class='argname'>value</span> <span class='argtype'>(string)</span> &ndash; Value<br/>
<span class='argname'>lineWrapping</span> <span class='argtype'>(boolean, optional)</span> &ndash; True if you need to wrap Table lines. Works only with tables.<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Show a named valued on screen for debug purposes.
Up to 32 values can be shown simultaneously. Values updated the current
frame are drawn opaque. Old values are drawn transparent in white.
<p>
The function will also recognize tables and convert them to strings automatically.
<p>
</p>
<pre class='example'>
function tick()
	DebugWatch("Player camera transform", GetPlayerCameraTransform())

	local anyTable = {
		"teardown",
		{
			name = "Alex",
			age = 25,
			child = { name = "Lena" }
		},
		nil,
		version = "1.6.0",
		true
	}
	DebugWatch("table", anyTable);
end

</pre>
<hr/>
<a name='DebugPrint'></a><h3 class='function'>DebugPrint</h3>
<pre class='funcdef'><span class='retname'></span>DebugPrint(<span class='argname'>message, [lineWrapping]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>message</span> <span class='argtype'>(string)</span> &ndash; Message to display<br/>
<span class='argname'>lineWrapping</span> <span class='argtype'>(boolean, optional)</span> &ndash; True if you need to wrap Table lines. Works only with tables.<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Display message on screen. The last 20 lines are displayed.
The function will also recognize tables and convert them to strings automatically.
<p>
</p>
<pre class='example'>
function init()
	DebugPrint("time")

	DebugPrint(GetPlayerCameraTransform())

	local anyTable = {
		"teardown",
		{
			name = "Alex",
			age = 25,
			child = { name = "Lena" }
		},
		nil,
		version = "1.6.0",
		true,
	}
	DebugPrint(anyTable)
end

</pre>
<hr/>
<a name='RegisterListenerTo'></a><h3 class='function'>RegisterListenerTo</h3>
<pre class='funcdef'><span class='retname'></span>RegisterListenerTo(<span class='argname'>eventName, listenerFunction</span>)</pre>
<p>Arguments<br/>
<span class='argname'>eventName</span> <span class='argtype'>(string)</span> &ndash; Event name<br/>
<span class='argname'>listenerFunction</span> <span class='argtype'>(string)</span> &ndash; Listener function name<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Binds the callback function on the event
<p>
</p>
<pre class='example'>
function onLangauageChanged()
	DebugPrint("langauageChanged")
end

function init()
	RegisterListenerTo("LanguageChanged", "onLangauageChanged")
	TriggerEvent("LanguageChanged")
end

</pre>
<hr/>
<a name='UnregisterListener'></a><h3 class='function'>UnregisterListener</h3>
<pre class='funcdef'><span class='retname'></span>UnregisterListener(<span class='argname'>eventName, listenerFunction</span>)</pre>
<p>Arguments<br/>
<span class='argname'>eventName</span> <span class='argtype'>(string)</span> &ndash; Event name<br/>
<span class='argname'>listenerFunction</span> <span class='argtype'>(string)</span> &ndash; Listener function name<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Unbinds the callback function from the event
<p>
</p>
<pre class='example'>
function onLangauageChanged()
	DebugPrint("langauageChanged")
end

function init()
	RegisterListenerTo("LanguageChanged", "onLangauageChanged")
	UnregisterListener("LanguageChanged", "onLangauageChanged")
	TriggerEvent("LanguageChanged")
end

</pre>
<hr/>
<a name='TriggerEvent'></a><h3 class='function'>TriggerEvent</h3>
<pre class='funcdef'><span class='retname'></span>TriggerEvent(<span class='argname'>eventName, [args]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>eventName</span> <span class='argtype'>(string)</span> &ndash; Event name<br/>
<span class='argname'>args</span> <span class='argtype'>(string, optional)</span> &ndash; Event parameters<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Triggers an event for all registered listeners
<p>
</p>
<pre class='example'>
function onLangauageChanged()
	DebugPrint("langauageChanged")
end

function init()
	RegisterListenerTo("LanguageChanged", "onLangauageChanged")
	UnregisterListener("LanguageChanged", "onLangauageChanged")
	TriggerEvent("LanguageChanged")
end

</pre>
<hr/>
<a name='LoadHaptic'></a><h3 class='function'>LoadHaptic</h3>
<pre class='funcdef'><span class='retname'>handle = </span>LoadHaptic(<span class='argname'>filepath</span>)</pre>
<p>Arguments<br/>
<span class='argname'>filepath</span> <span class='argtype'>(string)</span> &ndash; Path to Haptic effect to play<br/>
<p>Return value<br/>
<span class='retname'>handle</span> <span class='argtype'>(string)</span> &ndash; Haptic effect handle<br/>
<p><p>
</p>
<pre class='example'>
-- Rumble with gun Haptic effect
function init()
	haptic_effect = LoadHaptic("haptic/gun_fire.xml")
end

function tick()
	if trigHaptic then
		PlayHaptic(haptic_effect, 1)
	end
end

</pre>
<hr/>
<a name='CreateHaptic'></a><h3 class='function'>CreateHaptic</h3>
<pre class='funcdef'><span class='retname'>handle = </span>CreateHaptic(<span class='argname'>leftMotorRumble, rightMotorRumble, leftTriggerRumble, rightTriggerRumble</span>)</pre>
<p>Arguments<br/>
<span class='argname'>leftMotorRumble</span> <span class='argtype'>(number)</span> &ndash; Amount of rumble for left motor<br/>
<span class='argname'>rightMotorRumble</span> <span class='argtype'>(number)</span> &ndash; Amount of rumble for right motor<br/>
<span class='argname'>leftTriggerRumble</span> <span class='argtype'>(number)</span> &ndash; Amount of rumble for left trigger<br/>
<span class='argname'>rightTriggerRumble</span> <span class='argtype'>(number)</span> &ndash; Amount of rumble for right trigger<br/>
<p>Return value<br/>
<span class='retname'>handle</span> <span class='argtype'>(string)</span> &ndash; Haptic effect handle<br/>
<p><p>
</p>
<pre class='example'>
-- Rumble with gun Haptic effect
function init()
	haptic_effect = CreateHaptic(1, 1, 0, 0)
end

function tick()
	if trigHaptic then
		PlayHaptic(haptic_effect, 1)
	end
end

</pre>
<hr/>
<a name='PlayHaptic'></a><h3 class='function'>PlayHaptic</h3>
<pre class='funcdef'><span class='retname'></span>PlayHaptic(<span class='argname'>handle, amplitude</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(string)</span> &ndash; Handle of haptic effect<br/>
<span class='argname'>amplitude</span> <span class='argtype'>(number)</span> &ndash; Amplidute used for calculation of Haptic effect.<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>If Haptic already playing, restarts it.
<p>
</p>
<pre class='example'>
-- Rumble with gun Haptic effect
function init()
	haptic_effect = LoadHaptic("haptic/gun_fire.xml")
end

function tick()
	if trigHaptic then
		PlayHaptic(haptic_effect, 1)
	end
end

</pre>
<hr/>
<a name='PlayHapticDirectional'></a><h3 class='function'>PlayHapticDirectional</h3>
<pre class='funcdef'><span class='retname'></span>PlayHapticDirectional(<span class='argname'>handle, direction, amplitude</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(string)</span> &ndash; Handle of haptic effect<br/>
<span class='argname'>direction</span> <span class='argtype'>(TVec)</span> &ndash; Direction in which effect must be played<br/>
<span class='argname'>amplitude</span> <span class='argtype'>(number)</span> &ndash; Amplidute used for calculation of Haptic effect.<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>If Haptic already playing, restarts it.
<p>
</p>
<pre class='example'>
-- Rumble with gun Haptic effect
local haptic_effect
function init()
	haptic_effect = LoadHaptic("haptic/gun_fire.xml")
end

function tick()
	if InputPressed("interact") then
		PlayHapticDirectional(haptic_effect, Vec(-1, 0, 0), 1)
	end
end

</pre>
<hr/>
<a name='HapticIsPlaying'></a><h3 class='function'>HapticIsPlaying</h3>
<pre class='funcdef'><span class='retname'>flag = </span>HapticIsPlaying(<span class='argname'>handle</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(string)</span> &ndash; Handle of haptic effect<br/>
<p>Return value<br/>
<span class='retname'>flag</span> <span class='argtype'>(boolean)</span> &ndash; is current Haptic playing or not<br/>
<p><p>
</p>
<pre class='example'>
-- Rumble infinitely
local haptic_effect
function init()
	haptic_effect = LoadHaptic("haptic/gun_fire.xml")
end

function tick()
	if not HapticIsPlaying(haptic_effect) then
		PlayHaptic(haptic_effect, 1)
	end
end

</pre>
<hr/>
<a name='SetToolHaptic'></a><h3 class='function'>SetToolHaptic</h3>
<pre class='funcdef'><span class='retname'></span>SetToolHaptic(<span class='argname'>id, handle, [amplitude]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>id</span> <span class='argtype'>(string)</span> &ndash; Tool unique identifier<br/>
<span class='argname'>handle</span> <span class='argtype'>(string)</span> &ndash; Handle of haptic effect<br/>
<span class='argname'>amplitude</span> <span class='argtype'>(number, optional)</span> &ndash; Amplitude multiplier. Default (1.0)<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Register haptic as a "Tool haptic" for custom tools.
"Tool haptic" will be played on repeat while this tool is active.
Also it can be used for Active Triggers of DualSense controller
<p>
</p>
<pre class='example'>
function init()
	RegisterTool("minigun", "loc@MINIGUN", "MOD/vox/minigun.vox")
	toolHaptic = LoadHaptic("MOD/haptic/tool.xml")
	SetToolHaptic("minigun", toolHaptic) 
end

</pre>
<hr/>
<a name='StopHaptic'></a><h3 class='function'>StopHaptic</h3>
<pre class='funcdef'><span class='retname'></span>StopHaptic(<span class='argname'>handle</span>)</pre>
<p>Arguments<br/>
<span class='argname'>handle</span> <span class='argtype'>(string)</span> &ndash; Handle of haptic effect<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p><p>
</p>
<pre class='example'>
-- Rumble infinitely
local haptic_effect
function init()
	haptic_effect = LoadHaptic("haptic/gun_fire.xml")
end

function tick()
    if InputDown("interact") then
        StopHaptic(haptic_effect)
    elseif not HapticIsPlaying(haptic_effect) then
		PlayHaptic(haptic_effect, 1)
    end
end

</pre>
<hr/>
<a name='SetVehicleHealth'></a><h3 class='function'>SetVehicleHealth</h3>
<pre class='funcdef'><span class='retname'></span>SetVehicleHealth(<span class='argname'>vehicle, health</span>)</pre>
<p>Arguments<br/>
<span class='argname'>vehicle</span> <span class='argtype'>(number)</span> &ndash; Vehicle handle<br/>
<span class='argname'>health</span> <span class='argtype'>(number)</span> &ndash; Set vehicle health (between zero and one)<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Works only for vehicles with 'customhealth' tag. 'customhealth' disables the common vehicles damage system.
So this function needed for custom vehicle damage systems.
<p>
</p>
<pre class='example'>
function tick()
	if InputPressed("usetool") then
		SetVehicleHealth(FindVehicle("car", true), 0.0)
	end
end

</pre>
<hr/>
<a name='QueryRaycastWater'></a><h3 class='function'>QueryRaycastWater</h3>
<pre class='funcdef'><span class='retname'>hit, dist, hitPos = </span>QueryRaycastWater(<span class='argname'>origin, direction, maxDist</span>)</pre>
<p>Arguments<br/>
<span class='argname'>origin</span> <span class='argtype'>(TVec)</span> &ndash; Raycast origin as world space vector<br/>
<span class='argname'>direction</span> <span class='argtype'>(TVec)</span> &ndash; Unit length raycast direction as world space vector<br/>
<span class='argname'>maxDist</span> <span class='argtype'>(number)</span> &ndash; Raycast maximum distance. Keep this as low as possible for good performance.<br/>
<p>Return value<br/>
<span class='retname'>hit</span> <span class='argtype'>(boolean)</span> &ndash; True if raycast hit something<br/>
<span class='retname'>dist</span> <span class='argtype'>(number)</span> &ndash; Hit distance from origin<br/>
<span class='retname'>hitPos</span> <span class='argtype'>(TVec)</span> &ndash; Hit point as world space vector<br/>
<p>This will perform a raycast query looking for water.
<p>
</p>
<pre class='example'>
function init()
	--Raycast from a high point straight downwards, looking for water
	local hit, d = QueryRaycast(Vec(0, 100, 0), Vec(0, -1, 0), 100)
	if hit then
		DebugPrint(d)
	end
end

</pre>
<hr/>
<a name='AddHeat'></a><h3 class='function'>AddHeat</h3>
<pre class='funcdef'><span class='retname'></span>AddHeat(<span class='argname'>shape, pos, amount</span>)</pre>
<p>Arguments<br/>
<span class='argname'>shape</span> <span class='argtype'>(number)</span> &ndash; Shape handle<br/>
<span class='argname'>pos</span> <span class='argtype'>(TVec)</span> &ndash; World space point as vector<br/>
<span class='argname'>amount</span> <span class='argtype'>(number)</span> &ndash; amount of heat<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Adds heat to shape. It works similar to blowtorch.
As soon as the heat of the voxel reaches a critical value, it destroys and can ignite the surrounding voxels.
<p>
</p>
<pre class='example'>
function tick(dt)
	if InputDown("usetool") then
		local playerCameraTransform = GetPlayerCameraTransform()
		local dir = TransformToParentVec(playerCameraTransform, Vec(0, 0, -1))

		-- Cast ray out of player camera and add heat to shape if we can find one
		local hit, dist, normal, shape = QueryRaycast(playerCameraTransform.pos, dir, 50)

		if hit then
			local hitPos = VecAdd(playerCameraTransform.pos, VecScale(dir, dist))
			AddHeat(shape, hitPos, 2 * dt)
		end

		DrawLine(VecAdd(playerCameraTransform.pos, Vec(0.5, 0, 0)), VecAdd(playerCameraTransform.pos, VecScale(dir, dist)), 1, 0, 0, 1)
	end
end

</pre>
<hr/>
<a name='GetGravity'></a><h3 class='function'>GetGravity</h3>
<pre class='funcdef'><span class='retname'>vector = </span>GetGravity(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>vector</span> <span class='argtype'>(TVec)</span> &ndash; Gravity vector<br/>
<p>Returns the gravity value on the scene.
<p>
</p>
<pre class='example'>
function tick()
	DebugPrint(VecStr(GetGravity()))
end

</pre>
<hr/>
<a name='SetGravity'></a><h3 class='function'>SetGravity</h3>
<pre class='funcdef'><span class='retname'></span>SetGravity(<span class='argname'>vec</span>)</pre>
<p>Arguments<br/>
<span class='argname'>vec</span> <span class='argtype'>(TVec)</span> &ndash; Gravity vector<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Sets the gravity value on the scene.
When the scene restarts, it resets to the default value (0, -10, 0).
<p>
</p>
<pre class='example'>
local isMoonGravityEnabled = false

function tick()
	if InputPressed("g") then
		isMoonGravityEnabled = not isMoonGravityEnabled
		if isMoonGravityEnabled then
			SetGravity(Vec(0, -1.6, 0))
		else
			SetGravity(Vec(0, -10.0, 0))
		end
	end
end

</pre>
<hr/>
<a name='SetPlayerOrientation'></a><h3 class='function'>SetPlayerOrientation</h3>
<pre class='funcdef'><span class='retname'></span>SetPlayerOrientation(<span class='argname'>orientation</span>)</pre>
<p>Arguments<br/>
<span class='argname'>orientation</span> <span class='argtype'>(Quat)</span> &ndash; Base orientation<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Sets the base orientation when gravity is disabled with SetGravity.
This will determine what direction is "up", "right" and "forward" as
gravity is completely turned off. 
<p>
</p>
<pre class='example'>
function tick()
	SetGravity(Vec(0, 0, 0))

	-- Turn player upside-down.
	local base = QuatAxisAngle(Vec(1,0,0), 180)
	SetPlayerOrientation(base)
end

</pre>
<hr/>
<a name='GetPlayerOrientation'></a><h3 class='function'>GetPlayerOrientation</h3>
<pre class='funcdef'><span class='retname'>orientation = </span>GetPlayerOrientation(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>orientation</span> <span class='argtype'>(TQuat)</span> &ndash; Player base orientation<br/>
<p>Gets the base orientation of the player.
This can be used to retrieve the base orientation of the player when using a custom gravity vector.
<p>
</p>
<pre class='example'>
function tick(dt)
	SetGravity(Vec(0, 0, 0))
	-- Spin the player if using zero gravity 
	local base = QuatRotateQuat(GetPlayerOrientation(), QuatAxisAngle(Vec(1,0,0), dt))
	SetPlayerOrientation(base)
end

</pre>
<hr/>
<a name='GetPlayerUp'></a><h3 class='function'>GetPlayerUp</h3>
<pre class='funcdef'><span class='retname'>up = </span>GetPlayerUp(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>up</span> <span class='argtype'>(TVec)</span> &ndash; Player up vector<br/>
<p>Returns the current "up" vector derived from the player's base orientation.
This can be used to retrieve the player's up vector when using a custom gravity vector.
<p>
</p>
<pre class='example'>
function tick(dt)
	local up = GetPlayerUp()
end

</pre>
<hr/>
<a name='GetFps'></a><h3 class='function'>GetFps</h3>
<pre class='funcdef'><span class='retname'>fps = </span>GetFps(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>fps</span> <span class='argtype'>(number)</span> &ndash; Frames per second<br/>
<p>Returns the fps value based on general game timestep.
It doesn't depend on whether it is called from tick or update.
<p>
</p>
<pre class='example'>
function tick()
	DebugWatch("fps", GetFps())
end

</pre>
<hr/>
<a name='UiMakeInteractive'></a><h3 class='function'>UiMakeInteractive</h3>
<pre class='funcdef'><span class='retname'></span>UiMakeInteractive(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Calling this function will disable game input, bring up the mouse pointer
and allow Ui interaction with the calling script without pausing the game.
This can be useful to make interactive user interfaces from scripts while
the game is running. Call this continuously every frame as long as Ui 
interaction is desired.
<p>
</p>
<pre class='example'>
UiMakeInteractive()

</pre>
<hr/>
<a name='UiPush'></a><h3 class='function'>UiPush</h3>
<pre class='funcdef'><span class='retname'></span>UiPush(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Push state onto stack. This is used in combination with UiPop to
remember a state and restore to that state later.
<p>
</p>
<pre class='example'>
UiColor(1,0,0)
UiText("Red")
UiPush()
	UiColor(0,1,0)
	UiText("Green")
UiPop()
UiText("Red")

</pre>
<hr/>
<a name='UiPop'></a><h3 class='function'>UiPop</h3>
<pre class='funcdef'><span class='retname'></span>UiPop(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Pop state from stack and make it the current one. This is used in
combination with UiPush to remember a previous state and go back to
it later.
<p>
</p>
<pre class='example'>
UiColor(1,0,0)
UiText("Red")
UiPush()
	UiColor(0,1,0)
	UiText("Green")
UiPop()
UiText("Red")

</pre>
<hr/>
<a name='UiWidth'></a><h3 class='function'>UiWidth</h3>
<pre class='funcdef'><span class='retname'>width = </span>UiWidth(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>width</span> <span class='argtype'>(number)</span> &ndash; Width of draw context<br/>
<p><p>
</p>
<pre class='example'>
local w = UiWidth()

</pre>
<hr/>
<a name='UiHeight'></a><h3 class='function'>UiHeight</h3>
<pre class='funcdef'><span class='retname'>height = </span>UiHeight(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>height</span> <span class='argtype'>(number)</span> &ndash; Height of draw context<br/>
<p><p>
</p>
<pre class='example'>
local h = UiHeight()

</pre>
<hr/>
<a name='UiCenter'></a><h3 class='function'>UiCenter</h3>
<pre class='funcdef'><span class='retname'>center = </span>UiCenter(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>center</span> <span class='argtype'>(number)</span> &ndash; Half width of draw context<br/>
<p><p>
</p>
<pre class='example'>
local c = UiCenter()
--Same as 
local c = UiWidth()/2

</pre>
<hr/>
<a name='UiMiddle'></a><h3 class='function'>UiMiddle</h3>
<pre class='funcdef'><span class='retname'>middle = </span>UiMiddle(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>middle</span> <span class='argtype'>(number)</span> &ndash; Half height of draw context<br/>
<p><p>
</p>
<pre class='example'>
local m = UiMiddle()
--Same as
local m = UiHeight()/2

</pre>
<hr/>
<a name='UiColor'></a><h3 class='function'>UiColor</h3>
<pre class='funcdef'><span class='retname'></span>UiColor(<span class='argname'>r, g, b, [a]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>r</span> <span class='argtype'>(number)</span> &ndash; Red channel<br/>
<span class='argname'>g</span> <span class='argtype'>(number)</span> &ndash; Green channel<br/>
<span class='argname'>b</span> <span class='argtype'>(number)</span> &ndash; Blue channel<br/>
<span class='argname'>a</span> <span class='argtype'>(number, optional)</span> &ndash; Alpha channel. Default 1.0<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p><p>
</p>
<pre class='example'>
--Set color yellow
UiColor(1,1,0)

</pre>
<hr/>
<a name='UiColorFilter'></a><h3 class='function'>UiColorFilter</h3>
<pre class='funcdef'><span class='retname'></span>UiColorFilter(<span class='argname'>r, g, b, [a]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>r</span> <span class='argtype'>(number)</span> &ndash; Red channel<br/>
<span class='argname'>g</span> <span class='argtype'>(number)</span> &ndash; Green channel<br/>
<span class='argname'>b</span> <span class='argtype'>(number)</span> &ndash; Blue channel<br/>
<span class='argname'>a</span> <span class='argtype'>(number, optional)</span> &ndash; Alpha channel. Default 1.0<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Color filter, multiplied to all future colors in this scope
<p>
</p>
<pre class='example'>
UiPush()
	--Draw menu in transparent, yellow color tint
	UiColorFilter(1, 1, 0, 0.5)
	drawMenu()
UiPop()

</pre>
<hr/>
<a name='UiResetColor'></a><h3 class='function'>UiResetColor</h3>
<pre class='funcdef'><span class='retname'></span>UiResetColor(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Resets the ui context's color, outline color, shadow color, color filter to default values. <br>
Remarkable that if some component, lets call it "parent", wants to hide everyting in it's scope, <br>
it is possible that a child which uses UiResetColor would ignore the hide logic, if its implemented via changing opacity.
<p>
</p>
<pre class='example'>
function draw()
	UiPush()
        UiFont("bold.ttf", 44)
		UiTranslate(100, 100)
		UiColor(1, 0, 0)
		UiText("A")
		UiTranslate(100, 0)
		UiResetColor()
		UiText("B")
	UiPop()
end

</pre>
<hr/>
<a name='UiTranslate'></a><h3 class='function'>UiTranslate</h3>
<pre class='funcdef'><span class='retname'></span>UiTranslate(<span class='argname'>x, y</span>)</pre>
<p>Arguments<br/>
<span class='argname'>x</span> <span class='argtype'>(number)</span> &ndash; X component<br/>
<span class='argname'>y</span> <span class='argtype'>(number)</span> &ndash; Y component<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Translate cursor
<p>
</p>
<pre class='example'>
UiPush()
	UiTranslate(100, 0)
	UiText("Indented")
UiPop()

</pre>
<hr/>
<a name='UiRotate'></a><h3 class='function'>UiRotate</h3>
<pre class='funcdef'><span class='retname'></span>UiRotate(<span class='argname'>angle</span>)</pre>
<p>Arguments<br/>
<span class='argname'>angle</span> <span class='argtype'>(number)</span> &ndash; Angle in degrees, counter clockwise<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Rotate cursor
<p>
</p>
<pre class='example'>
UiPush()
	UiRotate(45)
	UiText("Rotated")
UiPop()

</pre>
<hr/>
<a name='UiScale'></a><h3 class='function'>UiScale</h3>
<pre class='funcdef'><span class='retname'></span>UiScale(<span class='argname'>x, [y]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>x</span> <span class='argtype'>(number)</span> &ndash; X component<br/>
<span class='argname'>y</span> <span class='argtype'>(number, optional)</span> &ndash; Y component. Default value is x.<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Scale cursor either uniformly (one argument) or non-uniformly (two arguments)
<p>
</p>
<pre class='example'>
UiPush()
	UiScale(2)
	UiText("Double size")
UiPop()

</pre>
<hr/>
<a name='UiGetScale'></a><h3 class='function'>UiGetScale</h3>
<pre class='funcdef'><span class='retname'>x, y = </span>UiGetScale(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>x</span> <span class='argtype'>(number)</span> &ndash; X scale<br/>
<span class='retname'>y</span> <span class='argtype'>(number)</span> &ndash; Y scale<br/>
<p>Returns the ui context's scale
<p>
</p>
<pre class='example'>
function draw()
	UiPush()
		UiScale(2)
		x, y = UiGetScale()
		DebugPrint(x .. " " .. y)
	UiPop()
end

</pre>
<hr/>
<a name='UiClipRect'></a><h3 class='function'>UiClipRect</h3>
<pre class='funcdef'><span class='retname'></span>UiClipRect(<span class='argname'>width, height, [inherit]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>width</span> <span class='argtype'>(number)</span> &ndash; Rect width<br/>
<span class='argname'>height</span> <span class='argtype'>(number)</span> &ndash; Rect height<br/>
<span class='argname'>inherit</span> <span class='argtype'>(boolean, optional)</span> &ndash; True if must include the parent's clip rect<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Specifies the area beyond which ui is cut off and not drawn.<br>
If inherit is true the resulting rect clip will be equal to the overlapped area of both rects
<p>
</p>
<pre class='example'>
function draw()
    UiTranslate(200, 200)
    UiPush()
        UiClipRect(100, 50)
        UiTranslate(5, 15)
        UiFont("regular.ttf", 50)
        UiText("Text")
    UiPop()
end


</pre>
<hr/>
<a name='UiWindow'></a><h3 class='function'>UiWindow</h3>
<pre class='funcdef'><span class='retname'></span>UiWindow(<span class='argname'>width, height, [clip], [inherit]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>width</span> <span class='argtype'>(number)</span> &ndash; Window width<br/>
<span class='argname'>height</span> <span class='argtype'>(number)</span> &ndash; Window height<br/>
<span class='argname'>clip</span> <span class='argtype'>(boolean, optional)</span> &ndash; Clip content outside window. Default is false.<br/>
<span class='argname'>inherit</span> <span class='argtype'>(boolean, optional)</span> &ndash; Inherit current clip region (for nested clip regions)<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Set up new bounds. Calls to UiWidth, UiHeight, UiCenter and UiMiddle
will operate in the context of the window size. 
If clip is set to true, contents of window will be clipped to 
bounds (only works properly for non-rotated windows).
<p>
</p>
<pre class='example'>
UiPush()
	UiWindow(400, 200)
	local w = UiWidth()
	--w is now 400
UiPop()

</pre>
<hr/>
<a name='UiGetCurrentWindow'></a><h3 class='function'>UiGetCurrentWindow</h3>
<pre class='funcdef'><span class='retname'>tl_x, tl_y, br_x, br_y = </span>UiGetCurrentWindow(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>tl_x</span> <span class='argtype'>(number)</span> &ndash; Top left x<br/>
<span class='retname'>tl_y</span> <span class='argtype'>(number)</span> &ndash; Top left y<br/>
<span class='retname'>br_x</span> <span class='argtype'>(number)</span> &ndash; Bottom right x<br/>
<span class='retname'>br_y</span> <span class='argtype'>(number)</span> &ndash; Bottom right y<br/>
<p>Returns the top left & bottom right points of the current window
<p>
</p>
<pre class='example'>
function draw()
	UiPush()
		UiWindow(400, 200)
		tl_x, tl_y, br_x, br_y = UiGetCurrentWindow()
		-- do something
	UiPop()
end

</pre>
<hr/>
<a name='UiIsInCurrentWindow'></a><h3 class='function'>UiIsInCurrentWindow</h3>
<pre class='funcdef'><span class='retname'>val = </span>UiIsInCurrentWindow(<span class='argname'>x, y</span>)</pre>
<p>Arguments<br/>
<span class='argname'>x</span> <span class='argtype'>(number)</span> &ndash; X<br/>
<span class='argname'>y</span> <span class='argtype'>(number)</span> &ndash; Y<br/>
<p>Return value<br/>
<span class='retname'>val</span> <span class='argtype'>(boolean)</span> &ndash; True if<br/>
<p>True if the specified point is within the boundaries of the current window
<p>
</p>
<pre class='example'>
function draw()
	UiPush()
		UiWindow(400, 200)
		DebugPrint("point 1: " .. tostring(UiIsInCurrentWindow(200, 100)))
        DebugPrint("point 2: " .. tostring(UiIsInCurrentWindow(450, 100)))
	UiPop()
end

</pre>
<hr/>
<a name='UiIsRectFullyClipped'></a><h3 class='function'>UiIsRectFullyClipped</h3>
<pre class='funcdef'><span class='retname'>value = </span>UiIsRectFullyClipped(<span class='argname'>w, h</span>)</pre>
<p>Arguments<br/>
<span class='argname'>w</span> <span class='argtype'>(number)</span> &ndash; Width<br/>
<span class='argname'>h</span> <span class='argtype'>(number)</span> &ndash; Height<br/>
<p>Return value<br/>
<span class='retname'>value</span> <span class='argtype'>(boolean)</span> &ndash; True if rect is fully clipped<br/>
<p>Checks whether a rectangle with width w and height h is completely clipped
<p>
</p>
<pre class='example'>
function draw()
    UiTranslate(200, 200)
    UiPush()
        UiClipRect(150, 150)
        UiColor(1.0, 1.0, 1.0, 0.15)
        UiRect(150, 150)
        UiRect(w, h)
        UiTranslate(-50, 30)
        UiColor(1, 0, 0)
        local w, h = 100, 100
        UiRect(w, h)
        DebugPrint(UiIsRectFullyClipped(w, h))
    UiPop()
end

</pre>
<hr/>
<a name='UiIsInClipRegion'></a><h3 class='function'>UiIsInClipRegion</h3>
<pre class='funcdef'><span class='retname'>value = </span>UiIsInClipRegion(<span class='argname'>x, y</span>)</pre>
<p>Arguments<br/>
<span class='argname'>x</span> <span class='argtype'>(number)</span> &ndash; X<br/>
<span class='argname'>y</span> <span class='argtype'>(number)</span> &ndash; Y<br/>
<p>Return value<br/>
<span class='retname'>value</span> <span class='argtype'>(boolean)</span> &ndash; True if point is in clip region<br/>
<p>Checks whether a point is inside the clip region
<p>
</p>
<pre class='example'>
function draw()
    UiPush()
        UiTranslate(200, 200)
        UiClipRect(150, 150)
        UiColor(1.0, 1.0, 1.0, 0.15)
        UiRect(150, 150)
        UiRect(w, h)

        DebugPrint("point 1: " .. tostring(UiIsInClipRegion(250, 250)))
        DebugPrint("point 2: " .. tostring(UiIsInClipRegion(350, 250)))
    UiPop()
end

</pre>
<hr/>
<a name='UiIsFullyClipped'></a><h3 class='function'>UiIsFullyClipped</h3>
<pre class='funcdef'><span class='retname'>value = </span>UiIsFullyClipped(<span class='argname'>w, h</span>)</pre>
<p>Arguments<br/>
<span class='argname'>w</span> <span class='argtype'>(number)</span> &ndash; Width<br/>
<span class='argname'>h</span> <span class='argtype'>(number)</span> &ndash; Height<br/>
<p>Return value<br/>
<span class='retname'>value</span> <span class='argtype'>(boolean)</span> &ndash; True if rect is not overlapping clip region<br/>
<p>Checks whether a rect is overlap the clip region
<p>
</p>
<pre class='example'>
function draw()
    UiPush()
        UiTranslate(200, 200)
        UiClipRect(150, 150)
        UiColor(1.0, 1.0, 1.0, 0.15)
        UiRect(150, 150)
        UiRect(w, h)

        DebugPrint("rect 1: " .. tostring(UiIsFullyClipped(200, 200)))
        UiTranslate(200, 0)
        DebugPrint("rect 2: " .. tostring(UiIsFullyClipped(200, 200)))
    UiPop()
end

</pre>
<hr/>
<a name='UiSafeMargins'></a><h3 class='function'>UiSafeMargins</h3>
<pre class='funcdef'><span class='retname'>x0, y0, x1, y1 = </span>UiSafeMargins(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>x0</span> <span class='argtype'>(number)</span> &ndash; Left<br/>
<span class='retname'>y0</span> <span class='argtype'>(number)</span> &ndash; Top<br/>
<span class='retname'>x1</span> <span class='argtype'>(number)</span> &ndash; Right<br/>
<span class='retname'>y1</span> <span class='argtype'>(number)</span> &ndash; Bottom<br/>
<p>Return a safe drawing area that will always be visible regardless of
display aspect ratio. The safe drawing area will always be 1920 by 1080
in size. This is useful for setting up a fixed size UI.
<p>
</p>
<pre class='example'>
function draw()
	local x0, y0, x1, y1 = UiSafeMargins()
	UiTranslate(x0, y0)
	UiWindow(x1-x0, y1-y0, true)
	--The drawing area is now 1920 by 1080 in the center of screen
	drawMenu()
end

</pre>
<hr/>
<a name='UiCanvasSize'></a><h3 class='function'>UiCanvasSize</h3>
<pre class='funcdef'><span class='retname'>value = </span>UiCanvasSize(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>value</span> <span class='argtype'>(table)</span> &ndash; Canvas width and height<br/>
<p>Returns the canvas size. "Canvas" means a coordinate space in which UI is drawn
<p>
</p>
<pre class='example'>
function draw()
	UiPush()
        local canvas = UiCanvasSize()
        UiWindow(canvas.w, canvas.h)
        --[[ 
            ...
        ]]
	UiPop()
end

</pre>
<hr/>
<a name='UiAlign'></a><h3 class='function'>UiAlign</h3>
<pre class='funcdef'><span class='retname'></span>UiAlign(<span class='argname'>alignment</span>)</pre>
<p>Arguments<br/>
<span class='argname'>alignment</span> <span class='argtype'>(string)</span> &ndash; Alignment keywords<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>The alignment determines how content is aligned with respect to the
cursor.
<table border=0><tr><td class='header'>&nbsp;Alignment&nbsp;</td><td class='header'>&nbsp;Description</td></tr>
<tr><td class='first' valign='top'>left	</td><td valign='top'> Horizontally align to the left</td></tr><tr><td class='first' valign='top'>right	</td><td valign='top'> Horizontally align to the right</td></tr><tr><td class='first' valign='top'>center	</td><td valign='top'> Horizontally align to the center</td></tr><tr><td class='first' valign='top'>top		</td><td valign='top'> Vertically align to the top</td></tr><tr><td class='first' valign='top'>bottom	</td><td valign='top'> Veritcally align to the bottom</td></tr><tr><td class='first' valign='top'>middle	</td><td valign='top'> Vertically align to the middle</td></tr><table/>
Alignment can contain combinations of these, for instance:
"center middle", "left top", "center top", etc. If horizontal
or vertical alginment is omitted it will depend on the element drawn.
Text, for instance has default vertical alignment at baseline.
<p>
<p>
</p>
<pre class='example'>
UiAlign("left")
UiText("Aligned left at baseline")

UiAlign("center middle")
UiText("Fully centered")

</pre>
<hr/>
<a name='UiTextAlignment'></a><h3 class='function'>UiTextAlignment</h3>
<pre class='funcdef'><span class='retname'></span>UiTextAlignment(<span class='argname'>alignment</span>)</pre>
<p>Arguments<br/>
<span class='argname'>alignment</span> <span class='argtype'>(string)</span> &ndash; Alignment keyword<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>The alignment determines how text is aligned with respect to the
cursor and wrap width.
<table border=0><tr><td class='header'>&nbsp;Alignment&nbsp;</td><td class='header'>&nbsp;Description</td></tr>
<tr><td class='first' valign='top'>left	</td><td valign='top'> Horizontally align to the left</td></tr><tr><td class='first' valign='top'>right	</td><td valign='top'> Horizontally align to the right</td></tr><tr><td class='first' valign='top'>center	</td><td valign='top'> Horizontally align to the center</td></tr><table/>
Alignment can contain either "center", "left", or "right"
<p>
<p>
</p>
<pre class='example'>
UiTextAlignment("left")
UiText("Aligned left at baseline")

UiTextAlignment("center")
UiText("Centered")

</pre>
<hr/>
<a name='UiModalBegin'></a><h3 class='function'>UiModalBegin</h3>
<pre class='funcdef'><span class='retname'></span>UiModalBegin(<span class='argname'>[force]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>force</span> <span class='argtype'>(boolean, optional)</span> &ndash; Pass true if you need to increase the priority of this modal in the context<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Disable input for everything, except what's between UiModalBegin and UiModalEnd
(or if modal state is popped)
<p>
</p>
<pre class='example'>
UiModalBegin()
if UiTextButton("Okay") then
	--All other interactive ui elements except this one are disabled
end
UiModalEnd()

--This is also okay
UiPush()
	UiModalBegin()
	if UiTextButton("Okay") then
		--All other interactive ui elements except this one are disabled
	end
UiPop()
--No longer modal

</pre>
<hr/>
<a name='UiModalEnd'></a><h3 class='function'>UiModalEnd</h3>
<pre class='funcdef'><span class='retname'></span>UiModalEnd(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Disable input for everything, except what's between UiModalBegin and UiModalEnd
Calling this function is optional. Modality is part of the current state and will
be lost if modal state is popped.
<p>
</p>
<pre class='example'>
UiModalBegin()
if UiTextButton("Okay") then
	--All other interactive ui elements except this one are disabled
end
UiModalEnd()

</pre>
<hr/>
<a name='UiDisableInput'></a><h3 class='function'>UiDisableInput</h3>
<pre class='funcdef'><span class='retname'></span>UiDisableInput(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Disable input
<p>
</p>
<pre class='example'>
UiPush()
	UiDisableInput()
	if UiTextButton("Okay") then
		--Will never happen
	end
UiPop()

</pre>
<hr/>
<a name='UiEnableInput'></a><h3 class='function'>UiEnableInput</h3>
<pre class='funcdef'><span class='retname'></span>UiEnableInput(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Enable input that has been previously disabled
<p>
</p>
<pre class='example'>
UiDisableInput()
if UiTextButton("Okay") then
	--Will never happen
end

UiEnableInput()
if UiTextButton("Okay") then
	--This can happen
end

</pre>
<hr/>
<a name='UiReceivesInput'></a><h3 class='function'>UiReceivesInput</h3>
<pre class='funcdef'><span class='retname'>receives = </span>UiReceivesInput(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>receives</span> <span class='argtype'>(boolean)</span> &ndash; True if current context receives input<br/>
<p>This function will check current state receives input. This is the case 
if input is not explicitly disabled with (with UiDisableInput) and no other
state is currently modal (with UiModalBegin). Input functions and UI
elements already do this check internally, but it can sometimes be useful 
to read the input state manually to trigger things in the UI.
<p>
</p>
<pre class='example'>
if UiReceivesInput() then
	highlightItemAtMousePointer()
end

</pre>
<hr/>
<a name='UiGetMousePos'></a><h3 class='function'>UiGetMousePos</h3>
<pre class='funcdef'><span class='retname'>x, y = </span>UiGetMousePos(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>x</span> <span class='argtype'>(number)</span> &ndash; X coordinate<br/>
<span class='retname'>y</span> <span class='argtype'>(number)</span> &ndash; Y coordinate<br/>
<p>Get mouse pointer position relative to the cursor
<p>
</p>
<pre class='example'>
local x, y = UiGetMousePos()

</pre>
<hr/>
<a name='UiGetCanvasMousePos'></a><h3 class='function'>UiGetCanvasMousePos</h3>
<pre class='funcdef'><span class='retname'>x, y = </span>UiGetCanvasMousePos(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>x</span> <span class='argtype'>(number)</span> &ndash; X coordinate<br/>
<span class='retname'>y</span> <span class='argtype'>(number)</span> &ndash; Y coordinate<br/>
<p>Returns position of mouse cursor in UI canvas space.<br>
The size of the canvas depends on the aspect ratio. For example, for 16:9, the maximum value will be 1920x1080, and for 16:10, it will be 1920x1200
<p>
</p>
<pre class='example'>
function draw()
	local x, y = UiGetCanvasMousePos()
	DebugPrint("x :" .. x .. " y:" .. y)
end

</pre>
<hr/>
<a name='UiIsMouseInRect'></a><h3 class='function'>UiIsMouseInRect</h3>
<pre class='funcdef'><span class='retname'>inside = </span>UiIsMouseInRect(<span class='argname'>w, h</span>)</pre>
<p>Arguments<br/>
<span class='argname'>w</span> <span class='argtype'>(number)</span> &ndash; Width<br/>
<span class='argname'>h</span> <span class='argtype'>(number)</span> &ndash; Height<br/>
<p>Return value<br/>
<span class='retname'>inside</span> <span class='argtype'>(boolean)</span> &ndash; True if mouse pointer is within rectangle<br/>
<p>Check if mouse pointer is within rectangle. Note that this function respects
alignment.
<p>
</p>
<pre class='example'>
if UiIsMouseInRect(100, 100) then
	-- mouse pointer is in rectangle
end

</pre>
<hr/>
<a name='UiWorldToPixel'></a><h3 class='function'>UiWorldToPixel</h3>
<pre class='funcdef'><span class='retname'>x, y, distance = </span>UiWorldToPixel(<span class='argname'>point</span>)</pre>
<p>Arguments<br/>
<span class='argname'>point</span> <span class='argtype'>(TVec)</span> &ndash; 3D world position as vector<br/>
<p>Return value<br/>
<span class='retname'>x</span> <span class='argtype'>(number)</span> &ndash; X coordinate<br/>
<span class='retname'>y</span> <span class='argtype'>(number)</span> &ndash; Y coordinate<br/>
<span class='retname'>distance</span> <span class='argtype'>(number)</span> &ndash; Distance to point<br/>
<p>Convert world space position to user interface X and Y coordinate relative
to the cursor. The distance is in meters and positive if in front of camera,
negative otherwise.
<p>
</p>
<pre class='example'>
local x, y, dist = UiWorldToPixel(point)
if dist > 0 then
UiTranslate(x, y)
UiText("Label")
end

</pre>
<hr/>
<a name='UiPixelToWorld'></a><h3 class='function'>UiPixelToWorld</h3>
<pre class='funcdef'><span class='retname'>direction = </span>UiPixelToWorld(<span class='argname'>x, y</span>)</pre>
<p>Arguments<br/>
<span class='argname'>x</span> <span class='argtype'>(number)</span> &ndash; X coordinate<br/>
<span class='argname'>y</span> <span class='argtype'>(number)</span> &ndash; Y coordinate<br/>
<p>Return value<br/>
<span class='retname'>direction</span> <span class='argtype'>(TVec)</span> &ndash; 3D world direction as vector<br/>
<p>Convert X and Y UI coordinate to a world direction, as seen from current camera.
This can be used to raycast into the scene from the mouse pointer position.
<p>
</p>
<pre class='example'>
UiMakeInteractive()
local x, y = UiGetMousePos()
local dir = UiPixelToWorld(x, y)
local pos = GetCameraTransform().pos
local hit, dist = QueryRaycast(pos, dir, 100)
if hit then
	DebugPrint("hit distance: " .. dist)
end

</pre>
<hr/>
<a name='UiGetCursorPos'></a><h3 class='function'>UiGetCursorPos</h3>
<pre class='funcdef'><span class='retname'></span>UiGetCursorPos(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Returns the ui cursor's postion
<p>
</p>
<pre class='example'>
function draw()
    UiTranslate(100, 50)
    x, y = UiGetCursorPos()
    DebugPrint("x: " .. x .. "; y: " .. y)
end

</pre>
<hr/>
<a name='UiBlur'></a><h3 class='function'>UiBlur</h3>
<pre class='funcdef'><span class='retname'></span>UiBlur(<span class='argname'>amount</span>)</pre>
<p>Arguments<br/>
<span class='argname'>amount</span> <span class='argtype'>(number)</span> &ndash; Blur amount (0.0 to 1.0)<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Perform a gaussian blur on current screen content
<p>
</p>
<pre class='example'>
UiBlur(1.0)
drawMenu()

</pre>
<hr/>
<a name='UiFont'></a><h3 class='function'>UiFont</h3>
<pre class='funcdef'><span class='retname'></span>UiFont(<span class='argname'>path, size</span>)</pre>
<p>Arguments<br/>
<span class='argname'>path</span> <span class='argtype'>(string)</span> &ndash; Path to TTF font file<br/>
<span class='argname'>size</span> <span class='argtype'>(number)</span> &ndash; Font size (10 to 100)<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p><p>
</p>
<pre class='example'>
UiFont("bold.ttf", 24)
UiText("Hello")

</pre>
<hr/>
<a name='UiFontHeight'></a><h3 class='function'>UiFontHeight</h3>
<pre class='funcdef'><span class='retname'>size = </span>UiFontHeight(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>size</span> <span class='argtype'>(number)</span> &ndash; Font size<br/>
<p><p>
</p>
<pre class='example'>
local h = UiFontHeight()

</pre>
<hr/>
<a name='UiText'></a><h3 class='function'>UiText</h3>
<pre class='funcdef'><span class='retname'>w, h, x, y, linkId = </span>UiText(<span class='argname'>text, [move], [maxChars]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>text</span> <span class='argtype'>(string)</span> &ndash; Print text at cursor location<br/>
<span class='argname'>move</span> <span class='argtype'>(boolean, optional)</span> &ndash; Automatically move cursor vertically. Default false.<br/>
<span class='argname'>maxChars</span> <span class='argtype'>(number, optional)</span> &ndash; Maximum amount of characters. Default 100000.<br/>
<p>Return value<br/>
<span class='retname'>w</span> <span class='argtype'>(number)</span> &ndash; Width of text<br/>
<span class='retname'>h</span> <span class='argtype'>(number)</span> &ndash; Height of text<br/>
<span class='retname'>x</span> <span class='argtype'>(number)</span> &ndash; End x-position of text.<br/>
<span class='retname'>y</span> <span class='argtype'>(number)</span> &ndash; End y-position of text.<br/>
<span class='retname'>linkId</span> <span class='argtype'>(string)</span> &ndash; Link id of clicked link<br/>
<p><p>
</p>
<pre class='example'>
UiFont("bold.ttf", 24)
UiText("Hello")

...

--Automatically advance cursor
UiText("First line", true)
UiText("Second line", true)



--Using links
UiFont("bold.ttf", 26)
UiTranslate(100,100)
--Using virtual links
link = "[[link;label=loc@UI_TEXT_FREE_ROAM_OPTIONS_LINK_NAME;id=options/game;color=#DDDD7FDD;underline=true]]"
someText = "Some text with a link: " .. link .. " and some more text"

w, h, x, y, linkId = UiText(someText)
if linkId:len() ~= 0 then
	if linkId == "options/game" then
		DebugPrint(linkId.." link clicked")
	elseif linkId == "options/sound" then
		--Do something else
	end
end
UiTranslate(0,50)

--Using game links, id attribute is required, color is optional, same as virtual links
link = "[[game://options;label=loc@UI_TEXT_FREE_ROAM_OPTIONS_LINK_NAME;id=game;color=#DDDD7FDD;underline=false]]"
someText = "Some text with a link: " .. link .. " and some more text"
w, h, x, y, linkId = UiText(someText)
if linkId:len() ~= 0 then
	DebugPrint(linkId.." link clicked")
end
UiTranslate(0,50)

--Using http/s links is also possible, link will be opened in the default browser
link = "[[http://www.example.com;label=loc@SOME_KEY;]]"
someText = "Goto: " .. link
UiText(someText)


</pre>
<hr/>
<a name='UiTextDisableWildcards'></a><h3 class='function'>UiTextDisableWildcards</h3>
<pre class='funcdef'><span class='retname'></span>UiTextDisableWildcards(<span class='argname'>disable</span>)</pre>
<p>Arguments<br/>
<span class='argname'>disable</span> <span class='argtype'>(boolean)</span> &ndash; Enable or disable wildcard [[...]] substitution support in UiText<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p><p>
<p>
</p>
<pre class='example'>

UiFont("regular.ttf", 30)
UiPush()
	UiTextDisableWildcards(true)
	-- icon won't be embedded here, text will be left as is
	UiText("Text with embedded icon image [[menu:menu_accept;iconsize=42,42]]")
UiPop()

-- embedding works as expected
UiText("Text with embedded icon image [[menu:menu_accept;iconsize=42,42]]")

</pre>
<hr/>
<a name='UiTextUniformHeight'></a><h3 class='function'>UiTextUniformHeight</h3>
<pre class='funcdef'><span class='retname'></span>UiTextUniformHeight(<span class='argname'>uniform</span>)</pre>
<p>Arguments<br/>
<span class='argname'>uniform</span> <span class='argtype'>(boolean)</span> &ndash; Enable or disable fixed line height for text rendering<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>This function toggles the use of a fixed line height for text rendering. 
When enabled (true), the line height is set to a constant value determined by 
the current font metrics, ensuring uniform spacing between lines of text. 
This mode is useful for maintaining consistent line spacing across different 
text elements, regardless of the specific characters displayed. 
When disabled (false), the line height adjusts dynamically to accommodate 
the tallest character in each line of text.
<p>
<p>
</p>
<pre class='example'>
#include "script/common.lua"
enabled = false
group = 1
local desc = {
    {
        {"A mod desc without descenders"},
        {"Author: Abcd"},
        {"Tags: map, spawnable"},
    },
    {
        {"A mod with descenders, like g, j, p, q, y"},
        {"Author: Ggjyq"},
        {"Tags: map, spawnable"},
    },
}
-- Function to draw text with or without uniform line height
local function drawDescriptions()
    UiAlign("top")
    for _, text in ipairs(desc[group]) do
        UiTextUniformHeight(enabled)
        UiText(text[1], true)
    end
end

function draw()
    UiFont("regular.ttf", 22)
    UiTranslate(100, 100)

    UiPush()
        local r,g,b
        if enabled then
            r,g,b = 0,1,0
        else
            r,g,b = 1,0,0
        end
        UiColor(0,0,0)
        UiButtonImageBox("ui/common/box-solid-6.png", 6, 6, r,g,b)
        if UiTextButton("Uniform height "..(enabled and "enabled" or "disabled")) then
            enabled = not enabled
        end
        UiTranslate(0,35)
        if UiTextButton(">") then
            group = clamp(group + 1, 1, #desc)
        end
        UiTranslate(0,35)
        if UiTextButton("<") then
            group = clamp(group - 1, 1, #desc)
        end
    UiPop()
    UiTranslate(0,80)
    drawDescriptions()
end


</pre>
<hr/>
<a name='UiGetTextSize'></a><h3 class='function'>UiGetTextSize</h3>
<pre class='funcdef'><span class='retname'>w, h, x, y = </span>UiGetTextSize(<span class='argname'>text</span>)</pre>
<p>Arguments<br/>
<span class='argname'>text</span> <span class='argtype'>(string)</span> &ndash; A text string<br/>
<p>Return value<br/>
<span class='retname'>w</span> <span class='argtype'>(number)</span> &ndash; Width of text<br/>
<span class='retname'>h</span> <span class='argtype'>(number)</span> &ndash; Height of text<br/>
<span class='retname'>x</span> <span class='argtype'>(number)</span> &ndash; Offset x-component of text AABB<br/>
<span class='retname'>y</span> <span class='argtype'>(number)</span> &ndash; Offset y-component of text AABB<br/>
<p><p>
</p>
<pre class='example'>

local w, h = UiGetTextSize("Some text")

</pre>
<hr/>
<a name='UiMeasureText'></a><h3 class='function'>UiMeasureText</h3>
<pre class='funcdef'><span class='retname'>w, h = </span>UiMeasureText(<span class='argname'>space, text/locale</span>)</pre>
<p>Arguments<br/>
<span class='argname'>space</span> <span class='argtype'>(number)</span> &ndash; Space between lines<br/>
<span class='argname'>text/locale</span> <span class='argtype'>(string,)</span> &ndash; , ... A text strings<br/>
<p>Return value<br/>
<span class='retname'>w</span> <span class='argtype'>(number)</span> &ndash; Width of biggest line<br/>
<span class='retname'>h</span> <span class='argtype'>(number)</span> &ndash; Height of all lines combined with interval<br/>
<p><p>
</p>
<pre class='example'>

local w, h = UiMeasureText(0, "Some text", "loc@key")

</pre>
<hr/>
<a name='UiGetSymbolsCount'></a><h3 class='function'>UiGetSymbolsCount</h3>
<pre class='funcdef'><span class='retname'>count = </span>UiGetSymbolsCount(<span class='argname'>text</span>)</pre>
<p>Arguments<br/>
<span class='argname'>text</span> <span class='argtype'>(string)</span> &ndash; Text<br/>
<p>Return value<br/>
<span class='retname'>count</span> <span class='argtype'>(number)</span> &ndash; Symbols count<br/>
<p>Returns the symbols count in the specified text.<br>
This function is intended to property count symbols in UTF 8 encoded string
<p>
</p>
<pre class='example'>
function draw()
    DebugPrint(UiGetSymbolsCount("Hello world!"))
end

</pre>
<hr/>
<a name='UiTextSymbolsSub'></a><h3 class='function'>UiTextSymbolsSub</h3>
<pre class='funcdef'><span class='retname'>substring = </span>UiTextSymbolsSub(<span class='argname'>text, from, to</span>)</pre>
<p>Arguments<br/>
<span class='argname'>text</span> <span class='argtype'>(string)</span> &ndash; Text<br/>
<span class='argname'>from</span> <span class='argtype'>(number)</span> &ndash; From element index<br/>
<span class='argname'>to</span> <span class='argtype'>(number)</span> &ndash; To element index<br/>
<p>Return value<br/>
<span class='retname'>substring</span> <span class='argtype'>(string)</span> &ndash; Substring<br/>
<p>Returns the substring. This function is intended to properly work with UTF8 encoded strings
<p>
</p>
<pre class='example'>
function draw()
    DebugPrint(UiTextSymbolsSub("Hello world", 1, 5))
end

</pre>
<hr/>
<a name='UiWordWrap'></a><h3 class='function'>UiWordWrap</h3>
<pre class='funcdef'><span class='retname'></span>UiWordWrap(<span class='argname'>width</span>)</pre>
<p>Arguments<br/>
<span class='argname'>width</span> <span class='argtype'>(number)</span> &ndash; Maximum width of text<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p><p>
</p>
<pre class='example'>
UiWordWrap(200)
UiText("Some really long text that will get wrapped into several lines")

</pre>
<hr/>
<a name='UiTextLineSpacing'></a><h3 class='function'>UiTextLineSpacing</h3>
<pre class='funcdef'><span class='retname'></span>UiTextLineSpacing(<span class='argname'>value</span>)</pre>
<p>Arguments<br/>
<span class='argname'>value</span> <span class='argtype'>(number)</span> &ndash; Text linespacing<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Sets the context's linespacing value of the text which is drawn using UiText
<p>
</p>
<pre class='example'>
function draw()
    UiTextLineSpacing(10)
	UiWordWrap(200)
	UiText("TEXT TEXT TEXT TEXT TEXT TEXT TEXT TEXT TEXT TEXT TEXT TEXT TEXT")
end

</pre>
<hr/>
<a name='UiTextOutline'></a><h3 class='function'>UiTextOutline</h3>
<pre class='funcdef'><span class='retname'></span>UiTextOutline(<span class='argname'>r, g, b, a, [thickness]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>r</span> <span class='argtype'>(number)</span> &ndash; Red channel<br/>
<span class='argname'>g</span> <span class='argtype'>(number)</span> &ndash; Green channel<br/>
<span class='argname'>b</span> <span class='argtype'>(number)</span> &ndash; Blue channel<br/>
<span class='argname'>a</span> <span class='argtype'>(number)</span> &ndash; Alpha channel<br/>
<span class='argname'>thickness</span> <span class='argtype'>(number, optional)</span> &ndash; Outline thickness. Default is 0.1<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p><p>
</p>
<pre class='example'>
--Black outline, standard thickness
UiTextOutline(0,0,0,1)
UiText("Text with outline")

</pre>
<hr/>
<a name='UiTextShadow'></a><h3 class='function'>UiTextShadow</h3>
<pre class='funcdef'><span class='retname'></span>UiTextShadow(<span class='argname'>r, g, b, a, [distance], [blur]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>r</span> <span class='argtype'>(number)</span> &ndash; Red channel<br/>
<span class='argname'>g</span> <span class='argtype'>(number)</span> &ndash; Green channel<br/>
<span class='argname'>b</span> <span class='argtype'>(number)</span> &ndash; Blue channel<br/>
<span class='argname'>a</span> <span class='argtype'>(number)</span> &ndash; Alpha channel<br/>
<span class='argname'>distance</span> <span class='argtype'>(number, optional)</span> &ndash; Shadow distance. Default is 1.0<br/>
<span class='argname'>blur</span> <span class='argtype'>(number, optional)</span> &ndash; Shadow blur. Default is 0.5<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p><p>
</p>
<pre class='example'>
--Black drop shadow, 50% transparent, distance 2
UiTextShadow(0, 0, 0, 0.5, 2.0)
UiText("Text with drop shadow")

</pre>
<hr/>
<a name='UiRect'></a><h3 class='function'>UiRect</h3>
<pre class='funcdef'><span class='retname'></span>UiRect(<span class='argname'>w, h</span>)</pre>
<p>Arguments<br/>
<span class='argname'>w</span> <span class='argtype'>(number)</span> &ndash; Width<br/>
<span class='argname'>h</span> <span class='argtype'>(number)</span> &ndash; Height<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Draw solid rectangle at cursor position
<p>
</p>
<pre class='example'>
--Draw full-screen black rectangle
UiColor(0, 0, 0)
UiRect(UiWidth(), UiHeight())

--Draw smaller, red, rotating rectangle in center of screen
UiPush()
	UiColor(1, 0, 0)
	UiTranslate(UiCenter(), UiMiddle())
	UiRotate(GetTime())
	UiAlign("center middle")
	UiRect(100, 100)
UiPop()

</pre>
<hr/>
<a name='UiRectOutline'></a><h3 class='function'>UiRectOutline</h3>
<pre class='funcdef'><span class='retname'></span>UiRectOutline(<span class='argname'>width, height, thickness</span>)</pre>
<p>Arguments<br/>
<span class='argname'>width</span> <span class='argtype'>(number)</span> &ndash; Rectangle width<br/>
<span class='argname'>height</span> <span class='argtype'>(number)</span> &ndash; Rectangle height<br/>
<span class='argname'>thickness</span> <span class='argtype'>(number)</span> &ndash; Rectangle outline thickness<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Draw rectangle outline at cursor position
<p>
</p>
<pre class='example'>
--Draw a red rotating rectangle outline in center of screen
UiPush()
	UiColor(1, 0, 0)
	UiTranslate(UiCenter(), UiMiddle())
	UiRotate(GetTime())
	UiAlign("center middle")
	UiRectOutline(100, 100, 5)
UiPop()

</pre>
<hr/>
<a name='UiRoundedRect'></a><h3 class='function'>UiRoundedRect</h3>
<pre class='funcdef'><span class='retname'></span>UiRoundedRect(<span class='argname'>width, height, roundingRadius</span>)</pre>
<p>Arguments<br/>
<span class='argname'>width</span> <span class='argtype'>(number)</span> &ndash; Rectangle width<br/>
<span class='argname'>height</span> <span class='argtype'>(number)</span> &ndash; Rectangle height<br/>
<span class='argname'>roundingRadius</span> <span class='argtype'>(number)</span> &ndash; Round corners radius<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Draw a solid rectangle with round corners of specified radius
<p>
</p>
<pre class='example'>
UiPush()
	UiColor(1, 0, 0)
	UiTranslate(UiCenter(), UiMiddle())
	UiRotate(GetTime())
	UiAlign("center middle")
	UiRoundedRect(100, 100, 8)
UiPop()

</pre>
<hr/>
<a name='UiRoundedRectOutline'></a><h3 class='function'>UiRoundedRectOutline</h3>
<pre class='funcdef'><span class='retname'></span>UiRoundedRectOutline(<span class='argname'>width, height, roundingRadius, thickness</span>)</pre>
<p>Arguments<br/>
<span class='argname'>width</span> <span class='argtype'>(number)</span> &ndash; Rectangle width<br/>
<span class='argname'>height</span> <span class='argtype'>(number)</span> &ndash; Rectangle height<br/>
<span class='argname'>roundingRadius</span> <span class='argtype'>(number)</span> &ndash; Round corners radius<br/>
<span class='argname'>thickness</span> <span class='argtype'>(number)</span> &ndash; Rectangle outline thickness<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Draw rectangle outline with round corners at cursor position
<p>
</p>
<pre class='example'>
UiPush()
	UiColor(1, 0, 0)
	UiTranslate(UiCenter(), UiMiddle())
	UiRotate(GetTime())
	UiAlign("center middle")
	UiRoundedRectOutline(100, 100, 20, 5)
UiPop()

</pre>
<hr/>
<a name='UiCircle'></a><h3 class='function'>UiCircle</h3>
<pre class='funcdef'><span class='retname'></span>UiCircle(<span class='argname'>radius</span>)</pre>
<p>Arguments<br/>
<span class='argname'>radius</span> <span class='argtype'>(number)</span> &ndash; Circle radius<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Draw a solid circle at cursor position
<p>
</p>
<pre class='example'>
UiPush()
	UiColor(1, 0, 0)
	UiTranslate(UiCenter(), UiMiddle())
	UiAlign("center middle")
	UiCircle(100)
UiPop()

</pre>
<hr/>
<a name='UiCircleOutline'></a><h3 class='function'>UiCircleOutline</h3>
<pre class='funcdef'><span class='retname'></span>UiCircleOutline(<span class='argname'>radius, thickness</span>)</pre>
<p>Arguments<br/>
<span class='argname'>radius</span> <span class='argtype'>(number)</span> &ndash; Circle radius<br/>
<span class='argname'>thickness</span> <span class='argtype'>(number)</span> &ndash; Circle outline thickness<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Draw a circle outline at cursor position
<p>
</p>
<pre class='example'>
--Draw a red rotating rectangle outline in center of screen
UiPush()
	UiColor(1, 0, 0)
	UiTranslate(UiCenter(), UiMiddle())
	UiAlign("center middle")
	UiCircleOutline(100, 8)
UiPop()

</pre>
<hr/>
<a name='UiFillImage'></a><h3 class='function'>UiFillImage</h3>
<pre class='funcdef'><span class='retname'></span>UiFillImage(<span class='argname'>path</span>)</pre>
<p>Arguments<br/>
<span class='argname'>path</span> <span class='argtype'>(string)</span> &ndash; Path to image (PNG or JPG format)<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Image to fill for UiRoundedRect, UiCircle
<p>
</p>
<pre class='example'>
UiPush()
	UiFillImage("ui/hud/tutorial/plank-lift.jpg")
	UiTranslate(UiCenter(), UiMiddle())
	UiRotate(GetTime())
	UiAlign("center middle")
	UiRoundedRect(100, 100, 8)
UiPop()

</pre>
<hr/>
<a name='UiImage'></a><h3 class='function'>UiImage</h3>
<pre class='funcdef'><span class='retname'>w, h = </span>UiImage(<span class='argname'>path, [x0], [y0], [x1], [y1]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>path</span> <span class='argtype'>(string)</span> &ndash; Path to image (PNG or JPG format)<br/>
<span class='argname'>x0</span> <span class='argtype'>(number, optional)</span> &ndash; Lower x coordinate (default is 0)<br/>
<span class='argname'>y0</span> <span class='argtype'>(number, optional)</span> &ndash; Lower y coordinate (default is 0)<br/>
<span class='argname'>x1</span> <span class='argtype'>(number, optional)</span> &ndash; Upper x coordinate (default is image width)<br/>
<span class='argname'>y1</span> <span class='argtype'>(number, optional)</span> &ndash; Upper y coordinate (default is image height)<br/>
<p>Return value<br/>
<span class='retname'>w</span> <span class='argtype'>(number)</span> &ndash; Width of drawn image<br/>
<span class='retname'>h</span> <span class='argtype'>(number)</span> &ndash; Height of drawn image<br/>
<p>Draw image at cursor position. If x0, y0, x1, y1 is provided a cropped version
will be drawn in that coordinate range.
<p>
</p>
<pre class='example'>
--Draw image in center of screen
UiPush()
	UiTranslate(UiCenter(), UiMiddle())
	UiAlign("center middle")
	UiImage("test.png")
UiPop()

</pre>
<hr/>
<a name='UiUnloadImage'></a><h3 class='function'>UiUnloadImage</h3>
<pre class='funcdef'><span class='retname'></span>UiUnloadImage(<span class='argname'>path</span>)</pre>
<p>Arguments<br/>
<span class='argname'>path</span> <span class='argtype'>(string)</span> &ndash; Path to image (PNG or JPG format)<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Unloads a texture from the memory
<p>
</p>
<pre class='example'>
local image = "gfx/cursor.png"

function draw()
    UiTranslate(300, 300)
	if UiHasImage(image) then
		if InputDown("interact") then
			UiUnloadImage("img/background.jpg")
		else
			UiImage(image)
		end
	end
end

</pre>
<hr/>
<a name='UiHasImage'></a><h3 class='function'>UiHasImage</h3>
<pre class='funcdef'><span class='retname'>exists = </span>UiHasImage(<span class='argname'>path</span>)</pre>
<p>Arguments<br/>
<span class='argname'>path</span> <span class='argtype'>(string)</span> &ndash; Path to image (PNG or JPG format)<br/>
<p>Return value<br/>
<span class='retname'>exists</span> <span class='argtype'>(boolean)</span> &ndash; Does the image exists at the specified path<br/>
<p><p>
</p>
<pre class='example'>
local image = "gfx/circle.png"

function draw()
	if UiHasImage(image) then
		DebugPrint("image " .. image .. " exists")
	end
end

</pre>
<hr/>
<a name='UiGetImageSize'></a><h3 class='function'>UiGetImageSize</h3>
<pre class='funcdef'><span class='retname'>w, h = </span>UiGetImageSize(<span class='argname'>path</span>)</pre>
<p>Arguments<br/>
<span class='argname'>path</span> <span class='argtype'>(string)</span> &ndash; Path to image (PNG or JPG format)<br/>
<p>Return value<br/>
<span class='retname'>w</span> <span class='argtype'>(number)</span> &ndash; Image width<br/>
<span class='retname'>h</span> <span class='argtype'>(number)</span> &ndash; Image height<br/>
<p>Get image size
<p>
</p>
<pre class='example'>
local w,h = UiGetImageSize("test.png")

</pre>
<hr/>
<a name='UiImageBox'></a><h3 class='function'>UiImageBox</h3>
<pre class='funcdef'><span class='retname'></span>UiImageBox(<span class='argname'>path, width, height, [borderWidth], [borderHeight]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>path</span> <span class='argtype'>(string)</span> &ndash; Path to image (PNG or JPG format)<br/>
<span class='argname'>width</span> <span class='argtype'>(number)</span> &ndash; Width<br/>
<span class='argname'>height</span> <span class='argtype'>(number)</span> &ndash; Height<br/>
<span class='argname'>borderWidth</span> <span class='argtype'>(number, optional)</span> &ndash; Border width. Default 0<br/>
<span class='argname'>borderHeight</span> <span class='argtype'>(number, optional)</span> &ndash; Border height. Default 0<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Draw 9-slice image at cursor position. Width should be at least 2*borderWidth.
Height should be at least 2*borderHeight.
<p>
</p>
<pre class='example'>
UiImageBox("menu-frame.png", 200, 200, 10, 10)

</pre>
<hr/>
<a name='UiSound'></a><h3 class='function'>UiSound</h3>
<pre class='funcdef'><span class='retname'></span>UiSound(<span class='argname'>path, [volume], [pitch], [panAzimuth], [panDepth]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>path</span> <span class='argtype'>(string)</span> &ndash; Path to sound file (OGG format)<br/>
<span class='argname'>volume</span> <span class='argtype'>(number, optional)</span> &ndash; Playback volume. Default 1.0<br/>
<span class='argname'>pitch</span> <span class='argtype'>(number, optional)</span> &ndash; Playback pitch. Default 1.0<br/>
<span class='argname'>panAzimuth</span> <span class='argtype'>(number, optional)</span> &ndash; Playback stereo panning azimuth (-PI to PI). Default 0.0.<br/>
<span class='argname'>panDepth</span> <span class='argtype'>(number, optional)</span> &ndash; Playback stereo panning depth (0.0 to 1.0). Default 1.0.<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>UI sounds are not affected by acoustics simulation. Use LoadSound / PlaySound for that.
<p>
</p>
<pre class='example'>
UiSound("click.ogg")

</pre>
<hr/>
<a name='UiSoundLoop'></a><h3 class='function'>UiSoundLoop</h3>
<pre class='funcdef'><span class='retname'></span>UiSoundLoop(<span class='argname'>path, [volume], [pitch]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>path</span> <span class='argtype'>(string)</span> &ndash; Path to looping sound file (OGG format)<br/>
<span class='argname'>volume</span> <span class='argtype'>(number, optional)</span> &ndash; Playback volume. Default 1.0<br/>
<span class='argname'>pitch</span> <span class='argtype'>(number, optional)</span> &ndash; Playback pitch. Default 1.0<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Call this continuously to keep playing loop. 
UI sounds are not affected by acoustics simulation. Use LoadLoop / PlayLoop for that.
<p>
</p>
<pre class='example'>
if animating then
	UiSoundLoop("screech.ogg")
end

</pre>
<hr/>
<a name='UiMute'></a><h3 class='function'>UiMute</h3>
<pre class='funcdef'><span class='retname'></span>UiMute(<span class='argname'>amount, [music]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>amount</span> <span class='argtype'>(number)</span> &ndash; Mute by this amount (0.0 to 1.0)<br/>
<span class='argname'>music</span> <span class='argtype'>(boolean, optional)</span> &ndash; Mute music as well<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Mute game audio and optionally music for the next frame. Call
continuously to stay muted.
<p>
</p>
<pre class='example'>
if menuOpen then
	UiMute(1.0)
end

</pre>
<hr/>
<a name='UiButtonImageBox'></a><h3 class='function'>UiButtonImageBox</h3>
<pre class='funcdef'><span class='retname'></span>UiButtonImageBox(<span class='argname'>path, borderWidth, borderHeight, [r], [g], [b], [a]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>path</span> <span class='argtype'>(string)</span> &ndash; Path to image (PNG or JPG format)<br/>
<span class='argname'>borderWidth</span> <span class='argtype'>(number)</span> &ndash; Border width<br/>
<span class='argname'>borderHeight</span> <span class='argtype'>(number)</span> &ndash; Border height<br/>
<span class='argname'>r</span> <span class='argtype'>(number, optional)</span> &ndash; Red multiply. Default 1.0<br/>
<span class='argname'>g</span> <span class='argtype'>(number, optional)</span> &ndash; Green multiply. Default 1.0<br/>
<span class='argname'>b</span> <span class='argtype'>(number, optional)</span> &ndash; Blue multiply. Default 1.0<br/>
<span class='argname'>a</span> <span class='argtype'>(number, optional)</span> &ndash; Alpha channel. Default 1.0<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Set up 9-slice image to be used as background for buttons.
<p>
</p>
<pre class='example'>
UiButtonImageBox("button-9slice.png", 10, 10)
if UiTextButton("Test") then
	...
end

</pre>
<hr/>
<a name='UiButtonHoverColor'></a><h3 class='function'>UiButtonHoverColor</h3>
<pre class='funcdef'><span class='retname'></span>UiButtonHoverColor(<span class='argname'>r, g, b, [a]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>r</span> <span class='argtype'>(number)</span> &ndash; Red multiply<br/>
<span class='argname'>g</span> <span class='argtype'>(number)</span> &ndash; Green multiply<br/>
<span class='argname'>b</span> <span class='argtype'>(number)</span> &ndash; Blue multiply<br/>
<span class='argname'>a</span> <span class='argtype'>(number, optional)</span> &ndash; Alpha channel. Default 1.0<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Button color filter when hovering mouse pointer.
<p>
</p>
<pre class='example'>
UiButtonHoverColor(1, 0, 0)
if UiTextButton("Test") then
	...
end

</pre>
<hr/>
<a name='UiButtonPressColor'></a><h3 class='function'>UiButtonPressColor</h3>
<pre class='funcdef'><span class='retname'></span>UiButtonPressColor(<span class='argname'>r, g, b, [a]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>r</span> <span class='argtype'>(number)</span> &ndash; Red multiply<br/>
<span class='argname'>g</span> <span class='argtype'>(number)</span> &ndash; Green multiply<br/>
<span class='argname'>b</span> <span class='argtype'>(number)</span> &ndash; Blue multiply<br/>
<span class='argname'>a</span> <span class='argtype'>(number, optional)</span> &ndash; Alpha channel. Default 1.0<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Button color filter when pressing down.
<p>
</p>
<pre class='example'>
UiButtonPressColor(0, 1, 0)
if UiTextButton("Test") then
	...
end

</pre>
<hr/>
<a name='UiButtonPressDist'></a><h3 class='function'>UiButtonPressDist</h3>
<pre class='funcdef'><span class='retname'></span>UiButtonPressDist(<span class='argname'>distX, distY</span>)</pre>
<p>Arguments<br/>
<span class='argname'>distX</span> <span class='argtype'>(number)</span> &ndash; Press distance along X axis<br/>
<span class='argname'>distY</span> <span class='argtype'>(number)</span> &ndash; Press distance along Y axis<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>The button offset when being pressed
<p>
</p>
<pre class='example'>
UiButtonPressDistance(4, 4)
if UiTextButton("Test") then
	...
end

</pre>
<hr/>
<a name='UiButtonTextHandling'></a><h3 class='function'>UiButtonTextHandling</h3>
<pre class='funcdef'><span class='retname'></span>UiButtonTextHandling(<span class='argname'>type</span>)</pre>
<p>Arguments<br/>
<span class='argname'>type</span> <span class='argtype'>(number)</span> &ndash; One of the enum value<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>indicating how to handle text overflow.
Possible values are:
0 - AsIs,
1 - Slide,
2 - Truncate,
3 - Fade,
4 - Resize (Default)
<p>
</p>
<pre class='example'>
UiButtonTextHandling(1)
if UiTextButton("Test") then
	...
end

</pre>
<hr/>
<a name='UiTextButton'></a><h3 class='function'>UiTextButton</h3>
<pre class='funcdef'><span class='retname'>pressed = </span>UiTextButton(<span class='argname'>text, [w], [h]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>text</span> <span class='argtype'>(string)</span> &ndash; Text on button<br/>
<span class='argname'>w</span> <span class='argtype'>(number, optional)</span> &ndash; Button width<br/>
<span class='argname'>h</span> <span class='argtype'>(number, optional)</span> &ndash; Button height<br/>
<p>Return value<br/>
<span class='retname'>pressed</span> <span class='argtype'>(boolean)</span> &ndash; True if user clicked button<br/>
<p><p>
</p>
<pre class='example'>
if UiTextButton("Test") then
	...
end

</pre>
<hr/>
<a name='UiImageButton'></a><h3 class='function'>UiImageButton</h3>
<pre class='funcdef'><span class='retname'>pressed = </span>UiImageButton(<span class='argname'>path</span>)</pre>
<p>Arguments<br/>
<span class='argname'>path</span> <span class='argtype'>(string)</span> &ndash; Image path (PNG or JPG file)<br/>
<p>Return value<br/>
<span class='retname'>pressed</span> <span class='argtype'>(boolean)</span> &ndash; True if user clicked button<br/>
<p><p>
</p>
<pre class='example'>
if UiImageButton("image.png") then
	...
end

</pre>
<hr/>
<a name='UiBlankButton'></a><h3 class='function'>UiBlankButton</h3>
<pre class='funcdef'><span class='retname'>pressed = </span>UiBlankButton(<span class='argname'>w, h</span>)</pre>
<p>Arguments<br/>
<span class='argname'>w</span> <span class='argtype'>(number)</span> &ndash; Button width<br/>
<span class='argname'>h</span> <span class='argtype'>(number)</span> &ndash; Button height<br/>
<p>Return value<br/>
<span class='retname'>pressed</span> <span class='argtype'>(boolean)</span> &ndash; True if user clicked button<br/>
<p><p>
</p>
<pre class='example'>
if UiBlankButton(30, 30) then
	...
end

</pre>
<hr/>
<a name='UiSlider'></a><h3 class='function'>UiSlider</h3>
<pre class='funcdef'><span class='retname'>value, done = </span>UiSlider(<span class='argname'>path, axis, current, min, max</span>)</pre>
<p>Arguments<br/>
<span class='argname'>path</span> <span class='argtype'>(string)</span> &ndash; Image path (PNG or JPG file)<br/>
<span class='argname'>axis</span> <span class='argtype'>(string)</span> &ndash; Drag axis, must be "x" or "y"<br/>
<span class='argname'>current</span> <span class='argtype'>(number)</span> &ndash; Current value<br/>
<span class='argname'>min</span> <span class='argtype'>(number)</span> &ndash; Minimum value<br/>
<span class='argname'>max</span> <span class='argtype'>(number)</span> &ndash; Maximum value<br/>
<p>Return value<br/>
<span class='retname'>value</span> <span class='argtype'>(number)</span> &ndash; New value, same as current if not changed<br/>
<span class='retname'>done</span> <span class='argtype'>(boolean)</span> &ndash; True if user is finished changing (released slider)<br/>
<p><p>
</p>
<pre class='example'>
value = UiSlider("dot.png", "x", value, 0, 100)

</pre>
<hr/>
<a name='UiSliderHoverColorFilter'></a><h3 class='function'>UiSliderHoverColorFilter</h3>
<pre class='funcdef'><span class='retname'></span>UiSliderHoverColorFilter(<span class='argname'>r, g, b, a</span>)</pre>
<p>Arguments<br/>
<span class='argname'>r</span> <span class='argtype'>(number)</span> &ndash; Red channel<br/>
<span class='argname'>g</span> <span class='argtype'>(number)</span> &ndash; Green channel<br/>
<span class='argname'>b</span> <span class='argtype'>(number)</span> &ndash; Blue channel<br/>
<span class='argname'>a</span> <span class='argtype'>(number)</span> &ndash; Alpha channel<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Sets the slider hover color filter
<p>
</p>
<pre class='example'>
local slider = 0

function draw()
    local thumbPath = "common/thumb_I218_249_2430_49029.png"
    UiTranslate(200, 200)
    UiPush()
        UiMakeInteractive()
        UiPush()
            UiAlign("top right")
            UiTranslate(40, 3.4)
            UiColor(0.5291666388511658, 0.5291666388511658, 0.5291666388511658, 1)
            UiFont("regular.ttf", 27)
            UiText("slider")
        UiPop()
        UiTranslate(45.0, 3.0)
        UiPush()
            UiTranslate(0, 4.0)
            UiImageBox("common/rect_c#ffffff_o0.10_cr3.png", 301.0, 12.0, 4, 4)
        UiPop()
        UiTranslate(2, 0)
        UiSliderHoverColorFilter(1.0, 0.2, 0.2)
        UiSliderThumbSize(8, 20)
        slider = UiSlider(thumbPath, "x", slider * 295, 0, 295) / 295
    UiPop()
end

</pre>
<hr/>
<a name='UiSliderThumbSize'></a><h3 class='function'>UiSliderThumbSize</h3>
<pre class='funcdef'><span class='retname'></span>UiSliderThumbSize(<span class='argname'>width, height</span>)</pre>
<p>Arguments<br/>
<span class='argname'>width</span> <span class='argtype'>(number)</span> &ndash; Thumb width<br/>
<span class='argname'>height</span> <span class='argtype'>(number)</span> &ndash; Thumb height<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Sets the slider thumb size
<p>
</p>
<pre class='example'>
local slider = 0

function draw()
    local thumbPath = "common/thumb_I218_249_2430_49029.png"
    UiTranslate(200, 200)
    UiPush()
        UiMakeInteractive()
        UiPush()
            UiAlign("top right")
            UiTranslate(40, 3.4)
            UiColor(0.5291666388511658, 0.5291666388511658, 0.5291666388511658, 1)
            UiFont("regular.ttf", 27)
            UiText("slider")
        UiPop()
        UiTranslate(45.0, 3.0)
        UiPush()
            UiTranslate(0, 4.0)
            UiImageBox("common/rect_c#ffffff_o0.10_cr3.png", 301.0, 12.0, 4, 4)
        UiPop()
        UiTranslate(2, 0)
        UiSliderHoverColorFilter(1.0, 0.2, 0.2)
        UiSliderThumbSize(8, 20)
        slider = UiSlider(thumbPath, "x", slider * 295, 0, 295) / 295
    UiPop()
end

</pre>
<hr/>
<a name='UiGetScreen'></a><h3 class='function'>UiGetScreen</h3>
<pre class='funcdef'><span class='retname'>handle = </span>UiGetScreen(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>handle</span> <span class='argtype'>(number)</span> &ndash; Handle to the screen running this script or zero if none.<br/>
<p><p>
</p>
<pre class='example'>
--Turn off screen running current script
screen = UiGetScreen()
SetScreenEnabled(screen, false)

</pre>
<hr/>
<a name='UiNavComponent'></a><h3 class='function'>UiNavComponent</h3>
<pre class='funcdef'><span class='retname'>id = </span>UiNavComponent(<span class='argname'>w, h</span>)</pre>
<p>Arguments<br/>
<span class='argname'>w</span> <span class='argtype'>(number)</span> &ndash; Width of the component<br/>
<span class='argname'>h</span> <span class='argtype'>(number)</span> &ndash; Height of the component<br/>
<p>Return value<br/>
<span class='retname'>id</span> <span class='argtype'>(string)</span> &ndash; Generated ID of the component which can be used to get an info about the component state<br/>
<p>Declares a navigation component which participates in navigation using dpad buttons of a gamepad.
It's an abstract entity which can be focused. It has it's own size and position on screen accroding to 
UI cursor and passed arguments, but it won't be drawn on the screen. 
Note that all navigation components which are located outside of UiWindow borders won't participate 
in the navigation and will be considered as inactive
<p>
</p>
<pre class='example'>
function draw()
    -- window declaration is necessary for navigation to work
    UiWindow(1920, 1080)
    if LastInputDevice() == UI_DEVICE_GAMEPAD then
		-- active mouse cursor has higher priority over the gamepad control
		-- so it will reset focused components if the mouse moves
        UiSetCursorState(UI_CURSOR_HIDE_AND_LOCK)   
    end
    UiTranslate(960, 540)
    local id = UiNavComponent(100, 20)
    local isInFocus = UiIsComponentInFocus(id)
    if isInFocus then
        local rect = UiFocusedComponentRect()
        DebugPrint("Position: (" .. tostring(rect.x) .. ", " .. tostring(rect.y) .. "), Size: (" .. tostring(rect.w) .. ", " .. tostring(rect.h) .. ")")
    end
end

</pre>
<hr/>
<a name='UiIgnoreNavigation'></a><h3 class='function'>UiIgnoreNavigation</h3>
<pre class='funcdef'><span class='retname'></span>UiIgnoreNavigation(<span class='argname'>[ignore]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>ignore</span> <span class='argtype'>(boolean, optional)</span> &ndash; Whether ignore the navigation in a current UI scope or not.<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Sets a flag to ingore the navgation in a current UI scope or not. By default, if argument isn't
specified, the function sets the flag to true. If ignore is set to true, all components after the function call
won't participate in navigation as if they didn't exist on a scene. Flag resets back to false
after leaving the UI scope in which the function was called.
<p>
</p>
<pre class='example'>
function draw()
    -- window declaration is necessary for navigation to work
    UiWindow(1920, 1080)
    if LastInputDevice() == UI_DEVICE_GAMEPAD then
		-- active mouse cursor has higher priority over the gamepad control
		-- so it will reset focused components if the mouse moves
        UiSetCursorState(UI_CURSOR_HIDE_AND_LOCK)   
    end
    UiTranslate(960, 540)
    UiNavComponent(100, 20)

	UiTranslate(150, 40)
	UiPush()
		UiIgnoreNavigation(true)
		local id = UiNavComponent(100, 20)
		local isInFocus = UiIsComponentInFocus(id)
		-- will be always "false"
		DebugPrint(isInFocus)
	UiPop()
end

</pre>
<hr/>
<a name='UiResetNavigation'></a><h3 class='function'>UiResetNavigation</h3>
<pre class='funcdef'><span class='retname'></span>UiResetNavigation(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Resets navigation state as if none componets before the function call were declared
<p>
</p>
<pre class='example'>
function draw()
    -- window declaration is necessary for navigation to work
    UiWindow(1920, 1080)
    if LastInputDevice() == UI_DEVICE_GAMEPAD then
		-- active mouse cursor has higher priority over the gamepad control
		-- so it will reset focused components if the mouse moves
        UiSetCursorState(UI_CURSOR_HIDE_AND_LOCK)   
    end
    UiTranslate(960, 540)
    local id = UiNavComponent(100, 20)

	UiResetNavigation()
	UiTranslate(150, 40)
	UiNavComponent(100, 20)

	local isInFocus = UiIsComponentInFocus(id)
	-- will be always "false"
	DebugPrint(isInFocus)
end

</pre>
<hr/>
<a name='UiNavSkipUpdate'></a><h3 class='function'>UiNavSkipUpdate</h3>
<pre class='funcdef'><span class='retname'></span>UiNavSkipUpdate(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Skip update of the whole navigation state in a current draw. Could be used to override
behaviour of navigation in some cases. See an example.
<p>
</p>
<pre class='example'>
function draw()
    -- window declaration is necessary for navigation to work
    UiWindow(1920, 1080)
    if LastInputDevice() == UI_DEVICE_GAMEPAD then
		-- active mouse cursor has higher priority over the gamepad control
		-- so it will reset focused components if the mouse moves
        UiSetCursorState(UI_CURSOR_HIDE_AND_LOCK)   
    end
    UiTranslate(960, 540)
	UiNavComponent(100, 20)

	UiTranslate(0, 50)
    local id = UiNavComponent(100, 20)
	local isInFocus = UiIsComponentInFocus(id)

	if isInFocus and InputPressed("menu_up") then
		-- don't let navigation to update and if component in focus
		-- and do different action
		UiNavSkipUpdate()
		DebugPrint("Navigation action UP is overrided")
	end
end

</pre>
<hr/>
<a name='UiIsComponentInFocus'></a><h3 class='function'>UiIsComponentInFocus</h3>
<pre class='funcdef'><span class='retname'>focus = </span>UiIsComponentInFocus(<span class='argname'>id</span>)</pre>
<p>Arguments<br/>
<span class='argname'>id</span> <span class='argtype'>(string)</span> &ndash; Navigation id of the component<br/>
<p>Return value<br/>
<span class='retname'>focus</span> <span class='argtype'>(boolean)</span> &ndash; Flag whether the component in focus on not<br/>
<p>Returns the flag whether the component with specified id is in focus or not
<p>
</p>
<pre class='example'>
function draw()
    -- window declaration is necessary for navigation to work
    UiWindow(1920, 1080)
    if LastInputDevice() == UI_DEVICE_GAMEPAD then
		-- active mouse cursor has higher priority over the gamepad control
		-- so it will reset focused components if the mouse moves
        UiSetCursorState(UI_CURSOR_HIDE_AND_LOCK)   
    end

    UiTranslate(960, 540)

	local gId = UiNavGroupBegin()

	UiNavComponent(100, 20)
	UiTranslate(0, 50)
    local id = UiNavComponent(100, 20)
	local isInFocus = UiIsComponentInFocus(id)

	UiNavGroupEnd()

	local groupInFocus = UiIsComponentInFocus(gId)


	if isInFocus then
		DebugPrint(groupInFocus)
	end
end

</pre>
<hr/>
<a name='UiNavGroupBegin'></a><h3 class='function'>UiNavGroupBegin</h3>
<pre class='funcdef'><span class='retname'>id = </span>UiNavGroupBegin(<span class='argname'>[id]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>id</span> <span class='argtype'>(string, optional)</span> &ndash; Name of navigation group. If not presented, will be generated automatically.<br/>
<p>Return value<br/>
<span class='retname'>id</span> <span class='argtype'>(string)</span> &ndash; Generated ID of the group which can be used to get an info about the group state<br/>
<p>Begins a scope of a new navigation group. Navigation group is an entity which aggregates
all navigation components which was declared in it's scope. The group becomes a parent entity 
for all aggregated components including inner group declarations. During the navigation update process
the game engine first checks the focused componet for proximity to components in the same group,
and then if none neighbour was found the engine starts to search for the closest group and the 
closest component inside that group.
Navigation group has the same properties as navigation component, that is id, width and height.
Group size depends on its children common bounding box or it can be set explicitly.
Group is considered in focus if any of its child is in focus.
<p>
</p>
<pre class='example'>
function draw()
    -- window declaration is necessary for navigation to work
    UiWindow(1920, 1080)
    if LastInputDevice() == UI_DEVICE_GAMEPAD then
		-- active mouse cursor has higher priority over the gamepad control
		-- so it will reset focused components if the mouse moves
        UiSetCursorState(UI_CURSOR_HIDE_AND_LOCK)   
    end

    UiTranslate(960, 540)

	local gId = UiNavGroupBegin()

	UiNavComponent(100, 20)
	UiTranslate(0, 50)
    local id = UiNavComponent(100, 20)
	local isInFocus = UiIsComponentInFocus(id)

	UiNavGroupEnd()

	local groupInFocus = UiIsComponentInFocus(gId)


	if isInFocus then
		DebugPrint(groupInFocus)
	end
end

</pre>
<hr/>
<a name='UiNavGroupEnd'></a><h3 class='function'>UiNavGroupEnd</h3>
<pre class='funcdef'><span class='retname'></span>UiNavGroupEnd(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Ends a scope of a new navigation group. All components before that call become
children of that navigation group.
<p>
</p>
<pre class='example'>
function draw()
    -- window declaration is necessary for navigation to work
    UiWindow(1920, 1080)
    if LastInputDevice() == UI_DEVICE_GAMEPAD then
		-- active mouse cursor has higher priority over the gamepad control
		-- so it will reset focused components if the mouse moves
        UiSetCursorState(UI_CURSOR_HIDE_AND_LOCK)   
    end

    UiTranslate(960, 540)

	local gId = UiNavGroupBegin()

	UiNavComponent(100, 20)
	UiTranslate(0, 50)
    local id = UiNavComponent(100, 20)
	local isInFocus = UiIsComponentInFocus(id)

	UiNavGroupEnd()

	local groupInFocus = UiIsComponentInFocus(gId)


	if isInFocus then
		DebugPrint(groupInFocus)
	end
end

</pre>
<hr/>
<a name='UiNavGroupSize'></a><h3 class='function'>UiNavGroupSize</h3>
<pre class='funcdef'><span class='retname'></span>UiNavGroupSize(<span class='argname'>w, h</span>)</pre>
<p>Arguments<br/>
<span class='argname'>w</span> <span class='argtype'>(number)</span> &ndash; Width of the component<br/>
<span class='argname'>h</span> <span class='argtype'>(number)</span> &ndash; Height of the component<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Set a size of current navigation group explicitly. Can be used in cases when it's needed
to limit area occupied by the group or make it bigger than total occupied area by children
in order to catch focus from near neighbours.
<p>
</p>
<pre class='example'>
function draw()
    -- window declaration is necessary for navigation to work
    UiWindow(1920, 1080)
    if LastInputDevice() == UI_DEVICE_GAMEPAD then
		-- active mouse cursor has higher priority over the gamepad control
		-- so it will reset focused components if the mouse moves
        UiSetCursorState(UI_CURSOR_HIDE_AND_LOCK)   
    end
    
	UiTranslate(960, 540)

	local gId = UiNavGroupBegin()
	UiNavGroupSize(500, 300)

	UiNavComponent(100, 20)
	UiTranslate(0, 50)
    local id = UiNavComponent(100, 20)
	local isInFocus = UiIsComponentInFocus(id)

	UiNavGroupEnd()

	local groupInFocus = UiIsComponentInFocus(gId)

    if groupInFocus then
		-- get a rect of the focused component parent 
        local rect = UiFocusedComponentRect(1)
        DebugPrint("Position: (" .. tostring(rect.x) .. ", " .. tostring(rect.y) .. "), Size: (" .. tostring(rect.w) .. ", " .. tostring(rect.h) .. ")")
    end
end

</pre>
<hr/>
<a name='UiForceFocus'></a><h3 class='function'>UiForceFocus</h3>
<pre class='funcdef'><span class='retname'></span>UiForceFocus(<span class='argname'>id</span>)</pre>
<p>Arguments<br/>
<span class='argname'>id</span> <span class='argtype'>(string)</span> &ndash; Id of the component<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Force focus to the component with specified id.
<p>
</p>
<pre class='example'>
function draw()
    -- window declaration is necessary for navigation to work
    UiWindow(1920, 1080)
    if LastInputDevice() == UI_DEVICE_GAMEPAD then
        -- active mouse cursor has higher priority over the gamepad control
        -- so it will reset focused components if the mouse moves
        UiSetCursorState(UI_CURSOR_HIDE_AND_LOCK)   
    end
    
	UiPush()

    UiTranslate(960, 540)

    local id1 = UiNavComponent(100, 20)
    UiTranslate(0, 50)
    local id2 = UiNavComponent(100, 20)

	UiPop()

    local f1 = UiIsComponentInFocus(id1)
    local f2 = UiIsComponentInFocus(id2)

    local rect = UiFocusedComponentRect()
    UiPush()
        UiColor(1, 0, 0)
        UiTranslate(rect.x, rect.y)
        UiRect(rect.w, rect.h)
    UiPop()

    if InputPressed("menu_accept") then
        UiForceFocus(id2)
    end
end

</pre>
<hr/>
<a name='UiFocusedComponentId'></a><h3 class='function'>UiFocusedComponentId</h3>
<pre class='funcdef'><span class='retname'>id = </span>UiFocusedComponentId(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>id</span> <span class='argtype'>(string)</span> &ndash; Id of the focused component<br/>
<p>Returns an id of the currently focused component
<p>
</p>
<pre class='example'>
function draw()
    -- window declaration is necessary for navigation to work
    UiWindow(1920, 1080)
    if LastInputDevice() == UI_DEVICE_GAMEPAD then
        -- active mouse cursor has higher priority over the gamepad control
        -- so it will reset focused components if the mouse moves
        UiSetCursorState(UI_CURSOR_HIDE_AND_LOCK)   
    end

	UiPush()
    
    UiTranslate(960, 540)

    local id1 = UiNavComponent(100, 20)
    UiTranslate(0, 50)
    local id2 = UiNavComponent(100, 20)

	UiPop()

    local f1 = UiIsComponentInFocus(id1)
    local f2 = UiIsComponentInFocus(id2)

    local rect = UiFocusedComponentRect()
    UiPush()
        UiColor(1, 0, 0)
        UiTranslate(rect.x, rect.y)
        UiRect(rect.w, rect.h)
    UiPop()

    DebugPrint(UiFocusedComponentId())
end

</pre>
<hr/>
<a name='UiFocusedComponentRect'></a><h3 class='function'>UiFocusedComponentRect</h3>
<pre class='funcdef'><span class='retname'>rect = </span>UiFocusedComponentRect(<span class='argname'>[n]</span>)</pre>
<p>Arguments<br/>
<span class='argname'>n</span> <span class='argtype'>(number, optional)</span> &ndash; Take n-th parent of the focused component insetad of the component itself<br/>
<p>Return value<br/>
<span class='retname'>rect</span> <span class='argtype'>(table)</span> &ndash; Rect object with info about the component bounding rectangle<br/>
<p>Returns a bounding rect of the currently focused component. If the arg "n" is specified
the function return a rect of the n-th parent group of the component.
The rect contains the following fields:
w - width of the component
h - height of the component
x - x position of the component on the canvas
y - y position of the component on the canvas
<p>
</p>
<pre class='example'>
function draw()
    -- window declaration is necessary for navigation to work
    UiWindow(1920, 1080)
    if LastInputDevice() == UI_DEVICE_GAMEPAD then
        -- active mouse cursor has higher priority over the gamepad control
        -- so it will reset focused components if the mouse moves
        UiSetCursorState(UI_CURSOR_HIDE_AND_LOCK)   
    end
    
    UiPush()

    UiTranslate(960, 540)

    local id1 = UiNavComponent(100, 20)
    UiTranslate(0, 50)
    local id2 = UiNavComponent(100, 20)

    UiPop()

    local f1 = UiIsComponentInFocus(id1)
    local f2 = UiIsComponentInFocus(id2)

    local rect = UiFocusedComponentRect()
    UiPush()
        UiColor(1, 0, 0)
        UiTranslate(rect.x, rect.y)
        UiRect(rect.w, rect.h)
    UiPop()
end

</pre>
<hr/>
<a name='UiGetItemSize'></a><h3 class='function'>UiGetItemSize</h3>
<pre class='funcdef'><span class='retname'>x, y = </span>UiGetItemSize(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>x</span> <span class='argtype'>(number)</span> &ndash; Width<br/>
<span class='retname'>y</span> <span class='argtype'>(number)</span> &ndash; Height<br/>
<p>Returns the last ui item size
<p>
</p>
<pre class='example'>
function draw()
    UiTranslate(200, 200)
    UiPush()
        UiBeginFrame()
            UiFont("regular.ttf", 30)
            UiText("Text")
        UiEndFrame()
        w, h = UiGetItemSize()
        DebugPrint(w .. " " .. h)
    UiPop()
end

</pre>
<hr/>
<a name='UiAutoTranslate'></a><h3 class='function'>UiAutoTranslate</h3>
<pre class='funcdef'><span class='retname'></span>UiAutoTranslate(<span class='argname'>value</span>)</pre>
<p>Arguments<br/>
<span class='argname'>value</span> <span class='argtype'>(boolean)</span> &ndash; <br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Enables/disables auto autotranslate function when measuring the item size
<p>
</p>
<pre class='example'>
function draw()
    UiPush()
        UiBeginFrame()
            if InputDown("interact") then
                UiAutoTranslate(false)
            else
                UiAutoTranslate(true)
            end
            
            UiRect(50, 50)
            local w, h = UiGetItemSize()
            DebugPrint(math.ceil(w) .. "x" .. math.ceil(h))
        UiEndFrame()
    UiPop()
end

</pre>
<hr/>
<a name='UiBeginFrame'></a><h3 class='function'>UiBeginFrame</h3>
<pre class='funcdef'><span class='retname'></span>UiBeginFrame(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Call to start measuring the content size. After drawing part of the 
interface, call UiEndFrame to get its size. Useful when you want the 
size of the image box to match the size of the content.
<p>
</p>
<pre class='example'>
function draw()
	UiPush()
        UiBeginFrame()
            UiColor(1.0, 1.0, 0.8)
            UiTranslate(UiCenter(), 300)
            UiFont("bold.ttf", 40)
            UiText("Hello")
        local panelWidth, panelHeight = UiEndFrame()
        DebugPrint(math.ceil(panelWidth) .. "x" .. math.ceil(panelHeight))
    UiPop()
end

</pre>
<hr/>
<a name='UiResetFrame'></a><h3 class='function'>UiResetFrame</h3>
<pre class='funcdef'><span class='retname'></span>UiResetFrame(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Resets the current frame measured values
<p>
</p>
<pre class='example'>
function draw()
    UiPush()
        UiTranslate(UiCenter(), 300)
        UiFont("bold.ttf", 40)
        UiBeginFrame()
            UiTextButton("Button1")
            UiTranslate(200, 0)
            UiTextButton("Button2")
        UiResetFrame()
        local panelWidth, panelHeight = UiEndFrame()
        DebugPrint("w: " .. panelWidth .. "; h:" .. panelHeight)
    UiPop()
end

</pre>
<hr/>
<a name='UiFrameOccupy'></a><h3 class='function'>UiFrameOccupy</h3>
<pre class='funcdef'><span class='retname'></span>UiFrameOccupy(<span class='argname'>width, height</span>)</pre>
<p>Arguments<br/>
<span class='argname'>width</span> <span class='argtype'>(number)</span> &ndash; Width<br/>
<span class='argname'>height</span> <span class='argtype'>(number)</span> &ndash; Height<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Occupies some space for current frame (between UiBeginFrame and UiEndFrame)
<p>
</p>
<pre class='example'>
function draw()
	UiPush()
        UiBeginFrame()
            UiColor(1.0, 1.0, 0.8)
            UiRect(200, 200)
            UiRect(300, 200)
            UiFrameOccupy(500, 500)
        local panelWidth, panelHeight = UiEndFrame()
        DebugPrint(math.ceil(panelWidth) .. "x" .. math.ceil(panelHeight))
    UiPop()
end

</pre>
<hr/>
<a name='UiEndFrame'></a><h3 class='function'>UiEndFrame</h3>
<pre class='funcdef'><span class='retname'>width, height = </span>UiEndFrame(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>width</span> <span class='argtype'>(number)</span> &ndash; Width of content drawn between since UiBeginFrame was called<br/>
<span class='retname'>height</span> <span class='argtype'>(number)</span> &ndash; Height of content drawn between since UiBeginFrame was called<br/>
<p><p>
</p>
<pre class='example'>
function draw()
	UiPush()
        UiBeginFrame()
            UiColor(1.0, 1.0, 0.8)
            UiRect(200, 200)
            UiRect(300, 200)
        local panelWidth, panelHeight = UiEndFrame()
        DebugPrint(math.ceil(panelWidth) .. "x" .. math.ceil(panelHeight))
    UiPop()
end

</pre>
<hr/>
<a name='UiFrameSkipItem'></a><h3 class='function'>UiFrameSkipItem</h3>
<pre class='funcdef'><span class='retname'></span>UiFrameSkipItem(<span class='argname'>skip</span>)</pre>
<p>Arguments<br/>
<span class='argname'>skip</span> <span class='argtype'>(boolean)</span> &ndash; Should skip item<br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Sets whether to skip items in current ui scope for current ui frame. This items won't affect on the frame size
<p>
</p>
<pre class='example'>
function draw()
	UiPush()
		UiBeginFrame()
			UiFrameSkipItem(true)
			--[[
				...
			]]
		UiEndFrame()
	UiPop()
end

</pre>
<hr/>
<a name='UiGetFrameNo'></a><h3 class='function'>UiGetFrameNo</h3>
<pre class='funcdef'><span class='retname'>frameNo = </span>UiGetFrameNo(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>frameNo</span> <span class='argtype'>(number)</span> &ndash; Frame number since the level start<br/>
<p><p>
</p>
<pre class='example'>
function draw()
	local fNo = GetFrame()
	DebugPrint(fNo)
end

</pre>
<hr/>
<a name='UiGetLanguage'></a><h3 class='function'>UiGetLanguage</h3>
<pre class='funcdef'><span class='retname'>index = </span>UiGetLanguage(<span class='argname'></span>)</pre>
<p>Arguments<br/>
<span class='argname'>none</span>
<p>Return value<br/>
<span class='retname'>index</span> <span class='argtype'>(number)</span> &ndash; Language index<br/>
<p><p>
</p>
<pre class='example'>
local n = UiGetLanguage()

</pre>
<hr/>
<a name='UiSetCursorState'></a><h3 class='function'>UiSetCursorState</h3>
<pre class='funcdef'><span class='retname'></span>UiSetCursorState(<span class='argname'>state</span>)</pre>
<p>Arguments<br/>
<span class='argname'>state</span> <span class='argtype'>(number)</span> &ndash; <br/>
<p>Return value<br/>
<span class='retname'>none</span>
<p>Possible values are: <br> 0 - show cursor (UI_CURSOR_SHOW) <br> 1 - hide cursor (UI_CURSOR_HIDE) <br> 2 - hide & lock cursor (UI_CURSOR_HIDE_AND_LOCK)<br><br>
Allows you to force visibilty of cursor for next frame. If the cursor is hidden, gamepad navigation methods are used.<br>
By default, in case of entering interactive UI state with gamepad, cursor will be shown and will be controlled using gamepad.<br>
Thus, if you need to implement navigation using the gamepad's D-pad, you should call this function.
<p>
</p>
<pre class='example'>
#include "ui/ui_helpers.lua"

function draw()
	UiPush()
		-- If the last input device was a gamepad, hide the cursor and proceed to control through D-pad navigation
		if LastInputDevice() == UI_DEVICE_GAMEPAD then
			UiSetCursorState(UI_CURSOR_HIDE_AND_LOCK)
		end

        UiMakeInteractive()
        UiAlign("center")
        UiColor(1.0, 1.0, 1.0)
		UiButtonHoverColor(1.0, 0.5, 0.5)
        UiFont("regular.ttf", 50)
        UiTranslate(UiCenter(), 200)
    
        UiTranslate(0, 100)
        if UiTextButton("1") then
            DebugPrint(1)
        end
        UiTranslate(0, 100)
        if UiTextButton("2") then
            DebugPrint(2)
        end
	UiPop()
end

</pre>
<hr/>
</body>
</html>
